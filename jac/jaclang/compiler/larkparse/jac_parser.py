# The file was automatically generated by Lark v1.1.9
__version__ = "1.1.9"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)


class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    # --
    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        # --
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        # --
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    # --
    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    # --

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    # --

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    # --

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass


import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    # --

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##

        return inst


class SerializeMemoizer(Serialize):
    # --

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(
        cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]
    ) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            ##

            ##

            MAXWIDTH = getattr(sre_parse, "MAXWIDTH", sre_constants.MAXREPEAT)
            if c.match("") is None:
                ##

                return 1, int(MAXWIDTH)
            else:
                return 0, int(MAXWIDTH)


from collections import OrderedDict


class Meta:

    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    # --

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        # --
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        # --
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        # --
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##
                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        # --
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        # --
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        # --
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    # --

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##


class _Decoratable:
    # --

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):

            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    # --
    __visit_tokens__ = True  ##

    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        # --
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        # --
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        # --
        return Tree(data, children, meta)

    def __default_token__(self, token):
        # --
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    # --
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):

    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    # --
    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    # --

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    # --
    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##


class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        # --
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    # --

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        # --
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        # --
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    # --

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        # --
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        # --
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    # --

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    # --
    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##


def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    # --
    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    # --
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec


TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    # --
    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion


from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    # --

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    # --
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    # --
    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token": ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token": ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token": ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token": ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    # --

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        # --
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    # --
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    # --

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    # --

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    # --
    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        # --
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None: ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token: ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = lexer_state.last_token  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##


_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = (
    'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
)
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start


from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##

            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    # --

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    # --
    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    # --
    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    # --

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            # --

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:

            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks


class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    # --
    pass


class IntParseTable(ParseTableBase[int]):
    # --

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)


class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##
            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]


class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        # --
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise


class InteractiveParser:
    # --
    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        # --
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        # --
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        # --
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        # --
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        # --
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        # --
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        # --
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        # --
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        # --
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        # --
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    # --

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        # --
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        # --
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)


def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser


class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    # --

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    # --

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except Exception:  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(lexer, Lexer)  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        # --
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        # --
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##
        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        # --
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options,
    ) -> _T:
        # --
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        # --
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        # --
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        # --
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        # --
        return self.parser.parse(text, start=start, on_error=on_error)


class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8


import pickle, zlib, base64

DATA = b"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/Sj/rBZ+aN8yUy38ONvZVFyh32Y726j6FO37XKcWErnOlml21lyrnuqzg1d2xIzudqlWCzdmDYr9L9+zN4QsZ2BwhXLsudH31UKRvWDvvimxFy6qh3le5SV1w2T7hgp7LeU4I7crVGYv/MAuylnOt9FlvX3Qrnyu0B/sG36obvi8yh+pG+bZd/0Xe4eh/ZMfq58MOkOuK7TI/slP1A33D9qjvMtaofKn6gdB+weX1cLP7Ff7M3trtW+x9x+W5jqjhiv0bvuWn6uFVTnO6OcKVdo/+oVauBX7rkb3UI3ukJqlFn6T7XyT1Ou1f/2XamFNjviG5uo9IePl+WopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBopdBop3WkUi71i1o/FRqqRI5ErMUYiTyJfwi3hkfBK+CQKJMZKFEqMkyiSGC9RLFEiMUFiosQkiVKJyRJTBKJWySs3baO92mj39qdv2q7u1UbbuFebtv+Kpm2kWRtp3v6smrY/da+mmkLr9sH/dM82cmxwD87c2KP31k+wv0ymS7O+L9oyjekSMyRmSsySKJOYLVEuMUfCL1EhUSkxV6JIYrxEicQ8iUkSEyUmSLglpkgsklgmkSuxXGKFxCqJNRJrJbokNkjkSVRL1EgUStRJ1EtMlmiQ2CIRkhgj0SLRKrFdYqfELok9Eh0S10hcK5ElkS/hlfBJzJdYILFQYrHEEomlEgckVkqsliiQWCeRLbFeIiARlNgoUSWxSaJWYpxEqcRmCUuiUaJJIkdin8RWiW0SHomwRJvEWIl2iR0SxRK7JfZL7JVolugUiFoT/wubCbuHKLF/e7Sr+G9oJuw9B7/LHny1q/j/r6v4lVoY+6drL+ar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sV1ip8QuiT0SHRLXSFwrkSWRL+GV8EnMl1ggsVBiscQSiaUSByRWSqyWKJBYJ5EtsV4iIBGU2ChRJbFJolZinESpxGYJS6JRokkiR2KfxFaJbRIeibBEm8RYiXaJHRLFErsl9kvslWiW6BSIWrfLQ267nRFyqlTUusO+x8iYexbt4Fm0fGfRkJ1FI34WrfBZtGBnMSk4q1uUO+VVH5OYzCUxmUtiMpfEZC6JyVwSk7kkJnNJTOaSmMwlMZlLYjKXxGQuiclcEpO5JCZzSUzmkpjMJTGZS2Iyl8RkLonJXBKTuSQmc0lM5pKYzCUxmUtiMpfEZC6JyVwS6y2JyVwSk7kkJnNJTOaSmMwlMZlLYhtKYjKXxGQuiclcEpO5JCZzSUzmkpjMJTGZS2Iyl8QWnMRkLonJXBKTuSQmc0lM5pKYzCUxmUtiMpfEZC6JyVwSk7kkJnNJTOaS+PYmMZlLYjKXxDc7iclcEpO5JCZzSUzmkpjMJTGZS2Iyl8TYkcRkLonJXBKTuSRGkiQmc0lM5pKYzCUxmUtiMpfEZC6JyVwSk7kkJnNJTOaSmMwlMZlLYjKXxGQuiclcEpO5JCZzST1S3mWPlKssV2iXffBvir3T7IZsMfB8GkfsP43zGj6Ncyy0DklFrbvlQDwhWw7EWtdBWdA0aDo0A5oJzYLyoTJoNlQOeSEfNAfyQxVQJTQXKoLGQyXQPGgSNBGaAM2H3NAUaAG0EFoELYaWQEuhZVAutBxaAa2EVkGroQJoDbQWWgdlQ+uhALQBCkIboTyoCqqGaqBNUC1UCNVB46B6qBSaDG2GGqAtkAU1QiGoCcqBmqGt0DbIA7VArVAY2g61QWOhdmgHVAzthHZBu6E90F5oH9QB7ZeKWvfoS8vo236B5ugXeqi+11x8JtRsD9VT7X+mZJ4z/rpCnc5pdgNysE2j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j602j601jxabR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR9abR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PrQAWggtguqgxVA91AA1QksgJ+SClkLLoOVQE7QCWgmtglZDzVAL1Aq1Qe3QGqgD0qC1kA6tg9ZDbmgD1AlthDZBm6EtUBe0FeqGtkHboR3QTmgXtBvaA/VAe6FeKa/2dVVvU8nIHSQjd5B23kFOcge54R2kJneQi95BhnIHGcodpIh3kKHcQb5yB4nKHaRCd5Cd3UHacgfZ2R1kL3eQmd5BEnMHScwdJDFJHYDyoH2QE2qAcqFHoAroMehx6AnoEHQYqoSehKqhWugpqA7yQM9A9ZAXyocaoSPQUegYZIGehZ6DnoeOQycgH3QS6odOQaehFugF6EXIgMqgNugMdBY6B52HXoYuQBehS9BlyA91QgPQK1AAugJ1Q69CQcgKZUMFkA0qhIqgYqgEKoVypLzaN+SM/gQ6vhPowE6gTz2BjvYEus8TyYr823evTRUnrlT9u/S7rxyV775ingTmnE4tuW1Un+vOSpwJFv1rGUbyq5/NUt/rd05cSUzFzyeuc/2uvM7lR6Xyo/74Ufn9qOd+1CY/apMftcmPauRHpfKj+vlRQ/2oW37ULT9qth9VzI8q5kcV82O88qOm+VHT/KhpfoxQflQ4PyqcH9Xdj3rnR73zo975Ue/8GDH8qH5+VD8/qp8f1c+P6udH9fOj+vlR/fyofn5UPz+qnx/Vz4/q50f186P6+TFW+1EL/Rir/aiMflRGPyqjH5XRj8roR2X0ozL6URn9qIx+VEY/KqMfldGPyuhHZfSjMvpRGf2ojEl1QVegbuhVKAi9BoWg16E3oKvQm1AYugZdh96CbkA3oVvQbcgKZUMFkA0qhIqgYqgEKoVypLza751I3sC1IlFFv/kgtPw4h5afoKxS5bNvqn/bhxxaxlUPs0T1KRbVsTjV0UZ15FJHU6zqOb8vcz83uiQ3cj83+ik3cj83cj83cj83cj83Oi83cj83cj83cj83cj83cj83ukA3cj83cj83cj83cj83cj83cj83cj83cj83uk43cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj83cj93cpb5B6repnrYQtxnV4hdCwqxr0Vh8irNv5crfz6PCvJ5VJCkrNA0aDpUDlVAM6BsaCZkh2ZBuVAeNBuaA1VCc6EqqBAqgoqheVAJNBGaADmgHGgyVA3VQLXQfGgBtBBaBGVBddBiqB5qgBqhfGgJ5IRcUAa0FFoGLYeaoBXQGGgltApaDTVDLVAB1AqNh9qgUmgS1A6tgTogDVoL6dA6KBNaD7mhDdBYqBPaCG2CNkNboHFQF7QVskHd0DZoO7QD2gPthHZBu6W82h/KzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2IzC2YzNy+9SBl+xinbPpSlewMpBYJFr7P4E1fpr6sQH3u/5AI7qdK3vTl6tcwVj37A8vg3pb5Wie65U50d53o6pN6CBoDZUM50FgoF8qD8qFxUAE0HiqEiiAbVAxNgCZCJVApNAmaDJVBU6CHoanQNGg6VA5VQDOgmZAdmgXNhuZAldBcqAqaBzmgaqgGqoXmQwughdAiqA5aDNVDDVAjtARyQi5oKbQMWg41QSugldAqaDXUDLVArVAb1A6tgTogDVoL6dA6aD3khjZAndBGaBO0GdoCdUFboW5oG7Qd2gHthHZBu6E9UA+0F+qV8mp/9KB/+Rj3L5+kq4TpFkV1agXqe3wYVwnTGcle5M17k3nzH8tdTyoSz3geegR6FDoB+aB+qAI6DT0GPQ49AbVAL0CHoUqoFXoRegl6EqqF+qDz0FPQy1Ad9DR0EXoGqocuQQ1QJzQAvQJ5oXyoEeqCrkBHoW7oVSgIPQsdgMqgk9BBqBraD70GhaDXoTegq9Cb0DUoDF2H3oJuQDehW9BtKA/aBzmhXCgAFUJFUDFUAuVAFug4VAAZUBt0BjoLXYAuQ37ICmVDhyAPdAQ6Bp2CSqFzkE3Kq/0HWTeHkEkOIX0eQvo8hIRyCAnlEDLJISTTQ8gkh5BTDyGnHkIyPYT0cgjp5RCS6SEk00NINoeQbA4h2RxCaj2EnHoIOfUQ8sohpNZDSC+HkGEPIbUeQpY5hAx7CBn2EHLOISTaQ0g2h5BsDiHZHEL2PYTsewjZ9xBSzyGknkPIvoeQgQ4hAx1CBjqEJDypA1AZdBI6CFVD+6HXoBD0OvQGdBV6E7oGhaHr0FvQ3br5qtVitaj/7j58E0+6Bd2G8qB9kBPKhQLQMcgCHYI80BHoOHQKMqA26Ax0FjoHXYAuQ37ICmVDBZANKoSKoGKoBCqFcqS82v+VeoOELtW+puc5apPL/2pc0ceqoM6tNsPOVUd77s7jtK+aj+SpR65iM+1096zmR19VXzZOPWlEHRWoo79Mzbz+Xj00Xj30Q7mbtl6oHvpxapaYoaLWosS+4KmbAyaoh2yJ7dfVUbE6sqtPTlPfItV6V6vP5avPNauH7k4JvNqfyPFiEOPFIMaLQYwXgxgvBjFeDGK8GMR4MYjxYhDjxSDGi0GMF4MYLwYxXgxivBjEeDGI8WIQ48UgxotBjBeDGC8GMV4MYrwYxHgxiPFiEOPFIMaLQYwXgxgvBjFeDGK8GMR4MYjxYhDjxSDGi0GMF4MYLwYxXgxivBjEeDGI8WIQ48UgxotBjBeDGC8GMV4MYrwYxHgxiPFiEOPFIMaLQYwXgxgvBjFeDGK8GMR4MYjxYhDjxSDGi0GMF4MYLwbleHFXN6Fb0G0oD9oHOaFcKAAdgyzQIcgDHYGOQ6cgA2qDzkBnoXPQBegy5IesUDZUANmgQqgIKoZKoFIoR8qr/cfUWymvSOVjy1QBb0q8n4Kq2xnqaHaWkbw5ayBxc9b/rb7IpFYrSukpnG6nUGpOoXydQsE6hXJyKvnP+nbyVjKtSN238P+oVdgr1L8jJzXKfCMj8aey6Met4lWxD9lqUsegaimv9o76H0ld07DhmoYN1zRsuKZhwzUNG65p2HBNw4ZrGjZc07DhmoYN1zRsuKZhwzUNG65p2HA1yYarSTZcP7Lh6ocNV4xsuJpkw5UmG66P2XD9yIYrIzZc77DhepwNVz9suPphw/UOG65w2HCFw4bE2oarGEmNgVZBq6ECqBVqgyZBa6AOSIcegjqhjdBmqBvaBu2AdkNToIchK5QN5UJ5kAOqhmqg+dACaCG0F6qHGqF8yAVlQEuhZVATtAJaCTVDLdB4qBRqhzRoLbQOyoR2QW5oAzQW2gRtgcZBXdBWyAZth/ZAO6H1UI+UV/vTE8nLDS8l7kD7T/d2BdcvqSc8rf2ZLMHLM2UJTmo6VA5VQDOgmZAdmgXNhuZAldBcqAoqhIqgYmgeVAJNhCZAOdBkqBZaBGVBddBiqAFaAjmh5dAYaBW0GiqAWqE2aBK0BuqAdKgT2ghthrqhbdAOaDc0BXoYskLZUC6UBzmgaqgGmg8tgBZC9VAjlA+5oAxoKbQMaoJWQCuhZqgFGg+VQu2QBq2F1kGZ0C7IDW2AxkKboC3QOKgL2grZoO3QHmgntF7Kq/253LjheQxJz6NNeR6N1/MYLJ/H8PF8skj/Z7nd4qTEz34Oeh56BHoUOgH5oH6oAvoUdBp6DHocegJqgV6ADkOVUCv0IvQS9CRUC/VB56GnoJehOuhp6CL0DFQPXYIaoE5oAHoF8kL5UCPUBV2BjkLd0KtQEHoWOgCVQSehg1A19BoUgl6H3oCuQm9C16AwdB16C7oB3YRuQbehAJQH7YOcUC40BhoHjYcmQZlQFpQBjYUsUBt0DLJC2dAhqBAqgoqhEigH8kBHoOPQKagAMqBS6Ax0FjoHXYAuQ37IJuXVRmTkXY46XY46XY46XY46XY46XY46XY46XY7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KXI7KnNR+6DUoBL0OvQFdhd6ErkFh6Dr0FnQDugndgm5DedA+yAnlQgGoECqCiqESKAeyQMehAsiA2qAz0FnoAnQZ8kNWKBs6BHmgI9Ax6BRUCp2DbFJe7TvyFvAriMqSmgpZoWnQdKgcqoBmQNnQTMgOzYJyoTxoNjQHqoTmQlVQIVQEFUPzoBJoIjQBckA50GSoGqqBaqH50AJoIbQIyoLqoMVQPdQANUL50BLICbmgDGgptAxaDjVBK6Ax0EpoFbQaaoZaoAKoFRoPtUGl0CSoHVoDdUAatBbSoXVQJrQeckMboLFQJ7QR2gRthrZA46AuaCtkg7qhbdB2aAe0E9oF7Yb2SHm1/yJuvdJ+JF6kSWRKZEk8JDFGIlsiR2KsRK5EnkS+xDiJAonxEoUSRRI2iWKJCRITJUokSiUmSUwW8Gp/oX6VqWGmK1MOM0lNg5qgcmgFVAHNgOzQKmg11ALNhuZAlVAV1ArNg9qhaqgG6oBqoYWQBk2G1kK7oHqoE9oIbYI2Q1ugRqgL2gZth3ZALmg9tBTaDS2T8mp/+eAeno/zPTzqfpZ/tBqfzJt5PtR7eB7FhPbR5Nn0V3f3It6SoS5Y/vXdpSkJfPfuG4cn/wLpn53686dfz+l/TPpPoH7Pn8sQf7bUayj9z039/bza38hboBvRLTaiu2lEV5vUQ9AYKBvKgcZCuVAelA+Ngwqg8VAhVATZoGJoAjQRKoFKoUnQZKgMmgI9DE2FpkHToXKoApoBzYTs0CxoNjQHqoTmQlXQPMgBVUM1UC00H1oALYQWQXXQYqgeaoAaoSWQE3JBS6Fl0HKoCVoBrYRWQauhZqgFaoXaoHZoDdQBadBaSIfWQeshN7QB6oQ2QpugzdAWqAvaCnVD26Dt0A5oJ7QL2g3tgXqgvVCvlFf7W1Vv96nhJyNRGiz69xNbvX7v7gb30xK1/+9k/h7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYsxnHkvM4VnDGseQ8jiXncawDjWPJeRxLzuNYch7HkvM41ojGseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2MNbBxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeRxLzuNYch7HkvM4lpzHseQ8jiXncSw5j2PJeTy5tvvv71bRr2apKvpfUwvQJ6h159PUKm9vRqK4WLRK8SL9UzQESQWgK1AuVAbtgw5IebV/SBb/5GOtmA+04uJXa3J28P0Hc+2P81z7EzTFVrHCmY/Arvo/kLHyO+qUypDIlMiSeEhijES2RI7EWIlciTyJfIlxEgUS4yUKJYokbBLFEhMkJkqUSJRKTJKYLDFF4mGJqRLTJKZLlEtUSMyQmClhl5glMVtijkSlxFyJKol5Eg6JaokaiVqJ+RILJBZKLJKok1gsUS/RINEosUTCKeGSWCqxTGK5RJPEComVEqskVks0S7RItEq0SbRLrJHokNAk1kroEusk1ku4JTZIdEpslNgksVlii0SXxFaJboltEtsldkjslNglsVtij0SPxF6JXgGv9v/KOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+J7siJOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+Jfs+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+J7t2JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+JOM+ZnNH9Y3Ine4seyjKScZ4/cRvzfxMLwbSvi9KQxFQJq8Q0iekS5RIVEjMksiVmStglZknkSuRJzJaYI1EpMVeiSqJQokiiWGKeRInERIkJEg6JHInJEtUSNRK1EvMlFkgslFgkkSVRJ7FYol6iQaJRIl9iiYRTwiWRIbFUYpnEcokmiRUSYyRWSqySWC3RLNEiUSDRKjFeok2iVGKSRLvEGokOCU1irYQusU4iU2K9hFtig8RYiU6JjRKbJDZLbJEYJ9ElsVXCJtEtsU1iu8QOiZ0SuyR2S+yR6JHYK9Er4NX+P9l6amg9NbSeGlpPDa2nhtZTQ+upofXU0HpqaD01tJ4aWk8NraeG1lND66mh9dTQempoPTW0nhpaTw2tp4bWU0PrqaH11NB6amg9NbSeGlpPDa2nhtZTQ+upofXU0HpqaD01tJ4aWk8NraeG1lND66mh9dTQempoPTW0nhpaTw2tp4bWU0PrqaH11NB6amg9NbSeGlpPDa2nhtZTQ+upofXU0HpqaD01tJ4aWk8NraeG1lND66mh9dTQempoPTW0nhpaTw2tp4bWU0PrqaH11NB6amg9NbSeGlpPDa2nhtZTQ+upofXU0HpqaD01tJ4aWk8NraeG1lND66mh9dTQempoPTW0nhpaTw2tp4bWU0PrqaH11NB6amg9NbSeWrL1/O8nku9uXp14S/QfquqbZz7we4k6aNFXZhrJN+jdqi5+lKqLH62JiPRH6pmpK0+n8Bs4hep7Cn/9UzjvTqGKHkfdPI46dhy1/zhq/3GMEsdR0Y8n/y//h/rXqsj6GdVgpy48uzLkizap56HD0BWoAeqGDkBl0EmoGtoP5UFOKBcKQMcgC3Qc2gcdhE5BhyADaoPOQGehc5AHugBdhvzQESmv9mP1x01dQkhfzHr3NW/py1yjF7+lLpukLqP8g1pZgcsGqatI6Qsr6esI6eseqQtM6irK9zIMcY0rfe0lfQUnda0odSXHq/3T3YuPFxJLOP6n2lmqUZ12DVYjeblrc2biT2zRfyPDSD51dqaRPIm/pvYeHKOefTSxLO9/pb5aK7j7NV/Lkt9FffHns97li/9Z3oU0PkN2B0lNhazQNGg6VA5VQDOgbGgmZIdmQblQHjQbmgNVQnOhKqgQKoKKoXlQCTQRmgA5oBxoMlQN1UC10HxoAbQQWgRlQXXQYqgeaoAaoXxoCeSEXFAGtBRaBi2HmqAV0BhoJbQKWg01Qy1QAdQKjYfaoFJoEtQOrYE6IA1aC+nQOigTWg+5oQ3QWKgT2ghtgjZDW6BxUBe0FbJB3dA2aDu0A9oJ7YJ2Q3ukvNq/qEqpUruXsoxk23QuUcr/94OFFw8WXnwsFl58KOst1IlyKvXuKEGswNAt1uSOPxb9r9UXp/rpA1jtlJBXtyaem2pqki3MWvWvUV++W52JeoZVNjOfRdTxWUQdSVmhadB0qByqgGZA2dBMyA7NgnKhPGg2NAeqhOZCVVAhVAQVQ/OgEmgiNAFyQDnQZKgaqoFqofnQAmghtAjKguqgxVA91AA1QvnQEsgJuaAMaCm0DFoONUEroDHQSmgVtBpqhlqgAqgVGg+1QaXQJKgdWgN1QBq0FtKhdVAmtB5yQxugsVAntBHaBG2GtkDjoC5oK2SDuqFt0HZoB7QT2gXthvZIefVMU4nK+WU1AdWzrHJTt/P4i5/HX/U8fufnca6dx6v9PH7L53Hen0/+Kx5K1/8/UjV9parpYXWLg1neU/c+/LnVSF4svabmq3q29UG79VO2W2oAXqO+9kHf9Qnou+51WTmJU0blQn+rwp9EzlSXafyrhOir6qvvkxDpY62pic/D6impMPE7iVmRnpv4rLotdZ9VfPawVbZwhzFoJLVfyqvnvct5nT6df0/9q3GmJ26IyjSSdWxl1i/klE+f4KPP/Z/xlFdn5/qsn9e5/9Od8mqxyuYP+9z/12ntg3P/Jzj38zElimFKFMOUKIYpUQxTohimRDFMiWKYEsUwJYphShTDlCiGKVEMU6IYpkQxTIlimBLFMCWKYUoUw5QohilRDFOiGKZEMUyJYpgSxTAlimFKFMOUKIYpUQxTohimRDG0RjFMiWKYEsUwJYphShTDlCiGKVEMbVoMU6IYpkQxTIlimBLFMCWKYUoUw5QohilRDFOiGJrEGKZEMUyJYpgSxTAlimFKFMOUKIYpUQxTohimRDFMiWKYEsUwJYphShRDgxzD6BbDlCiG5jmGKVEMU6IYpkQxTIlimBLFMCWKYUoUQ3sew5QohilRDFOiGJr1GKZEMUyJYpgSxTAlimFKFMOUKIYpUQxTohimRDFMiWKYEsUwJYphShTDlCiGKVEMU6IYpkSxZAcyLlEqx5il81NqMjJRdUD/I9EBFViTKzeTT+9BOtWTTKfGW+XNRP9LvMSTyJTIknhIYoxEtkSOxFiJXIk8iXyJcRIFEuMlCiWKJGwSxRITJCZKlEiUSkySmCzg1Qvx6z6HS9hJPQI9Ch2EKqDHoMehQ9ATUC6UBx2GKqH90JNQNVQL9UFPQXWQB3oaegaqhxogL5QPNUJHICd0FDoGWaBnoeeg56Hj0AnIB52E+qFT0GmoBXoBaoVehF6CDKgMaoPOQGehc9B56GXoAnQRugRdhvxQJzQAvQIFoC7oCtQNvQoFodegEPQ69AZ0FXoTCkPXoOvQW9AN6CZ0C7oNWaFsqACyQYVQEVQMlUClUI6UVy+y3l1V8sVEqGdL1FH17mRN8t3J9mB4TeoYVC3l1Yvl2KZvQP+2Af3GBvSZST0EjYGyoRxoLJQL5UH50DioABoPFUJFkA0qhiZAE6ESqBSaBE2GyqAp0MPQVGgaNB0qhyqgGdBMyA7NgmZDc6BKaC5UBc2DHFA1VAPVQvOhBdBCaBFUBy2G6qEGqBFaAjkhF7QUWgYth5qgFdBKaBW0GmqGWqBWqA1qh9ZAHZAGrYV0aB20HnJDG6BOaCO0CdoMbYG6oK1QN7QN2g7tgHZCu6Dd0B6oB9oL9Up59QlWvGmyeq/kT5szklVqRjIGb6P8O+an/kq+jXLqzZNTadm9t1V+z7dTTmdqP+n7Kqejt/d4g+VUeni/N1perZYt/q2hGnyLFjHu5Vz33oL5XoyaCh1TEZh4c+Z0GDbqXZpTiVzy3ZpLE1eXJqYGyrrEQFli/YmvKf3A/KZrjAfXlh4s5flExsqlVrk70Q/QwvwgWcQmya5R+zPRNCaRKZEl8ZDEGIlsiRyJsRK5EnkS+RLjJAokxksUShRJ2CSKJSZITJQokSiVmCQxWWKKxMMSUyWmSUyXKJeokJghMVPCLjFLYrbEHIlKibkSVRLzJBwS1RI1ErUS8yUWSCyUWCRRJ7FYol6iQaJRYomEU8IlsVRimcRyiSaJFRIrJVZJrJZolmiRaJVok2iXWCPRIaFJrJXQJdZJrJdwS2yQ6JTYKLFJYrPEFokuia0S3RLbJLZL7JDYKbFLYrfEHokeib0SvQJefbI1dd38a/LK+AF03kntl/LqZVb5Roh/hqlIUgHoCpQLlUH7oANSXn1K4semTugR+XcYkX+HEXkOj8gTYES+mEfk2TAif6cj8hU3IovaiCxqI7KojciTZkQWtRFZx0Zk6RqRZ9CIPINGZB0bkQVqRJ5BI7KWj8gzaEQWqBFZukZk+R6RNWlEnlsj8twakS+/EXk2jMjX/Ih8MY/IF/OIPAVHZOUZSfxpH7amtjdckeoFl1mN5Abih8zeuEm14bp5kKEOVqkvmWr9mC60Un39v+DGrw9zxZXWbvwCuuPD5sE3rcaDNvmj1SZPs45e3/itxAx0ulVmqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg4MFA5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg4MfQ5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg40Mg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg50dg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqg5kqo5kc1tuvf9bpDxnHlzNNN7Xe6WkMtVsVcc/k8pff0eOBqkxOz1Mpq663cAyhhvJC3YVVtnoj+D8GEGjP4JGfwT1ewTVbgSN/gga/ZHk72KGVb5lQA8uu/dgOUIPllv04CJ8DxYn9OCyew8uS/dgOUIPliP04JJ1D5Zp9GCpQg8WbfTgknUPLln3YAlHDy7s9+Cifw8WbfRg+UMPlj/0YKFED5Z+9OAyeA8WQ/TgongPLor34KJ4D5ZGJHUAKoNOQtXQfigXyoOcUAA6Blmg49A+6CB0CjoEGVAbdAY6C52DPNAF6DLkh45IefWZ1n9jCXp66vNxXmf+IP7/6K8qV/cC/Fj96I/6BMdulUv1LqEWXMLYkdSj0EGoAnoMehw6BD0B5UJ50GGoEtoPPQlVQ7VQH/QUVAd5oKehZ6B6qAHyQvlQI3QEckJHoWOQBXoWeg56HjoOnYB80EmoHzoFnYZaoBegVuhF6CXIgMqgNugMdBY6B52HXoYuQBehS9BlyA91QgPQK1AA6oKuQN3Qq1AQeg0KQa9Db0BXoTehMHQNug69Bd2AbkK3oNuQFcqGCiAbVAgVQcVQCVQK5Uh59Vnv0mt85NPVj1evoS9PLPpQg9bPqevQl6qfMKA+p0btwvfZiOjL1JcVqM89iFo/iE5ktlUuN/iqOuUyJCZJZEr0SGRJbJDYKzFGIltirMQsiV6JPIl8iXESBRLjJQoliiRsEsUSJRITJSZIlErkSEwW8OpzrPLews8gV/0MctWkrNA0aDpUDlVAM6BsaCZkh2ZBuVAeNBuaA1VCc6EqqBAqgoqheVAJNBGaADmgHGgyVA3VQLXQfGgBtBBaBGVBddBiqB5qgBqhfGgJ5IRcUAa0FFoGLYeaoBXQGGgltApaDTVDLVAB1AqNh9qgUmgS1A6tgTogDVoL6dA6KBNaD7mhDdBYqBPaCG2CNkNboHFQF7QVskHd0DZoO7QD2gntgnZDe6S8eqVVJq79mD31Y57cj3lyP+ZS/ZhL9WP21I85dD9mT/2YUfdjRt2POXQ/5ln9mGf1Yw7djzl0P+Zg/ZiD9WMO1o/5dT9m1P2YUfdjZtWP+XU/5ln9mG33Y37dj1lXP2bb/Zht92NG1o+5dz/mYP2Yg/VjDtaPWXo/Zun9mKX3Y37Wj/lZP2bp/Zit9WO21o/ZWj/m7EkdgMqgk9BBqBraD70GhaDXoavQm1AYug69Bd2EbkNvQNegG9AtKA/aBzmhXCgAHYMs0CHIAx2BjkOnIANqg85AZ6Fz0AXoMuSHrFA2VADZoEKoCCqGSqBSKEfKq881Zb5KLfqnstRK/SqrbDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDaDnDyZZznvXDWfCQGkj/S7KAO6zJVdDJB9szZSVsT+6dUW1N3e72Lpdb0/8T6WAxHYqmU8h0xJiOSVUY+nnxf5HO1Ublp+l/ezobTSduozf1T0dvqWxUz1RrZl8Tv0k9Sz0y8e6v6+vGvSwuFYiOykHTSVwqEB2VyI1KSFMRXSoXTSV0E8yPy4zRAV06Nx2d1I0O6NJpaTqgS/2hRwd1//q2vHsvjnRamk7u0hdi0xFeKhr16jXWB5n4J+b6uwrLz93v7HyQev8EqXetVeYKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEeQKEcz6I0gZIkgZIkgEIsgcIsgcIsgcIsgOIkggIkgSIsgjIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsgVIsm2dH6icKoRa6+qsakK2osK2osK2oua2Yua2Yua2Ysq2Ysq2Ysq2Ysq2Ysq2Ysq2Ysq2Ysq2Yva14va14tq14tq14tq14tq14v61ov61ov61ov61ov61ouK1ouK1ouK1ouK1ouK1osa1osa1osa1osa1osa1osa1osa1osa1osa1ouq1Yuq1YvzuBfnfy/O+F6c4704x3txjvfizO1FFelFPe3FWd2L2tCLc7wX53gvzvFenOO9OMd7UWF6ccb34ozvxRnfi1rUmzznFlhTN8Sq971ObC6cn6E+sdAqu5jDOAcP4xw8jHPwMM7BwzgHk6qATkOPQY9DT0At0AvQYagSehF6EqqFzkNPQS9DddBF6BmoHroENUCd0AD0CuSF8qFG6Ap0FOqGXoWC0LPQAagMOglVQ/uhXCgPckIB6BhkgfZBB6FDkAc6Ah2HTkEG1Aadgc5C56AL0GXIL+XVF1nlgpp/Us/IkMiUyJJ4SGKMRLZEjsRYiVyJPIl8iXESBRLjJQoliiRsEsUSEyQmSpRIlEpMkpgs4NXr5O9Sz0JknIWIMwvRdlIPQWOgbCgHGgvlQnlQPjQOKoDGQ4VQEWSDiqEJ0ESoBCqFJkGToSnQw9BUaBo0HSqHKqAZ0EzIDs2CZkNzoEpoLlQFzYMcUDVUA9VC86EF0EJoEVQHLYbqoQaoEVoCOSEXtBRaBi2HmqAV0EpoFbQaaoZaoFaoDWqH1kAdkAathXRoHbQeckMboE5oI7QJ2gxtgbqgrVA3tA3aDu2AdkK7oN3QHqgH2gv1Snn1xYkSe9HsKderCV2qgWtGA9eM1qsZjWYzGpxmNHfNaGma0dI0o6VpRrPVjGarGU1MM5qYZjQxzWhimtHENKNtaUbb0owGpxlNTDOamGY0Mc1oP5rR0jSjpWlGa9KMBqcZjUozGpVmNCrNaFSa0ag0o01qRtvSjLalGW1LMxqq5mQTU2+VM4uHM+UfPKlHoEehE5AP6ocqoNPQY9Dj0BNQC/QCdBiqhFqhF6GXoCehWqgPOg89Bb0M1UFPQxehZ6B66BLUAHVCA9ArkBfKhxqhLugKdBTqhl6FgtCz0AGoDDoJHYSqof3Qa1AIeh16A7oKvQldg8LQdegt6AZ0E7oF3YbyoH2QE8qFAlAhVAQVQyVQDmSBjkMFkAG1QWegs9AF6DLkh6xQNnQI8kBHoGPQKagUOgfZpLx6g1XOWDowY+nAjKUDM5YOzFg6MGPpwIylAzOWDsxYOjBj6cCMpQMzlg7MWDowY+nAjKUDM5YOzFg6MGPpwIylAzOWDsxYOjBj6cCMpQMzlg7MWJIqg6ZAD0NToWnQdKgcqoBmQDMhOzQLmg3NgSqhuVAVNA9yQNVQDVQLzYcWQAuhRVAdtBiqhxqgRmgJ5IRc0FJoGbQcaoJWQCuhVdBqqBlqgVqhNqgdWgN1QBq0FtKhddB6yA1tgDqhjdAmaDO0BeqCtkLd0DZoO7QD2gntgnZDe6AeaC/UK+XVGxMFV73JYSQj8Zr8t3ehSL//4Qe0HOaA+dyHjA/v7Q+1fOPB8piPw/YUH/VVMUusyaWPyROsBf1+C2ZMSa2FpkFN0A6oGtoFrYYmS3l1p1UuYw9ixA9ixE/KCk2DpkPlUAU0A8qGZkJ2aBaUC+VBs6E5UCU0F6qCCqEiqBiaB5VAE6EJkAPKgSZD1VANVAvNhxZAC6FFUBZUBy2G6qEGqBHKh5ZATsgFZUBLoWXQcqgJWgGNgVZCq6DVUDPUAhVArdB4qA0qhSZB7dAaqAPSoLWQDq2DMqH1kBvaAI2FOqGN0CZoM7QFGgd1QVshG9QNbYO2QzugndAuaDe0R8qru6wn7v3Uf1GPPa0vtcpdh0KIK0NYL5DUo9BBqAJ6DHocOgQ9AeVCedBhqBLaDz0JVUO1UB/0FFQHeaCnoWegeqgB8kL5UCN0BHJCR6FjkAV6FnoOeh46Dp2AfNBJqB86BZ2GWqAXoFboReglyIDKoDboDHQWOgedh16GLkAXoUvQZcgPdUID0CtQAOqCrkDd0KtQEHoNCkGvQ29AV6E3oTB0DboOvQXdgG5Ct6DbkBXKhgogG1QIFUHFUAlUCuVIefVlicL5abNRvpOV+BkW/XV1EDMPvpiZ+DdY9HfUPS0N6g6WPYZqCSz6H2ckvrFF19VzPm9+5oChGiyL/sOMxD/Oov831ZPfMT9z2VAtjUX//czEKGPRrpgfP2d+fMP8GDE/XkoUSIt+KisxtFn0385KFFCLds38+Mvmx9vmx6+bHz9j/jua1b/j88aVxPvyVqmfNmgeDN+9K0j7TfPjr5sfv2F+/Ir5iX9UP/U3zIPH1MEk82C3+prx5sFfqIMvmM8Nmx+/qCa/6oEvmQ/8KFHSLPrvqgeGzYOt6ot/S01j1cGQedCcmFcst8q2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PYS2PZRs25usD+7l+1DCSnVf3ctq2Hrwnnofs9RyhTU5q7XoS9UzUuvkvfpKtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB0BtB2BZNuxSpVKvUVtV/EIRqZRmxWoQcbINN7X9het6vt5Mo17o2y6oKdGOK++2pq6gLs6Vb4TF2dVQV+ZeEZz4hnpNyh+zvxeC+6+Q7O2y7jXReht6uc9m2mINzFOva1zerRJj0ipUSw1MnnN//3UfVbH7k6tdVfiE63W1LvAdWQayT7rl9T/RJ9qotQbVLWrH/zn6miNOupTz3pJ9Sfq4Gk1zVef61CfG1YPPWoe/I46UKP5H2Ya96K6PkR1fQhl+xDV9SGq60M414eItg/hXB8C2z4Etn2IaPsQ4/UhxutDRNuHiLYPoV4fIto+hLJ9iOP6EMr2IZzrQ0Tbh3CuD6FsH0LZPgR3fYho+xDV9SGq60NU14cwtw9hbh/C3D4Ed32Ib/sQ4/UhxutDjNeHMDepA1AZdBKqhvZDedA+yAnlQgHoGGSBDkKHIA90BDoOnYIMqA06A52FzkEXoMuQX8prVhJ1xqd3usMay36ssezHasx+rGDtT161breKSzFj1Q942qwT8h2MJia+7DnoeegR6FHoBOSD+qEK6FPQaegx6HHoCagFegE6DFVCrdCL0EvQk1At1Aedh56CXobqoKehi9AzUD10CWqAOqEB6BXIC+VDjVAXdAU6CnVDr0JB6FnoAFQGnYQOQtXQa1AIeh16A7oKvQldg8LQdegt6AZ0E7oF3YYCUB60D3JCudAYaBw0HpoEZUJZUAY0FrJAbdAxyAplQ4egQqgIKoZKoBzIAx2BjkOnoALIgEqhM9BZ6Bx0AboM+SGblNds4VTZPqYStwwjGWhtzjSS751bnZn4/Vv0r6kLQWNUs3dUHTWqo8ZEI6lZ77t7xj40ffvQ9O1D07cPTV9S/a9aLVaL+g8Pn4Yegx6HnoBaoBegw1Al9CRUC52HnoJehuqgi9AzUD10CWqABqBXIC+UDzVCV6CjUDf0KhSEnoUOQGXQSaga2g/lQnmQEwpAxyC+eo5D+6CD0CnoEGRAbdAZ6Cx0DvJAF6DLkB86IuXV11rljfn/XVTSJDIlsiQekhgjkS2RIzFWIlciTyJfYpxEgcR4iUKJIgmbRLHEBImJEiUSpRKTJCYLeHXdev9NMlU6YFOPvP9NMt8rG1hnfXA15BOzdFtdgfm7Bzsb/oxXQ9b/fE+Z9zhT3uO8+AidDj/TS/09XuHq1fXtX/j1PmyS+9O8rj/Yl/MH9ip2J17FAdM31TNS/c7v45pMUmVQLrQPOiDl1Te8xxg25YMbwzofjGGfnDHskzh0qXE79wM9+zda5Tr1i5iCXMTsOKlHoYNQBfQY9Dh0CHoCyoXyoMNQJbQfehKqhmqhPugpqA7yQE9Dz0D1UAPkhfKhRugI5ISOQscgC/Qs9Bz0PHQcOgH5oJNQP3QKOg21QC9ArdCL0EuQAZVBbdAZ6Cx0DjoPvQxdgC5Cl6DLkB/qhAagV6AA1AVdgbqhV6Eg9BoUgl6H3oCuQm9CYegadB16C7oB3YRuQbchK5QNFUA2qBAqgoqhEqgUypHy6pus8qrSn6NbSioAXYFyoTJoH3RAyqtvtuL6+A3zZF9uiOvkt8yD7szEn9Gib89M/CUs+kF1TXylCke9mYlibNFfyUrUb4t+NNMQl9fvXVS/bR60ZCZeAhZ9MDPx97bon8f19muqI3iX6+1vmQd/gAvv+82DP8pM/MnNdicz8Tq06H/Kq/qaOvpOZuIla9H/JjPx+rTof5uZePmZjYK8zu/VtyR+H6mlZmsTQfJUaBrUBJVDK6AKaAZkh1ZBq6EWaDY0B6qEqqBWaB7UDlVDNVAHVAsthDRoMrQWWgftguqhTmgjtAnaDG2BGqEuaBu0HdoBuaCd0HpoKbQbWibl1btQEd5BRXgHFeEdVIR3UBHeQUV4BxXhHVSEd5IVYav15/bWNP77RUQf8FvT3Jv7/FtvRJNuv9PznFQfnprv/ORvRPORfAOaUe87k579ePVuq3yvIguWsFmSL4ht7/KCSM+LR99cdcc8+II6SN1cZb5wLXqnOlDl+E/UwY/VwKAOMDF+KsN4z/lw+g6sleZBIEO+JpaYB9fVIyXmwTb1VembstTNV59Sn/ol8+DtTPlySd2vlZ47p27YSr8u0y/q0VPnHPO5XxIvqbsvHH2G+r8czDDuN1VOzcT1mepJX1BPKjC/7FFDteTmny5DvKzSN36l3uDoV8wH6tQDs8yD/RnG/Sba6XvTdPOLCs0fZFer7coMMQVPz7xnmp95WL700pPzKeZn7IZah2zRqo37TM1/1Xxgp3glrjE/aoaYqqduONNnqZ/fady78+z9TNlTt6DdKzfpO/bSiwZnq2+88V4t0eeoB7YZiRv2zMbKUIuOLVqPLBjpACFVOfRK9UWPG2pRqdniqJ/0a6oyYDa/3HzKE4ZqEi36l9VTRk3i9bXqz/nvrbJsLDK/6qioFgvMj88ZIvhJz+9HzevTgUI67kkHQHdriz5X/bv7ZW1J3wU4OgRYbD73jCw2W80H/EbiVkI9X70cq9S3u2Ek70e8Y9yrx6mao89Tz4iJoqM71CNfMcSdkumik7qp8N4bg6XvLkylBfeGlNHxWfoeTLf51V8z1ETMon3TEIHYZ8wHnjJEvR9jPvAtI13n9Rr1g79t3KvverV65M+Me/X8s+bH76TezuyvDZFjZZoHf6e+a/qGSrVbz/cMdTuBRfu+kb6vUq9VX/tPhkikouYDU417N1jq89VT/tkQBTgdSKVzqGJ14qlfypfNgxx18O774KglCxnqoM48yJZBlL5AvQqL1EOpYS99v2kqidIXqudMVM9JZ1Kpkc9hPjBVfebugKYvUs+dox5J3Wtq1h/zqEo9lB7CvmoePIlkqdk8qFGnxWL1bKd6duqOVHP0MI+Wq4dGx06fMw9Wqk+lx7P06PUN9Y0STfr2xIiUWsGRXK/xxcRwtiM9VnWl7pf9tPmMVeoZU9GYqO7gr8xPjVWfct997SXWG6d+7/vUyzTj7mplfY/6n8lTR1fxv54+odJ/JvVy+6p69jj17BF1VKCO/jI1mPy9emi8euiH6GVSvw29UH3ux6kUOSPjXvk1/7Tq76seUf/7EzLk+WlTn5uBHuhftwn6avUcmzoqVkd2tA7pddrpNdh3y5Ger55calW/4p2JX7G6N/lT6pc/UX3mbxJx+S7zM2pSpkXVMsndieelsrgm5DVNyM2akB01IdVqQk7XhMyiCclVExKMJiRlSR2AyqCTUDW0H8qDnFAuFICOQRboOLQPOgidgg5BBtQGnYHOQucgD3QBugz5oSNSXvN8kbOXtzF7eRuzl7cxe3kbs5e3MXt5G7OXtzF7eTvZrPZY5e7Hv4tXVlKPQI9CJyAf1A9VQKehx6DHoSegFugF6DBUCbVCL0IvQU9CtVAfdB56CnoZqoOehi5Cz0D10CWoAeqEBqBXIC+UDzVCXdAV6CjUDb0KBaFnoQNQGXQSOghVQ/uh16AQ9Dr0BnQVehO6BoWh69Bb0A3oJnQLug3lQfsgJ5QLBaBjkAU6BHmgI9Bx6BRkQG3QGegsdA66AF2G/JAVyoYKIBtUCBVBxVAJVArlSHn1vdb3e637p89/9t3vOuuo/Cc9+//pgqD0Ndn0FF/NpbT3jIbSs7mfR0aUnvn/DGHRe1zMfR+pUXrO/u7xUXry8h45UnqSnm7J07P1+yRLvRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRh7fRh7fRhtfRhtfRhtfRhffRhRfRjrfRjPfRilfRiXfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfRiJfcmReN/7HokfrDr7Ra86Uwum8jKNB8vPPpDlZx/YqrP973LKjL54+fM/ZX5++8V/EKeMegF7rR/KufMznjIqWCy976nzYOP4n/rUSXdKT+Km4SeTKxAOJE6rVJvwfWRx30/mbY9Y77u9pq6rWPhH6oePvhacvgScvsjTYx6M4PLu6Gu46Uu3qSu2qQu1dy8E6evUVZY2495V2a+bXzE7Fdbnygut6as7o7fYHH2FNX09NX0pSO3tudsQVxlTe2ymromm99r8rHmwXKXt69X/9DX1XVIXQUddJbInfmW49pm+rDb66lDqaqjuVl/2A/XQBFW41MHoC5np3UdTFzD1DerL3lAPpS8Q7TUPKtRB6prgffYXTV/p+WXzwKYO0huNjt5GNHXFJvXGH9qXE6+ZRxOvGbVobL76ugH1Z1IH/eZvZJ+h5hUWvVw98IJ5MCXj7slTog6eMQ+y1cFT5kGWOjhhHvyzuqDSqf78f2GoqYB5HqWubv2DOgiaB99RB6k5XzvmfO2YkbVjptqOuU075oPtmL+0Y/7SjvlLO2Zk7ZhntWMO1o75SzvmL+2Yv7RjxtKOGUs7uv12dPTt6Pbb0d+3o79vR3/fjq69HTOIdsyl2tHRt2Ne0I7+vh39fTv6+3b09+3o79sxu2hHt9+Obr8d3X475iHtyX774IN++yPbbz9os39BvYLqC0vUk99Xv/2YOmWSC4C/JVfievXHEydTqnpuwsYkm7BhxCZsx7EJ25RswjYlm7C1xCZs1ZHUE1ALlAcdgg5D+yEDKoPaoDNQNVQLnYXOQR7oAnQRugRdhhogP+SFAtAV6AjkhI5Cx6BuyCLl1Q9ZU3u0Xcswkssr/jCxouCJxKtphXo1zc+8W86+kZH4NZsV0yq+0z5sOZnUMahbyqsftt7/RsH3cX+gOscHrcb7ulHwSatcNf6/E6PMVGga1ASVQyugGVAFZIdWQauhFmg2NAeqglqheVA71AFVQzVQLbQQ0qDJ0FpoF1QPdUIboU3QZmgL1AVth3ZALmg9tBTaDS2T8up91ndfu/Toe69durdEKbWKSSxVSr1+R48QqZVK6VfyB7lkSSxVSp0577Vk6V3PyPe1UCm5QOmA+tzdMdNrjubyAtQX0dYn9Qj0KHQC8kH9UAV0GnoMehx6AmqBXoAOQ5VQK/Qi9BL0JFQL9UHnoaegl6E66GnoIvQMVA9dghqgTmgAegXyQvlQI9QFXYGOQt3Qq1AQehY6AJVBJ6GDUDW0H3oNCkGvQ29AV6E3oWtQGLoOvQXdgG5Ct6DbUB60D3JCuVAAOgZZoEOQBzoCHYdOQQbUBp2BzkLnoAvQZcgPWaFsqACyQYVQEVQMlUClUI6UV/dY5RthT8XG11OxUfNUbNCd1EPQGCgbyoHGQrlQHpQPjYMKoPFQIVQE2aBiaAI0ESqBSqFJ0GRoCvQwNBWaBk2HyqEKaAY0E7JDs6DZ0ByoEpoLVUHzIAdUDdVAtdB8aAG0EFoE1UGLoXqoAWqElkBOyAUthZZBy6EmaAW0EloFrYaaoRaoFWqD2qE1UAekQWshHVoHrYfc0AaoE9oIbYI2Q1ugLmgr1A1tg7ZDO6Cd0C5oN1QG7YF6oL1Qr5RXf9r6YOOnD2Pjp58pMFSR3+NW48HGT6lQ8JnEq/iI+udnGcmblNaqZ/yBedCYiEm81uQ9AeZMTT0j1SQfQsJ2KJkWHfn5nhOf0FQ+HcareH7iR/bc+j8vjP/AzrKjVnlfzXfRxHwX99V8F/fVfBdt9XcxfH0X99V8F/fVfDc5RB2z/sLeR8ODpMaDpMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDbMaDNMaD/MWD/MWDxMWDxMWDxMWDxMWDjMWDjMWDjMWDjMWDjMWDjMWDjMWDjMWDjMWDjMWDjMWDVMWDVMWDVMWDVMWDVMWDVMWDVMWDVMWDVMWDHMWDHMWDDMKDDMKDDMKDDMKDDMKDDMKDDMKDTMeDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKDRMKTTAGefTAAfxwvi6sLuX+oHnkwJP+C19J5zZNAXnGYlinHsaQegR6FTkA+qB+qgE5Dj0GPQ09ALdAL0GGoEmqFXoRegp6EaqE+6Dz0FPQyVAc9DV2EnoHqoUtQA9QJDUCvQF4oH2qEuqAr0FGoG3oVCkLPQgegMugkdBCqhvZDr0Eh6HXoDegq9CZ0DQpD16G3oBvQzf+fvTuPb+q8874vWS42tjFewA52IJiwOBDjGLBxDASz2CaIYxJbYFsgRBJwxL75sEQSO8fsYMyOgAOiVafTxe2MOtPpqK3aW3WXNPMkTZrpPemknXvap527nU5nXk9n2tmec+kgcX1qoCSBJHTIPzlvWV6wdb7X71oFBaFrUCa0DKqBMqBuKAfKhfKhAigdskA+KBvSoAaoE9oPHYaOQcchK5QGrYY2QpuhrdAuqBA6AOXJUhXvLWqNe7V+X2mOL8cV6X2XVvIraeIrzhJf8e7WH4pDfOHPiC98VyoRUR+ki0feSUki2vOz4kf4IJbsvWRcXBDf/O6s8/+fVJIk8+4nZk3ve1DT3481/bt/U47DNu1BTf+eanq/VXoHyN+IwbBNyvb79Da6Z43U+39DvYMWyWxB+1vvxT2WbJvuzj32P+HWErF0+qaN1N+bjdSO+N2VWCBxAQskLmCBhCkrNAx6BBoOlUAjoDToUWgkNArKgDKh0dAYqBR6DBoL5UC5UD40DiqABkODoMehdGgIVAaNh8qhJ6AKaAI0EUqFJkGVUBU0GaqGsqAnoRpoCpQCTYWmQU9B06FaqB80A5oJzYJmQ3VQNlQPDYQaoELoIWgO9DQ0F7JD8yAFaoRs0HzoGehZqD/UBDVDDmgBtBAaALVArVAe1AY5oUXQYsgFLYHc0FJZqrLTKg84XsLE2SVMnJnyQH5oO7QTKoF2QyuhVdAaqA7aA62FSqF6aC+0D1oHlUProYPQBugQNAnaBB2BOqAq6Cg0GWqCuqATkAplQdVQC3QS2gK1Qaeg09A2qB0qgnZAK6AyaDl0BjoLnYPOQxegAHQJughdhnToCnQVCkLXoExoGVQDZUDd0FbIAq2GNkKbIR+0C9KgBqgT2g8dgA5Dx6DjkBVKg7KhPCgHyoXyoQKoEEqXpSq7rImVSHtTpNfyUgyeLzUHJ3cjZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjaGkI0hZGMI2RhCNoaQjSFkYwjZGEI2hpCNIWRjCNkYQjZmhuwe6zvdfJsYRRGjOyvFR5LjCDHjYqr4KsmBleR4SmJIqNf4f6b4vnut8nsQLkOmLzMzfR+e0o1XUTcyvRuZ3o17rRu53Y2k7kZSd+M11Y3c7sbrtBuv727kdjdyuxv3djeyuRsp0I2k7kZSdyObu5HG3XjtdyObu5HG3UjjbuRvN1K1G6najVTtxt3Vjbu5G6najfu3G/dvN3LU1EuQF/JBfmg7tAPaCe2CdkN10B6oHtoL7YM0qAhqgDqh/dAB6CB0CDoMHYGOQseg41AT1AWdgLqhFugk1Aadgk5DZ6Cz0DnoPHQBCkAXoUvQZUiHrkBXoSB0DbJCaVA2lAflQLlQPlQAFULpslRFs8onHaTFs3UoNAyaDg2HaqERUAk0EpoJzYLqoNHQGGgsVA+Ng+ZAc6EyaDxUDk2A7NAQaB60BKqCmqBmyAEtgBZCLdAiaDE0BZoPTYXc0DRZqtJpxUkHyWklceTBL+74XINbn2dwp8cY3NnpBYlTC24cVnDjSALz3IGv3fRMghsnEeyP/3vFaSaN8mkmrRhEN7UVapOlKgfiXydRG/wA7eMP0Cr8ADXFD8x792D80795/UFf/C/zLejbUJksVTlklU8D/GfsIPhn8wc8bH3X63iUBeI3+WJic8H7cyKnslB805fEN73Xaw7MJUc73+U6HjFptscW/5MaP7m4eHfTp2K+8rhN+2AXJjw4r/M9rEc4ksySH8tZ4kSWOJElTmSJ07xVj8a/zjeMr/Ox1PiNbFF+Kb5Tu3HxslU845jxjPg7+nZaxaKH49fDx2L/hma+VWGruG0Lxcu63pzGtSjn4j9jlxU7AcUGwE+lauaWwD9KFc84YZXfHKoeVXI9eiv1qNjr0ZeoR++oHpViPfoL9agb61HR1qO3Uo/61lQ7VATtgMqg5VAmlAHVQN3QVsgC+aBl0ApoF7Qa0qAGqBPaDx2ANkKHoWPQcWizLFXpvkUb8v6/EUmy2bmTdyTpu/zmTt+aJAfrcX7/BuH39T1KbhmD9/GblfRto0TxcFp8nRtvX3LSKo/6fxwpZOpFyAP5oe3QTqgE2g2thFZBa6A6aA+0FiqF6qG90D5oHVQOrYcOQhugQ9AkaBN0BOqAqqCj0GSoCeqCTkAqlAVVQy3QSWgL1Aadgk5D26B2qAjaAa2AyqDl0BnoLHQOOg9dgALQJegidBnSoSvQVSgIXYMyoWVQDZQBdUNbIQu0GtoIbYZ80C5IgxqgTmg/dAA6DB2DjkNWKA3KhvKgHCgXyocKoEIoXZaqnLLefNQ/uVTyDs7evN40m+tVP5FoFr8uJ36i3Ug2yYk/ZBAvjqD5Q51GmruQ5i4kmgvZ7kKau5BoLqS5C6nlQmq5kFoupJYLSe9ChrmQ+y5kmAsZ5kKb4EIr4EIL4UIr4ELauZB2LuSiC22JC9nnQva5kH0uZJ8L2edC9rmQfS5knwvZ50LauZB2Ltz/LuSGC0nhQja4kA0uZIMLd7wLLzAXctiFNHAhU1zIBheywYVscCEbXMgGF5LJhaRwISlcSAoXMsxl3hZn4rdFYlHZLGyDm2WO+py13p9r3e/7Fe5iyOcL4iMPjkm/z4ZozsVvmbWGC6xSEtrMe+681TwGO/6g/b+lrIxDVS5Y5RNeXsZ65pcx6voy1py/jFNcXsYpLi+bgz6BD/5mvk9PHBMZ9CvrO7wbPyw3IQYU3tM9+CE9FOli/HUtxirPyxtKVuNuWY0176aWy1KVS1bp5FP7l8UzUmQ8JMMm4zkZqTKelfG8jH4y0mT0lzFKxgsyMmVkyRggI1vGQBk5MnJl5MnIl1EgY7CMQTIKZaTLGCJBVS6LX7nSTxT637ddv8EXxP+oujW+885i3y2Gn6/En9cintcgXim/NS6s4hMSG4Wi2CgUxUahKDYKRbFRKIqNQlFsFIpio1AUG4Wi2CgUxUahKDYKRbFRKIrQjmKjUBQbhaLYKBTFRqEoNgpFsVEoio1CUWwUimKjUBQbhaLYKBTFRqEoNgpFsVEoio1CUWwUimJeIoqNQlFsFIpio1AUG4Wi2CgUxUahKDYKRbFRKIqNQlFsFIqiYY1io1AUG4Wi2CgUxUahKDYKRbFRKIqNQlFsFIpio1AUG4Wi2CgUxUahKDYKRbFRKIqNQlFsFIpio1AUG4Wi2CgUxUahKEIzio1CUWwUimKjUBQbhaLYKBTFRqEoNgpFsVEoio1CUWwUimKjUBQbhaLYKBTFRqEoNgpFsVEoio1CUWwUimKjUBQbhaLYKBTFRqEoNgpFMRcXxUahKDYKRbFRKIqNQlFsFIpio1AUG4WiZsN21Xqzybv4ZF+XTZ7FU5Vg/KmJ1JmI1SMTsXpkItbKTMQKkYlY4TMRK0QmYoXIRKyqmSj3Qe3fjv/w16zyeeTZuMey8ZrIRhaY+gjUD0qD0qH+UAaUCWVBA6BsaCCUA+VCeVA+NAgaDBVAhdBD0BCoGHoYGgoNgx6BhkMl0AjoUWgkNAoaDY2BSqHHoLHQOOhxqAwaD5VDT0AV0ARoIjQJqoSqoMlQNfQkVANNgaZC06CnoOlQLTQDmgnNgmZDdVA91ADNgZ6G5kJ2aB6kQI3QfOgZ6FmoCWqGHNACaCHUArVCbZATWgQthlzQEsgNLYWeg56HXpClKh+NR+w+o31Yp4kxUYv9wo0bw/4N8RlFMtokqMrHrPLKsJ9j5PbnGEn9OcYyf47Ry5+b4yMha+Jtwo6mSr+0fuZHP279wN/p+Z+Mz67TzDckfkyTBjJuM06ZHOMQLe5s8cgHNk5pLkRz3IMRywdrye6zgco/ssqzYpsxK7YZ82CmPJAf2g7thEqg3dBKaBW0BqqD9kBroVKoHtoL7YPWQeXQeuggtAE6BE2CNkFHoA6oCjoKTYaaoC7oBKRCWVA11AKdhLZAbdAp6DS0DWqHiqAd0AqoDFoOnYHOQuegC1AAughdhnToKnQNOg9dgq5AQSgTWgbVQBlQN7QVskCroY3QZsgH7YI0qAHqhPZDB6DD0DHoOGSF0qBsKA/KgXKhfKgAKoTSZanKJ1Dw/Awv4Z/hn/kz/DN/hj/Hz8wv9sdWeULor6Q/bRyq8sn4ExIv/MH4boNxEw7G7TPY/PqfQsp7kfJepLwXKe9FynuR8l6kvBcp70XKe5HyXqS8FynvRcp7kfJepLwXKe9FynuR8l6kvBcp70XKe5HyXqS8FynvRcp7kfJepLwXKe9FynuR8l6kvBcp70XKe5HyXqS8FynvRcp7kfJepLwXKe9FynvxAvMi5b1IeS9S3ouU9+JF68XL1IuU9yLlvUh5L1Lei5T3IuW9SHkvUt6LlPci5b1IeS9S3ouU9yLlvUh5L1Lei5T3IuW9SHkvUt6LlPci5b1IeS9ixYuU9yLlvUh5L1Lei5T3IuW9SHkvUt6LlPci/ryIPy9S3ouU9yLlvUh5L1Lei5T3IuW9SHkvUt6LlPci5b1Iea8ZnJ9GcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKcfwelHcPoRnH4Epx/B6Udw+hGcfgSnH8HpR3D6EZx+BKffDM7PWOUTPL+BKYVvYErBlBUaBj0CDYdKoBFQGvQoNBIaBWVAmdBoaAxUCj0GjYVyoFwoHxoHFUCDoUHQ41A6NAQqg8ZD5dATUAU0AZoIpUKToEqoCpoMVUNZ0JNQDTQFSoGmQtOgp6DpUC3UD5oBzYRmQbOhOigbqocGQg1QIfQQNAd6GpoL2aF5kAI1QjZoPvQM9CzUH2qCmiEHtABaCA2AWqBWKA9qg5zQImgx5IKWQG5oqSxV6bFKnX+lAz9Eh/mUz4qnKLVi1D7NppnzBF9Lif/xLYpP3gS8DJ9uaitUJktVPhf/7v8hhrZT402YRVkvLv7TuNiXEm8MLcr+1Hg7aFGeSY03VxZleWq8hbMom8SFmNL4tvgx/kvMUohH/tu48Md30f1J/Bu8aLhF/OgrjYs3rPE72KL0WuM3vUX5krg4JeYBxEWiwnagynSgpnagrnSgpnagdnSgdnSgWnSgWnSgwnagWnSgWnSg+nag3nagFneg3nagknSg5nSgTnegrnSgrnSgrnSgknSgknSgknSgknSgknSgdnSgdnSg7nKgtnKg7nKg0nKg0nKg0nKgfnKglnOgqnWgtnKgQnOg0nKg0nKg0nKg0nKg0nKgznOg7nKg7nKg7nKgInSYlc+fWt/n6cnkvZucpxT7BibcfP/Ebd7QJt+4mPZ+zFQqrSLI6sRzbzlnmQybdzR5KUKrVTxwm1nMZHrd8+nMZJbeZl4zGaF9JzgTEfqhmukUv/vt4mdJTnkm24cP09xnsh26o0nQsDWxANn+iCavP/68VR7+2R2/3b3Qi5AH8kPboZ1QCbQbWgmtgtZAddAeaC1UCtVDe6F90DqoHFoPHYQ2QIegSdAm6AjUAVVBR6HJUBPUBZ2AVCgLqoZaoJPQFqgNOgWdhrZB7VARtANaAZVBy6Ez0FnoHHQBCkAXocuQDl2FrkHnoUvQFSgIZULLoBooA+qGtkIWaDW0EdoM+aBdkAY1QJ3QfugAdBg6Bh2HrFAalA3lQTlQLpQPFUCFULosVfmzeHAmumDH0AU7hk7sMXRUj6EbeQwdXFMWKBXqB6VA/aEyWarR67gPDpzpuwztwckzyQpCFGZt4pH7+AiaGyfPfOEu9SGUt6zae1jjqAwWj3y43gwz8bpS2sQ3eMGWeHOvU7abvcQ+BO899iF7N8z1xsVDKdr799ZjjxsPXLHd7m5+d92A3xgXH78LayHFmXWfYH/gL1D2P2KTy35TL0IeyA9th3ZCJdBuaCW0CloD1UF7oLVQKVQP7YX2Qeugcmg9dBDaAB2CJkGboCNQB1QFHYUmQ01QF3QCUqEsqBpqgU5CW6A26BR0GtoGtUNF0A5oBVQGLYfOQGehc9B56AIUgC5BF6HLkA5dga5CQegalAktg2qgDKgbyoFyoXyoAEqHLJAPyoY0qAHqhPZDh6Fj0HHICqVBq6GN0GZoK7QLKoQOQHmyVOWLVnmZ4sPouT6M3vDD6Mc+bPYa/vKOy/AHB83clXJG1HhfF498kPs3Hhw08x72b0Ss8kkx38e8ualu6CSUARVBy6B2WarypQcd5vu8w3zP+8kiOVbiBX0PO8xfRsU+DZXiNOxYn4b6YTlGmEwtl6UqX4l/6cRAUyfWFnRiaKkTA1udGITqxDBXJ4a5OjEk1Wl+26j1nb5z0u8enRiPxCH4ff/uiYmq8tX4txF/mSfNrqX5Q3gw1eHBVIcHkxseTG54MLnhweSGB5MbHkxueDC54cHkhgeTGx5MbngwueHB5IYH0xkeTGB4MIHhwZSFB1MWHkxZeDBl4cEkhQeTFB5MUngwSeHBJIUH0xIeTEt4MC3hwbSEB9MSHkxEeDAR4UHp5cFEhAcTER5MRHgwEeFBOedBAefB1IMHUw8eDMZ7MIjvwbC9BwP1HgzUezBQ78HgvwfTIB4M4nswiO/BIL4Hg/geDOJ7MIjvwSC+B4P4HgziezCI78EgvgeD+B4M4nvMEvhrVnlb0a/QLv/KTIb/ZU0c/++3Sb+S57Hy53ms/HkeCfO8+XViVnmJ5qX4Ux6GhkJWaBj0CDQcKoFGQGnQo9BIaBSUAWVCo6ExUCn0GDQWyoFyoXxoHFQADYYGQY9D6dAQqAwaD5VDT0AV0ARoIpQKTYIqoSpoMlQNZUFPQjXQFCgFmgpNg56CpkO1UD9oBjQTmgXNhuqgbKgeGgg1QIXQQ9Ac6GloLmSH5kEK1AjZoPnQM9CzUH+oCWqGHNACaCE0AGqBWqE8qA1yQougxZALWgK5oaWyVOXr1gcDE/LAhBg3ePp9nXB5MDBxnw1M9N7xLfNghOB/8AjBpvdrhOAb8ddjoqLtRQ3bixq2FzVsL2rYXtSwvahae1G19qJq7UVl2ovKtBeVaS8q015Upr2oTHtRmfaiMu1FZdqLyrQXlWkvKtNe1KK9qEV7UW/2oorsRRXZiyqyF1VkL+rGXtSGvagNe1Hj9aKO60Xl1ovKrRfVWS+qs17UY72owHpRc/Wi5upFXdWLGqgXNVAvqp5e1Cu9qFd6UaH0ogoxVQw9DFmhNCgDyoQeh8qg8dATUAU0AaqCqqEsaAqUAk2FpkHToVpoBjQbqoMGQoXQHMgOzYMaIRu0BHoGehbqDzmghdAAqAVqhfKgRdBSyAXNl6Uq3/wwVrui5Nwu0v4PeT7uQbV7n1a737LK8w+fxOj5JzF6bsoDXR9LP2WxWC3iv+sPb8eTdkIl0G5oJbQKWgPVQXugtVApVA/thfZB66ByaD10ENoAHYImQZugI1AHVAUdhSZDTVAXdAJSoSyoGmqBTkJboDboFHQa2ga1Q0XQDmgFVAYth85AZ6Fz0HnoAhSALkEXocuQDl2BrkJB6BqUCS2DaqAMqBvaClmg1dBGaDPkg3ZBGtQAdUL7oQPQYegYdByyQmlQNpQH5UC5UD5UABVC6bJU5dtI0F8hQX+FBP0VEvRXcoJe13ZoJ1QC7YZWQqugNVAdtAdaC5VC9dBeaB+0DiqH1kMHoQ3QIWgStAk6AnVAVdBRaDLUBHVBJyAVyoKqoRboJLQFaoNOQaehbVA7VATtgFZAZdBy6Ax0FjoHnYcuQAHoEnQRugzp0BXoKhSErkGZ0DKoBsqAuqGtkAVaDW2ENkM+aBekQQ1QJ7QfOgAdho5BxyErlAZlQ3lQDpQL5UMFUCGULktVXo4HZ+Il3IU/VReCswvB2YUXdBfCsQtx2IU47MIfrgvh2IUXQxdeRF0Ixy6EYxduoC4EYBdutS7EYRfisAsB2IXI68ILrAsB2IXI60LkdSHkuhBdXYiuLkRXF17CXbhluhBdXbhJunCTdCGsTL0EeSEf5Ie2QzugndAuaDdUB+2B6qG90D5Ig4qgBqgT2g8dgA5Ch6DD0BHoKHQMOg41QV3QCagbaoFOQm3QKeg0dAY6C52DzkMXoAB0EboEXYZ06Ap0FQpC1yArlAZlQ3lQDpQL5UMFUCGULktVvhMPzr5765IDXx8zLkKp8W9vUc6Ji5Bx8dnU+I9nUf53SjwZLEpTimYejPCGuBD7ktaLC4x8bRCP3GbAa7Bx8WtxMcO46BYXyeGtJ42Lyynxf5tFcYrPSjUuvm2LZ6tF+aj40MfF+BBmogYYIXJSk8bE/sh44KgmjdAlx8b6DomlG8/9U+3GSFhiz90I8a/8lPicvkNgiRE25VHxpM+mxP+kFrtHM99s6M/FA4nRsU8ZD3xFfPYg44Fpxv8/bTwwSTwwyrhYLp7adwAt17j4F/EcxfikHOMbjRQHNhRp0tBackTtUeMjD2vSyFpy0K3Y+MhITcywWOxl2k2G3D5nPODSbgy9PW38365JQ3B/IsYvjQtllPj+TcYjf2r8/1+1OxuK+7xxMVv8pZIDb39uXPyJeCQxAKmMFl+4WUuOxSljxANO44EeMfgpvswTxgPPadKYXHJgMDE4p5SKT1qliYFni7JIfKcviAE3jNI9ZTxlTfxWtCh/Jp7Sd3AuOSg30XjuFu3G4FyF8f+XNGk8Nzla12eULjk8mBy8TY7rXh/AUx4TP+1OTRrJ+0vjYuXNh/Qqjed2atKIXqvxwHHj/39hPJAlXoRjxZe7YjzySeP/Ie3GeHRigE8ZJ57x59qNkT7lcfHIF+OxYVEU8WWTQ35fMS5axV7TVPGcwcYjUXFfyYOASpl43Y8QD91md26KcfGa+IrPGF/ny1r8BC/7NzVpxPsTxgMbNGkMu5/xwF9pyXFqZbz4Ef5ak8anE+PSf2z8/0fGM2ziGT/RpGFpm3Hxf8UXe8i4cIvPEW9h8g+amPW02H9p/P+zxv8vGp9bLj73t5o0wBw2HhiqXT+wS/yenhBP+U9NGk1Oji8nh5XFYUIx8bv4M+MiXVzcepNqm3GRIi4mGRdp8riyUiF+p7niocR4cn/jgf8lvkNiYFmZIJ4zWDwnOcScGFAWe0+Hio9cHz9WJornjhGPfNG4+Gfx6ZPEQ2PFQ8mB4ohxsQ4DxbONi/HipqoUz64Rzx5oXPwf8euoEg89JR7qO5z8GeNihvhQchQ5OXj8NfGFxEViZuZbmLv7ljkX84pV3t/xC0yemuqGTkIZUBG0DGqXpSp/ZU28m+r3U6TnrsTXWYnJVFPLZanK/2OV15h+HfOYpoZCVmgY9Ag0HCqBRkBp0KPQSGgUlAFlQqOhMVAp9Bg0FsqBcqF8aBxUAA2GBkGPQ+nQEKgMGg+VQ09AFdAEaCKUCk2CKqEqaDJUDWVBT0KboRpoCpQCTYWmQU9Bv4WmQ7VQP2gGNBOaBc2G6qBsqB4aCDVAhdBD0BzoaWguZIfmQQrUCNmgJdAz0LNQf6gJaoYc0AJoITQAaoH+HWqF8qA2yAktghZDSyEXNB9yy1KVV+OhGi/fbZpZ0H88cbSDTzRpc0SL9Lfi6mlxtV48a58oBcTFJlFGi4/NFR/7injIY1x8XVyI2vGV+ITma9a7sv3o0/Kuo2QbeGP70XfRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRPgTRIgTRIgTRIgTRIgTRIgTRIgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgTRBgSRdUG0AUG0AUG0AUG0AUG0AUG0AUG0AUG0AUG0AUG0AUGkfhCpH0TqB5H6QaR+EKkfRM4H0f4FkfNBtA9BM/VfF1GptMQ7MCKrf2tcWMVFIj0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPCNIzgvSMID0jSM8I0jOC9IwgPSNIzwjSM4L0jCA9I0jPiJmeb1gfbEf5A9mOIgbit93LfSnvx3aU71nlk5IKMA9agJnBAszXFphzV28air9Srxhff5Pxp5VHCYviR1y8BHmhFyEP5Ie2QzuhEuij0G5oJbQKWgPVQXugtVApVA/thfZB66ByaD10ENoAHYImQZugI1AHVAUdhSZDTVAXdAJSoSyoGmqBTkJboDboFHQa2ga1Q0XQDmgFVAadgc5C56Dz0AUoAF2CLkKXIR26Al2FgtA1qBvKhJZBNVAG1A8aAA2EHoJsUCqUAvWHLFADtBWyQmnQaigHyoXyoQIoHdoIbYZ80C4oG9KgQqgT2g8dgA5Dx6DjUJ4sVfm+1ZxlMR9MscovBlPLoSKoAdoBWaA2qEyWqvxv0ZQknvFb8dgm5W/iP1jib1qPor4eRWg9Oh+mPgL1g9KgdKg/lAFlQlnQACgbGgjlQLlQHpQPDYIGQwVQIfQQNAQqgoqhh6Gh0DDoEWg4VAKNgB6FRkKjoNHQGKgUegwaC42DHofKoPFQOfQEVAFNgCZCk6BKqAqaDFVDT0I10BRoKjQNegqaDtVCM6CZ0CxoNlQH1UMN0BzoaWguZIfmQQrUCM2HnoGehZqgZsgBLYAWQi1QK9QGOaFF0GLIBS2B3NBS6DnoeegFWaryVjxwE52fvn3RPn2UZJ+070TM754KbnTClF+iF5PouCU7nsneTJ+unJjE+QcsR0v2O5O9GjHv9DmbdqOPdaOb8wOr2TGxKE5r/O6y2IeLx//WKndYfoZbz1Q3dBLKgIqgZVC7LNXoqsubTHqwgrYHa6V7sFa6B+tpe7CetgcraHuwjroHK2h7sKq6B6uqe7COugdrbXuw1rYH66h7sI66B+twe7AOtwfrcHuwxroHq6p7sKq6B6tre7DGugdrbXuw4roHa6x7sPK2Byuue7Diugercnuw/roH63B7sA63B+twe7BSuwcrtXuwUrsHa3R7sEa3Byu1e9Av78GK3R6s2O3Bum1T7VARtANaAZVBy6Ez0FnoHHQeugAFoEvQRegypENXoKtQELoGZULLoBooA+qGtkIWaDW0EdoM+aBdkAY1QJ3QfugAdBg6Bh2HrFAalA3lQTlQLpQPFUCFULosVflhPDiNX6xSmSK9Cl9BcL+C4H4F4fwKgvsVRPUriOpXzKj+Ufw7JgrhZ+I/1FBoGDQcKoFGQCOh0dAYqBQaC42DyqDx0BCoHJoAVUHV0BRoKjQNmg7VQjOhWVAdVA/NgeZCdmgeNB9qgpohB7QAWgi1QE5oEbQYWgK5oUbIJUtV/s4qVw1/E3+KF3oR8kB+aDu0EyqBdkMroVXQGqgO2gOthUqhemgvtA9aB5VD66GD0AboEDQJ2gQdgTqgKugoNBlqgrqgE5AKZUHVUAt0EtoCtUGnoNPQNqgdKoJ2QCugMmg5dAY6C52DzkMXoAB0CboIXYZ06Ap0FQpC16BMaBlUA2VA3dBWyAKthjZCmyEftAvSoAaoE9oPHYAOQ8eg45AVSoOyoTwoB8qF8qECqBBKl6Uq/8ea6P39PCX+b7IoM23xf45FmRpfZvj31sQerBbRP0zOqxodX/svtPj8qj2inVQyxLKXpVikn5zrE/OSkcT07M/FIv2B4tm/llfkKzniod8kTihKEev2c+N7C1I0c6Z3kLi4Pgup5MW3cognDRB7HWYbF/nioZHXNzEpjyVm/Mriyxh/bH1/TkwShyB1iH/z/XJQ6IMTkx6cmKTd9MSkn9yNW0bcD3v/wM7WfXDLPLhlbnbLJEvB5ZhMX25OJf6/6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6JWo6JWo6Ieo6Ieo6Ieo6Hmo6Guo6AWp6Omo6L+o6LGo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOo6KOoZh/lp1ZpqYP9++IZKTJsMlJlfERGPxlpMtJl9JeRISNTRpaMATKyZQyUkSMjV0aejHwZg2QMllEgo1DGQzKGyCiW8bCMoTKGyXhExnAZJTJGyHhUxkgZo2SMljFGRqmMx2SMlTFOxuMyymSMl1Eu4wkZFTImyJgoY5KMShlVMibLqJbxpIwaGVNkTJUxTcZTMqbLqJUxQ8ZMGbNkzJZRJ6NeRoOMOTKeljFXhl3GPBmKjEYZ82U8I+NZGU0ymmU4ZCyQsVBGi4xWGW0ynDIWyVgswyVjiQy3jKUynpPxvIwXJKjKz6x+8wiGf7eJpV//EM9DMULzujnTY1Emxjts/9d68x2hYkX5W9o72hl6mw2hP7fKA0KKUwy/7NX6jgwp/cV4zDPXu4UcI1IyxdWF3zNaZHQ97Quvj/AoPxSfli2u/v6ujCRJI0jJgSMlS/xjWrWbjCAlehqq8gurvCH281gN9nmsBjNlhYZBj0DDoRJoBJQGPQqNhEZBGVAmNBoaA5VCj0FjoRwoF8qHxkEF0GBoEPQ4lA4Ngcqg8VA59ARUAU2AJkKp0CSoEqqCJkPVUBb0JFQDTYFSoKnQNOgpaDpUC/WDZkAzoVnQbKgOyobqoYFQA1QIPQTNgZ6G5kJ2aB6kQI2QDZoPPQM9C/WHmqBmyAEtgBZCA6AWqBXKg9ogJ7QIWgy5oCWQG1oqS1X+0fpgS9fNtnSJwcc/wXFI98/erjvZ0pUcpvyw7u36JWqYeMXyMaP5nykKgdWY5hJ/uh/LxYw00XW9rEm8+u6sqEm87u60qkm+4u6svEn8opMTZsnT1JL1zq3rQGkKLfk771MJxYskpd2qSTXRP9268jT+nTf7lkbVav+W/NdO/BLTRQm2VrvNWyInfyWq8qv4902MXNZi5LIW44q1GG+txQhdLUY1azEKV4tRuFqMwtVifLAWI221GGmrxUhbLcbWajG2VotxqVqMRNViJKoWI1G1GImqxUhULcaXajHWVYtRv1qMPdViBKsWI1G1GImqxUhULUaiajESVYtxsFqMS9ViXKoW41K1GDGrNUeG/tkqH6z8IkbdXzRH3f/l5q/M+MtMeVZ+aYrX6qiUO3mN9u0V3bhLr79YVSM9xDdOBqBIhC9e70codSlyNCSmBL6Al6ipFyEP5Ie2QzuhEmg3tBJaBa2B6qA90FqoFKqH9kL7oHVQObQeOghtgA5Bk6BN0BGoA6qCjkKToSaoCzoBqVAWVA21QCehLVAbdAo6DW2D2qEiaAe0AiqDlkNnoLPQOeg8dAEKQJegi9BlSIeuQFehIHQN6oYyoWVQDZQBbYUs0GpoI7QZ8kG7IA1qgDqh/dAB6DB0DDoOWaE0KBvKg3KgXCgfKoAKoXRZqvL/WeWlx8/GnzIUGgYNh0qgEdBIaDQ0BiqFxkLjoDJoPDQEKocmQFVQNTQFmgpNg6ZDtdBMaBZUB9VDc6C5kB2aB82HmqBmyAEtgBZCLZATWgQthpZAbqgRcslSjSJd3if1BoZ33sBy+zewT+oNDMi9gaX4b2Dx/RtYfP+G2bX+1/i3vZPzz5PHnicPNn5OdDzERfJI877nliePK0+cUp44nDxx+HHiAPKvGk8cnejzZKRoN84UT55o3M+4GCs+kjxUvO9h4smjw5PHH3/G+DJuTTpQ+/r5x8njvxOnfItDlZWnRFE3X/xbL4mvkjjvu8/JyOJEcuVfxWclj/lOniXd90Tk5MHfg8T4gbjoe1K3OOF9V6p244Ruo6w0rs6LhxJHIRs9R+MH2aiJYX6LUiIeaRSPiD9s4kDs5HnHN47VTp5y/EnjIk9cJI40Th53feOU6+RpxYnJg8/HXyj/Zr35GfrJMZh3P/TyqlW7g6GXZI3cd3zlNsMqydGUWw6i3IuRkt8dIPndcRExfHFC/I5vM0DyTo66ufXgx23GPJJDHTcZ2PgN0uh1pNHrSKPXkUavI41eRxq9jjR6HWn0uplGv41/20QxPxdnl8w1O2L//qELrHuVU+IF8KL13gWWskg8NOwuRpeyWHzFQ78nxJLZ9c4iK5lLyePYRfQpv7DdNMUS4RWOv2j+Q7xolBni+RnXe+TKq/G5zv9EBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWhHBWg3K8D/ssoTwjomhHVMCOuYENYxIaxjQljHhLCOCWEdE8I6JoR1TAjrmBDWMSGsI/F1TAjrmBDWMSGsY0JYx4SwjglhHRPCOiaEdUwI65gQ1jEhrGNCWMeEsI4JYR0TwjomhHVMCOuYENYxIaxjQljHhLCOCWEdE8I6JoR1TAjrmBDWMSGso43WMSGsY0JYx4SwjglhHRPCOiaEdUwI65gQ1jEhrGNCWMeEsI4JYR0TwjomhHVMCOuYENYxIaxjQljHhLCOCWEdE8I6JoR1TAjrmBDWMSGsY0JYx4SwjglhHRPCOiaEdUwI65gQ1jEhrGNCWMeEsI4JYR0TwjomhHVMCOuYENYxIaxjQljHhLCOCWEdE8I6JoR1TAjrmBDWMSGsY0JYx4Swjglh3awT/9sqr4EvxrmHxTj3sBjnHhbj3MNinHtYjHMPi3HuYTFOOizGSYfFOOmwGCcdFuOkw2KcdFiMkw6LcdJhMU46LMZJh8U46bAYJx0W46TDYpx0WIyTDotx0mExTjosxkmHxTjpsBgnHRbjpMNinHRYjJMOi3HSYTFOOizGSYfFOOmwGCcdFuOkw2KcdFiM3kIxTjosxkmHxTjpsBgnHRbjpMNinHRYjJMOizFNVIyTDotx0mExTjo0tRw6A52FzkHnoQtQALoEXYQuQzp0BboKBaFrUCa0DKqBMqBuKAfKhfKhAigdskA+KBvSoAaoE9oPHYaOQcchK5QGrYY2QpuhrdAuqBA6AOXJUhVLigjOxBLpt6UGwcRCGeNkTJFRK2OqDLeMuTIeljFUxjAZ02UMlzFCxkgZM2XMkjFaxlgZ9TIGyZgjY7yMMhlDZEyQYZcxT8YSGQ4ZLTIWyVgsY76MaRJUxRr/0xaJsQGbZq7zHWgVH0hJue3O6/jKW+Vh2x/uSltbys2HjMRI0RmMHfUdMhKjHoHExPvHxcXdGDsSAzdfEJ8qRjf+Ulx8xLj4Wqr2zkaT+g4ifdn4bPGXdIlfS5pmjirlaXcy+n2rkaN3NsCdYXz2IO12w9o3xoHuZPjnS8bXG6LddsD6q8ZThmk3BohUJTVFHtRpxKBOIwZ1GjGo04hBnUYM6jRiUKcRgzqNGNRpxKBOIwZ1GjGo04hBnUYM6jRiUKcRgzqNGNRpxKBOIwZ1GjGo04hBnUYM6jRiUKcRgzqNGNRpxKBOIwZ1GjGo04hBnUYM6jRiUKcRgzqNGNRpxKBOIwZ1GjGo04hBnUYM6jRiUKcRgzqNGNRpxKBOIwZ1GjGo04hBnUYM6jSagzofSabyH4nXaqIw+ViKXCR9zHxuvxR5GdJePMXUi5AHWgGVQCuhVdBqaA2UAWVCa6FSaDm0DiqDyqH10AZoErQR2gR1QFXQZEiFsqBqaDNUA22BtkIWaBv0EuSFfJAf2g7tgHZCu6DdUB20B6qH9kL7IA0qghqgTmg/dAA6CB2CDkNHoKPQMeg41AR1QSegbqgFOgm1Qaeg09AZ6Cx0DjoPXYAC0EXoEnQZ0qEr0FUoCF2DrFAalA3lQTlQLpQPFUCFULosVUlDez83/pSh0DBoOFQCjYBGQqOhMVApNBYaB5VB46EhUDk0AaqCqqEp0FRoGjQdqoVmQrOgOqgemgPNhezQPGg+1AQ1Qw5oAbQQaoGc0CJoMbQEckONkEuWqqTHX4qJVvttpOLbaBHeNj+hf4r59jAWZYEo3PvF1xPHq9iMW3Rb/vBmuu/jFTnvcjIbc9j2bdrtFuKoSmaKPNy9FOXCUiSFqRchP7QB2gkdgTqgKugotBKaDK2CuqAT0BpoD1QHlUJZUDWkQmuhk9AWqA06BZ2GtkHtUBG0AyqDlkMZUCZUA3VDWyEL5IOWQSugXdBqSIMaoE5oP3QA2ggdho5Bx6HNslQlC/2lw/iHHcaNYMoDrYBKoJXQKmg1tAbKgDKhtVAptBxaB5VB5dB6aAM0CdoIbYI6oCpoMqRCWVA1tBmqgbZAWyELtA16CfJCPsgPbYd2QDuhXdBuqA7aA9VDe6F9kAYVQQ1QJ7QfOgAdhA5Bh6Ej0FHoGHQcaoK6oBNQN9QCnYTaoFPQaegMdBY6B52HLkAB6CJ0CboM6dAV6CoUhK5BVigNyobyoBwoF8qHCqBCKF2WqgxIDkqdskr33DUk6DXzudnJ5y60Smn0a3MifmCKvE50iE2+TYdgWn4IpuWHYFp+CKblh2Bafgim5YdgWt7UR6Hd0EpoFbQGqoP2QGuhUqge2gvtg9ZB5dB66CC0AToETYI2QUegDqgKOgpNhpqgLugEpEJZUDXUAp2EtkBt0CnoNLQNaoeKoB3QCqgMOgOdhc5B56ELUAC6BF2ELkM6dAW6CgWha1A3lAktg2qgDKgfNAAaCD0E2aBUKAXqD1mgBmgrZIXSoNVQDpQL5UMFUDq0EdoM+aBdUDakQYVQJ7QfOgAdho5Bx6E8WaqSE4/tbjEkYJPuj3/D6sZ/MyM+FxH/XSwz/C62AnwXWwG+i4Wh38VWgO9iK8B3sRXgu+a3zUu2O+ut8eda7I+Lx/PRF9ZRCuoo+nUU/ToKQx2FoY5SUEeHQEcpqKN7oKN7oKNDoKNo1FE06ugQ6OgQ6CgodRSUOgpKHZ0FHd0DHd0DHWWijs6CjqJRR9dBR2dBRwmpo+ugo+ugo7zU0ZHQUVDqKCh1FJQ6uhw6uhw6uhw6ik0dxaaOLoeO0lNH6amj9NTRATHVDhVBO6AVUBm0HDoDnYXOQeehC1AAugRdhC5DOnQFugoFoWtQJrQMqoEyoG5oK2SBVkMboc2QD9oFaVAD1Anthw5Ah6Fj0HHICqVB2VAelAPlQvlQAVQIpctSlUHx4Ewuk0ksA4ov8bEvMS4axMVcTVpBIxZzTNJuHFCT3Hf2kvFAhSYtBUpscEssCVKVwRic2YPqYw+qjz2oPvagBt2DWmSP2XoVpDw4DupWx0F5U7QHx0FpH9BxUIUfmhdm39fjO9o12/fVd8sX3T1/iX3VepOX2F1+ZX2QL6ibvI4eSrn5YUN1Yvrpqk3jYUMaQuGWZ7Eq9eKzN9q0257KOgTltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ8FtQ8FtQ8ltA8ltA8ltA9Fsw9lsg8FvA9Fug+ltw/Ftg/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltQ/ltc8sr4tuntnxhP6t3G7cwanZtzyyUFWKsdRpXvwnGQoNg4ZDJdAIaCQ0GhoDlUJjoXFQGTQeGgKVQxOgKqgamgJNhaZB06FaaCY0C6qD6qE50FzIDs2D5kNNUDPkgBZAC6EWyAktghZDSyA31Ai5ZKnKw7d4xRudQ+WCXKTcQW2SJmqTTyTqy6/f7h5IBuAPzR9jaHKg8JL5UYuyJb7vZViKvJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UMYNg1hP30I++lD2E8fwn76EPbTh7CfPoT99CHspw9hP30I++lD2E8fwn76EPbTh7CfPoT99CHspw9hxDmE/fQh7KcPYT99CPvpQ9hPH8J++hD204ewnz6E/fQh7KcPYaA7hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPYTx/CfvoQ9tOHsJ8+hP30IeynD2E/fQj76UPmZMsj6PV9PZ72XuhFyAP5oe3QTqgE2g2thFZBa6A6aA+0FiqF6qG90D5oHVQOrYcOQhugQ9AkaBN0BOqAqqCj0GSoCeqCTkAqlAVVQy3QSWgL1Aadgk5D26B2qAjaAa2AyqDl0BnoLHQOOg9dgALQJegidBnSoSvQVSgIXYMyoWVQDZQBdUNbIQu0GtoIbYZ80C5IgxqgTmg/dAA6DB2DjkNWKA3KhvKgHCgXyocKoEIoXZaqDEd3rCn+lKHQMGg4VAKNgEZCo6ExUCk0FhoHlUHjoSFQOTQBqoKqoSnQVGgaNB2qhWZCs6A6qB6aA82F7NA8aD7UBDVDDmgBtBBqgZzQImgxtARyQ42QS5aqlBgvRTFjpxy0inf3GoFlG6+imn0VyzZexbKNV9H/eBXLNl7Fso1XsWzjVbOSePT6/heLstNcWmhRVsXnA0fi53kNP89r+Hlew8/zGn6e1/DzvIaf5zX8PK+ZP8+o+LcV+1Q+KrbXDBb9zBXxQfbRuHWbces249Ztxq3bjFu3GbduM27dZty6zbh1m3HrNuPWbcat24xbtxm3bjNu3Wbcus24dZtx6zbj1m3GrduMW7cZt24zbt1m3LrNuHWbces249Ztxq3bjFu3GbduM27dZty6zbh1m3HrNuPWbcat24xbtxm3bjNu3Wbcus24dZtx6zbj1m3GrduMW7cZt26zeeuOucV8j0O8WhfbEuMjs8x3eXjHoyu/f0xFVUrveOryNm/Sfuv3Zr/NW7Lf5g3YP0Tvu/6e3lP9nr+V+qvGRYVNu+P3VMcM7nt6S/W7+07qd+kN1FXlMbQ230Nr8z20Nt9Da/M9tDbfQ2vzPbQ230Nr8z2ztRkr2mCf8VNY423wOHSrL8dvfS/0IuSB/NB2aCdUAu2GVkKroDVQHbQHWguVQvXQXmgftA4qh9ZDB6EN0CFoErQJOgJ1QFXQUWgy1AR1QScgFcqCqqEW6CS0BWqDTkGnoW1QO1QE7YBWQGXQcugMdBY6B52HLkAB6BJ0EboM6dAV6CoUhK5BmdAyqAbKgLqhrZAFWg1thDZDPmgXpEENUCe0HzoAHYaOQcchK5QGZUN5UA6UC+VDBVAhlC5LVR4XOXrcyNGJqSJHy5DmbyLN30Sav4k0fxNp/ibS/E2k+ZtI8zfNNB+fPDiNb3mQrJLuZG/+ZOOiCZv0f2NcrBcXKJM2iEduUyYlN/LPMC66xUWyXnrSuLh88z3+Ygv7R8WHkpv9k8VVYtf/XxsPXBSflNj+nyznklVX32IrcTRAosa6XlopI8S/8lPic/oWV4naTXlUPOmzKdqNAwVqRIEkHrhedynzxFN2iJ83ebLAIOND07SbnTCQLNLeNi6+lKpJZw4oxiflXD8cwF5kPPBD4yNfFU/5O/Fc8UmPGh95WJMqvB8ZFzFxUWx8ZKQmptEs9jLtJqVf4ryCRAn4tPF/uyaVgomDDJRR4vs3aTeOL3AZH/nx76kNk+cYJCvB5KkFydW7o8UXbtaSxaEyRjzg1KTTFZ4wHnhOk2rDZIGaKBKVUvFJq7SbHYIg1i/ki4unjKes0aRz3PpWicnqcKLx3C3ajSqxwvj/S5pZp24Wn/tL42Kc+Nw+dWOyTE32C94wLjrFxfWSUnlM/LQ7Nam2TJ600LfIrDSe26lJNWar8cBx7cZ5DcpY8eWuaPHTGewh7UY3JtkPGyee8eea9AaXj4tHvqhJR0wkq9HEQQ5KqnjOYE060SFRn97oVfXtTCWP8HjG+OwvayL6LfZvGv9/3fjAHvFrSBzPkewd9TMe+Cst2QNSxotv/NfajZ6PUiYe+YF2o+vzx8b/f2R8wCY+8BNN6vkkz/ZIHtfxT8ZT/kETc+AW+y+15GkdSrn43N9qUj+nz5kcT4in/Kcm9W6S/Z1kN6fv2RyJ/k7ffo441DJFXEwyLtLk7o1SET8vUjyU6Nckj+hIdHCUCeI5g8Vzkl2dRMfmceOBoeIj1zs0ykTx3DHikcR5HkbqGFdjcQRm8mSPXxsXk8XFbONivLinKsWza8Szk4d9VImHnpJPvrzR0fmMcTFDfCjZv0l2a24cBFIeb5G+eb2Z8sYXx38L+jZUJktVnsCQlxJveYdCw6DhUAk0AhoJjYbGQKXQWGgcVAaNh4ZA5dAEqAqqhqZAU6Fp0HSoFpoJzYLqoHpoDjQXskPzoPlQE9QMOaAF0EKoBXJCi6DF0BLIDTVCLlmqUoGX4kKb/FI0NQyaDg2HaqESaAQ0EpoJzYLqoNHQGKgUGgvVQ+OgOVAZNB6aC5VDEyA7NASaBy2BqqAmqBlyQAughVA11AI5oUXQYmgKNB+aCrmhabJUZcL1RWLmg5uwymKTWe1PjD9ls6hlRB6/bFz8QjQ+iQVkYSwgC2MBWRgLyMJYQBbGArIwFpCFsYAsjAVkYSwgC2MBWRgLyMJYQBZGpyeMBWRhLCALYwFZGAvIwlhAFsYCsjAWkIWxgCyMBWRhLCALYwFZGAvIwlhAFsYCsjAWkIWxgCyMBWRhLCALYwFZGAvIwlhAFsYCsjAWkIWxgCyMBWRhLCALYwFZGN3UMBaQhbGALIwFZGEsIAtjAVkYC8jCWEAWxgKyMBaQhbGALIwFZGEsIAtjAVkYC8jCWEAWxgKyMBaQhbGALIwFZGEsIAtjAVkYC8jCWEAWxgKyMBaQhbGALIwFZGEsIAtjAVkYC8jCWEAWxgKyMBaQhbGALIwFZGEsIAtjAVkYC8jCWEAWxgKyMBaQhbGALIwFZGEsIAsj2sJYQBbGArIwFpCFsYAsjAVkYSwgC2MBWdgMz0lYaxtAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGEJUBRGUAURlAVAYQlQFEZQBRGUBUBhCVAURlAFEZQFQGzKisvD7Zbz44G9XxbPQaZqNun41e0Wz0imajcp6NHsVs1Puz0deZjX7CbLNWrsJo+z/i3jTVDZ2EMqAiaBnULktVJnMRhBh3/Dsx+tFn421i3Ev5iBhOUVK12y19uM1W12q0WTkpcpuVg7GRHMyQ5GCkxNQj0HCoBBoBpUGPQiOhUVAGlAmNhsZApdBj0FgoB8qF8qFxUAE0GBoEPQ6lQ0OgMmg8VA49AVVAE6CJUCo0CaqEqqDJUDWUBT0J1UBToBRoKjQNegqaDtVC/aAZ0ExoFjQbqoOyoXpoINQAFUIPQXOgp6G5kB2aBylQI2SD5kPPQM9C/aEmqBlyQAughdAAqAVqhfKgNsgJLYIWQy5oCeSGlspSlSfRJPwUTcJP0ST8FE3CT9Ek/BRNwk/RJPwUTcJPzSah5t4uSkvORt1m2jU565Kchbo/1qslp0Ix4bnuw7+U7X1fwZacivyQLmWbEr8Jjhm+Ir6KWBUxOb6AeSpOWNqfIt9Opl6EPNAKqARaCa2CVkNroAwoE1oLlULLoXVQGVQOrYc2QJOgjdAmqAOqgiZDKpQFVUOboRpoC7QVskDboJcgL+SD/NB2aAe0E9oF7YbqoD1QPbQX2gdpUBHUAHVC+6ED0EHoEHQYOgIdhY5Bx6EmqAs6AXVDLdBJqA06BZ2GzkBnoXPQeegCFIAuQpegy5AOXYGuQkHoGmSF0qBsKA/KgXKhfKgAKoTSZanKNFQzb6GaeQvVzFuoZt5CNfMWqpm3UM28hWrmLbOaeSr+ba//Jux/IZ6RIuMhGTYZz8lIlfGsjOdl9JORJqO/jFEyXpCRKSNLxgAZ2TIGysiRkSsjT0a+jAIZg2UMklEoI13GEAmqMh2zzP8VfzEMhYZB06HhUC00AiqBRkIzoVlQHTQaGgONheqhcdAcaC5UBo2HyqEJkB0aAs2DlkBVUBPUDDmgBdBCqAVaBC2GpkDzoamQG5omS1Vq8ZZOWThRPAsnL2fh5OUsczhtBsq0QylyTph6EfJAK6ASaCW0CloNrYEyoExoLVQKLYfWQWVQObQe2gBNgjZCm6AOqAqaDKlQFlQNbYZqoC3QVsgCbYNegryQD/JD26Ed0E5oF7QbqoP2QPXQXmgfpEFFUAPUCe2HDkAHoUPQYegIdBQ6Bh2HmqAu6ATUDbVAJ6E26BR0GjoDnYXOQeehC1AAughdgi5DOnQFugoFoWuQFUqDsqE8KAfKhfKhAqgQSpelKjNvsfw+Ofrz7g9RHXdHh6i+u7NTf/+RqdJJqaesFqtF/HfXjkx9DyelvqsDUm99LuptjkNNDnPc5PDTWcnzvI6LD7SLgbP4fM1srOH6MYrxH5sldh023G20yQls6kXIA/mh7dBOqATaDa2EZkGroDVQHbQHWguVQvXQXmgftA4aApVD66F50EFoA3QImgRtgo5AHVAVdBSaDDVBXdAJSIWyoGqoBToJbYHaoFPQaWgb1A4VQTugFVAZtBw6A52FzkHnoQtQALoEXYQuQzp0BboKBaFrUDeUCS2DMqAaaCtkgVZDG6HNkA/aBWlQA9QJ7YcOQIehY9BxyAqlQdlQHpQD5UL5UAFUCKXLUpV6jGL8tXhGigybjFQZH5HRT0aajHQZ/WVkyMiUkSVjgIxsGQNl5MjIlZEnI1/GIBmDZRTIKJTxkIwhMoplPCxjqIxhMh6RMVxGiYwRMh6VMVLGKBmjZYyRUSrjMRljZYyT8biMMhnjZZTLeEJGhYwJMibKmCSjUkaVjMkyqmU8KaNGxhQZU2VMk/GUjOkyamXMkDFTxiwZs2XUyaiX0SBjjoynZcyVYZcxT4Yio1HGfBnPyHhWRpOMZhkOGQtkLJTRIqNVRpsMp4xFMhbLcMlYIsMtY6mM52Q8L+MFCarSEA/ARLuyE8vNdmKB4E4s2NuJ5Zc7sWjtJSz0ewmL+V7CUruXsMTyJSxyfAmL614yS+I51we7LcrXrfGfxqL8Zfx43KfFHutECZMuulybjC7TzSfc+/a97tmE+z8ZF4PFI8mZ92Rfq+8UfLKvldjELB2Uc28m45U28Q1esCVO5zll0+7WBH1y33Fya3KfmXqxKO6s+I7vZMr+TrYa38ncffLkoUSH+db7NO9kEv/eTN6LfZxXbrqx+F3N4ie3dYpN+x+/C/P64mS0T3CC3x6/6faK720en23eku0YP2zHSHE7xg/bMX7YjhHDdowbt2PEsB2jyO0YRW7HuHE7xhbbMbbYjnHjdowbt2OkuB1jw+0YFWzH2HA7xgjbMVLcjjHCdowNt2NsuB3jh+0YKW7HGGE7xgjbMYrcjlHkdowit2PEsB3jxu0YP2zH+GE7xg/bMYpsqh0qgnZAZdByKAPKhGqgbmgrZIF80DJoBbQLWg1pUAPUCe2HDkAbocPQMeg4tFmWqsyL34H/IWInNf5zW5T14uI/jYt11vjPblH2p8a/odFMpcZ/KouyPDX+D7Eom8TFf4m2RFz8t3Hhjw9lKfGvm/gDDcWfciheHkPxhx1q/liNooUWTdS/pIjGeX5yPLRF/EzJpsoIaPsvjPaov2iPnrFef0s3Zen11lm8c5uSKR65gK3ryYwTTVzk+rkm9oXGkweIJ/9QfKFscfX3iUb05+KhgeKhX8t72JUc8dBvEjVAitjpnhvfjZ+imT//IPFQnnhohLjKF1cjxVWWOB+gVTt5423pEu89pzjFh/7xRn6rRnkgD+7tQTzuQTya8kB+aDu0EyqBdkMroVXQGqgO2gOthUqhemgvtA9aB5VD66GD0AboEDQJ2gQdgTqgKugoNBlqgrqgE5AKZUHVUAt0EtoCtUGnoNPQNqgdKoJ2QCugMmg5dAY6C52DLkAB6CJ0GdKhq9A16Dx0CboCBaFMaBlUA2VA3dBWyAKthjZCmyEftAvSoAaoE9oPHYAOQ8eg45AVSoOyoTwoB8qF8qECqBBKl6Uqz8aDUyR4rYjrgngQJ7o/thTNPFflI+Jj08XHSuNladMH3xd8R11A0XFcJJ6TPNDqQ70c+w56ex9EJ+/u9O2Sh0Z9mFdoJ/t2d22pdnP8lkkMnf5ok3ZjxCuOhTLGyZgio1bGVBluGXNlPCxjqIxhMqbLGC5jhIyRMmbKmCVjtIyxMuplDJIxR8Z4GWUyhsiYIMMuY56MJTIcMlpkLJKxWMZ8GdMkqIoDKwktNunXfF3DoOnQcKgWGgGVQCOhmdAsqA4aDY2BxkL10DhoDjQXKoPGQ+XQBMgODYHmQUugKqgJaoYc0AJoIdQCLYIWQ1Og+dBUyA1Nk6UqC7CC4SdYwfATc7h24T3u5N1h5y7eM1MO3Z1uXt/e3Y1OXQvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuKxvuK5t5X7Um5zhmipdnohsyEDPrAzGzPtD8zLbrYwoWpVt8ZmI4oRVd6lYMLrRiOKEVXepWDCe0otvcim5zK7rNreg2t2KooRWd6FYMPLSiE92KTnQrBiVaMQzRiiGKVgxDtKK73Yrudis65q0YzGhF57sVne9WdL5b0fluRee7FZ3vVnS+W9H5bkXnuxXd7VZ0t1vRAW1Fx7UVXdVWdE5b0TltRee0FV3OVnR/WzEQ0IruaCs6ta3onLaic9qKzmkrOqet6Jy2omvciq5qK7qqreiqtqIT3Wp2Fp332Z7b+6O3dwedPKNDaP+cdl9twv3w9/HuWtdukbgtlIcT4zpbRPOhDAWTJ7FuQUu+xWxpFsfvKyNAlM+lStk7OX4PeqG10GSoDWqHiqAdUBm0HMqEaqAMqBuyQFshH7QM2g8dgFZAG6HD0C7oGHQcWg1thjSoAeqUpSqu+F8w8cepwJ+jAn+OCvw5KvDnqMCfowJ/jgr8OSrw56jAn6MCf44K/Dkq8OeowJ+jAn+OCvzKK/BrrcCvrgK/rAr8sirwy6rAn7gCf+IK/FEr8EetwJ+xAn/GCvzhKsw/xxIxOyZqvvHx2TH3Ld6NOhGnIq5mop14V4cGLU2Opc4VASFavI+LZ6wXzVlign9UavzPb1G+IdaJzBH9oL8VV0+Lq/XiWftE2yEuNhkX/yI+Nld87CviIY9x8XXb9fB9JZ4+z2HH6tvYsfo2dqy+jR2rb6OL+TZ2rL6NHatvY8fq22Zn9Pl7twOjR/59/94dGPFzypUe8aH3thfjxqHst9mUwUIg2XYlKoI+bdj1EkFZIr52m3YHmzIS72Vw323OeAFnZl2Nv2gehoZCVmgY9Ag0HCqBRkBp0KPQSGgUlAFlQqOhMVAp9Bg0FsqBcqF8aBxUAA2GBkGPQ+nQEKgMGg+VQ09AFdAEaCKUCk2CKqEqaDJUDWVBT0I10BQoBZoKTYOegqZDtVA/aAY0E5oFzYbqoGyoHhoINUCF0EPQHOhpaC5kh+ZBCtQI2aD50DPQs1B/qAlqhhzQAmghNABqgVqhPKgNckKLoMWQC1oCuaGlslRlWbzHMEQ0XINSNfONgJwpUvJ8B/Xdd1DffQd12ndQXX7HrH+W/56Cp2+dc725Nc9NTEmVW4HkaYvJvuBa4yJk06RW9XrroirtWIjjRg/GjZEzN0bO3Bg5c2PkzI2RMzdGztwYOXNj5MyNkTM3Rs7c6D+5MXLmxsiZGyNnboycuTFy5sbImRsjZ26MnLkxcubGyJkb/Tw3Rs7cGDlzo5vhxsiZGyNnboycufGScaND4kaHxI0OiRsdEjdelG50T9x4+brRIXGjC+JG98SNDokbL3Q3OiRudEjc6JC40SFxo0PiRofEjQ6JGx0SNzokbnRI3OiQuNEhcaND4jZvyBdx0IOGDWAaNpxp2EamYYuZho1qmjl44Enuib2Uopl9jE/GuyMrsBvrTakpNGGTkSrjIzL6yUiTkS6jv4wMGZkysmQMkJEtY6CMHBm5MvJk5MsYJGOwjAIZhTIekjFERrGMh2UMlTFMxiMyhssokTFCxqMyRsoYJWO0jDEySmU8JmOsjHEyHpdRJmO8jHIZT8iokDFBxkQZk2RUyqiSMVlGtYwnZdTImCJjqoxpMp6SMV1GrYwZMmbKmCVjtow6GfUyGmTMkfG0jLky7DLmyVBkNMqYL+MZGc/KaJLRLMMhY4GMhTJaZLTKaJPhlLFIxmIZLhlLZLhlLJXxnIznZbwgQVVW3nwCz4kyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxIkyxGmWIavid4TobWy2Sr+nV/B7egW/0Vfwr38Ff7NXzK+6GjX/p1Hzfxq3lykP5Ie2QzuhEmg3tBJaBa2B6qA90FqoFKqH9kL7oHVQObQeOghtgA5Bk6BN0BGoA6qCjkKToSaoCzoBqVAWVA21QCehLVAbdAo6DW2D2qEiaAe0AiqDlkNnoLPQOeg8dAEKQJegi9BlSIeuQFehIHQNyoSWQTVQBtQNbYUs0GpoI7QZ8kG7IA1qgDqh/dAB6DB0DDoOWaE0KBvKg3KgXCgfKoAKoXRZqrLmg19PcX+cWP7gWHIsiHgv6yDEAhr3zdeB3rUFEWsx2tGJ0Y5OjHZ0YrSjE6MdnRjt6DRHO9bFv7TX+FbbU7QbjXklmu9KNG+VaGAq0WxUotmoRNNQiUakEg1FJUK2ErFaiVitRKxWIkgrEbKVCMtKBHclIrASEViJ5q0ScVyJeKxEAFciLCsRlpWI+EqEeiWCuxLBXYngrjRjbr15moTFPlVMxm/gLPkV4/GnNGm2PGhctImPnDcuFomLy8bFCjEPPkMMTqu2+L/WomwRF4m5dWn+/JpxUScuLhgXnxIXF8UEMabWLxkXX7rF1LpuXLwsz7HHVxK8Ki6uikgUF2eNi7/hBL5dXP1IfPCMcfFTcXHOuPiZuAiI5JGn9JPVcgeq5Q5Uyx2ojztQH3egPu5AfdyB+rgD9XEH6uMO1McdqI87UB93oCLuQA3cgaq3A1VvB+rcDtS5HahzO1DndqCy7UBl24HKtgOVbQdu/Q5Uth2obDtQ2Xagsu1AZduByrYDtWwHatkORE3H/8/encfHWe6HoZc9Hu+7wWOb1SyDh/FIMAyybBA28sgy1gwG24MsS9gsxmCEMSDkJSyDWYbFBgts9n2JokZNmtOjJidKWp2e6DZNSG9vervdpv3cm9u0t/ek9+pUTbc0ubfzzlji/dYcwjlADycH/mG+Y8mL3vf9bc/zvkMt+yC17IPUsg9WL5QHPuNe86cmlz7tXvPgEYgfRUqf86bz7k+fiHRwyDo4CTs4CTs4gB2chB0csg4OWQeHrIND1sEJ2sEB7OB07eAAdnAAOziVOzh5OzixOziVOzjUHRzqDk6KDnJMB6dBB6dBB6dBB6dBB6dBB6dBB7mpg9zUQTbqIFN1kJs6yD8dZKoOMlUHuamDbNRBpuogN3WQmzrIPx3kmA7ySAeZo4PM0UHm6CDfdZDvOshwHWS4DnJaBzmtgyzWUb3kHvzJl+Bf7y3Nwa2zZwe/2V+mO1l/hnY5f/l3svZMFHCdwZeWa6rWPwjeP1B5f3znT4kdGSX2fJTY01Jil06JXSwl9piU2L1Uqu6lOFj5Y8e3lhXYTFZgM1mBzWQFNpMV2ExWYPtYge1jBbaPFdgiVmCLWIEtYgW2iBXYIlZgi1iBLWIFtogV2CJWYItYgS1iBbaIFdgUVmBTWIGNXwW2cxXYzlVgO1eB7VwFNnAV2KRVYJNWVbeja9BU1ITWo7loA1qGWtASdB3ahPIoiragraiA2tEO1Il2obPQ2WgSmoZmolloJUqhWnQZuhyl0W2oHjWg2egqNBldjRrRWrQOXYuyqBnNQzG0EbWiHLoeRdBOdAO6Ec1A29BNaA5qQ9vRQtSBbkE3o83o1rB68odOPbmq+nyQ6iNDvhMpVZ8U8q8qKeLwp/cZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbfQZbdU+4+dYI/3HlS95CN2J7kKPoEfRY2g5ehzdjbrQPtSMnkD3ohVoA3oSPYX2ozp0H3oO3Y+OogzqRs+jB1E9egGtQlvQi+gl1INmowbUhk6ig6gdvYxeQYfRHrQMFdFelEJ3oFfRa+h19AZ6E72F3kFvo3fRe+h99AH6EH2EZqHdaA2aiU6gQ6gG3YMeQAfQw+gIKqEW9DR6Bj2LjqHjqBdNQtPQXLQQzUcL0CK0GMXQ9LB68g9VAued5VKiLVKJYTX5fzSpcknV5H/71JMp839rUuWCKNch4XKjQGwpEEkLRJMCkbRAxCgQMQrEiAIxokBcLRAjCsSIAjG3QJQtEIELRNkC8aNApCkQnQtEkwLRpEA0KRA/CsSPAvGjQPwoED8KRIwCEaPA1VbgiipwtRW4vgpcXwWurwJXTYEruEAsK3BFFbguC1xfBa6vAtdXgeurwPVV4OoucLUVuNoKXG0F4kCher4/XLk1ZGpwu+ChUnWEV6jU1I+cWlStyTdOLlVvIT1a2ef96E/ZCPNrtK/g9IHlDx9PBvO5zm+2HHwpQ8kvbRZZpKweqlxQD6E70V3oEfQoegwtR4+ju9F61IX2oWb0BLoXrUAb0JPoKbQfLUV16D6UQ8+h+9FRlEHd6Hn0IKpHL6BVaAt6Eb2EetBs1IDa0El0ELWjl9Er6DDag5ahItqLUugO9Cp6Db2O3kBvorfQO+ht9C56D72PPkAfoo/QCTQL7UYz0Rp0CNWge9AD6AB6GB1BJdSCnkbPoGfRMXQc9aL5aAFahBaj6WgumoSmoRhaGFZP/jGeL/GHTPmrOoFOoploGdqN9oTVkz/CJyu3RMLfXtWesHryj5MKxkgFY6SCMVLBGKlgjFQwRioYIxWMkQrGSAVjBP8xgv8YwX+M4D9G8B8j+I8R/McI/mME/zGC/xjhfoxwP0aAHyPAjxHgxwjwYwT4MQL8GAF+jAA/RoAfI8CPEeDHCPBjBPgxAvwYAX6MAD9GgB8jwI8R4McI8GME+DEC/BgBfowAP0aAHyPAjxHgxwjwYwT4MQL8GAF+jAA/RoAfI8CPEeDHCPBjBPgxAvwYAX6MAD9GgB8jwI8R4McI6WOE9DGC+BgBfozEMEaAHyPAjxHgxwjwYwT4MQL8GAF+jAA/RoAfI8CPEeDHCPBjBPgxAvwYAX6MYDxGMB4jbI8RjMdIDGMkhjESwxiJYYwAP0aaGKsG+Cf40LKbWRSs6hBqD6sn/+RPWfv50/FQwK/FxpkflH/jt0rfbKD5UjfQfPLgBWqaXdUq5qm/FFfTr0/65mr6tKspf1fkm8vp819O1U395075ES+so9xwcpQbTo5yw8lRbjg5yg0nR6sXZGni8RofBH+P8eT3Z9Xk9/TEtDZ/TaQUHtc+U/m+3yv/iP5eKShFyj/u8vfnzwq+9Hjwalcw4n2q9MkWn2+xxaeqc9AkdC46D52PlqML0DR0IboIXYxmolkoji5BK1ACXYrmowVoEUqixehMdAZaiaajpSiFalEdugxdjtLoCjQFZdCVqB6tQg1oNlqN1qCr0GR0NWpE16C1aB2aiq5FTWg9yqJmNBdtQPNQC4qhJWgjug5tQq0oh/LoehRBm9EN6EY0A21BW9E2VEA3oTmoDW1HC1E72oE6UCe6Bd2MdqJdYfXknw1/IvG0oHHpzj838Wj/u6aEwv8O6qod1TB+9NM/O6PyUYL5I5NLf0k/KvGTD9M4xtM5+8g1feSaPnJNH7mmj1zTR67pI9f0kWv6yDV95Jo+ck0fuaaPXNNHrukj1/SRa/rINX3kmj5yTR+5po9c00eu6SPX9JFr+sg1feSaPnJNH7mmj1zTR67pI9f0kWv6yDV95Jo+ck0fuaaPXNNHrukj1/SRa/rINX3kmj5yTR+5po9c00eu6SPX9JFr+sg1feSaPnJNH7mmj1zTR67pI9f0kWv6yDV95Jo+ck0fuaaPXNNHrukj1/SRa/rINX3kmj5yTR+5po9c00eu6SPX9JFr+sg1feSaPnJNH7mmj1zTR67pI9f0kWv6yDV95Jo+ck0fuaaPXNNHrukj1/SRa/rINX1klz6ySx/ZpY+s1FfNNc9XQuV3yiH020FgHyy/aJlc+aHU5EeCmP/toIueXDmcNfldwYuh8oupkcrpXJP/B8E73y2/2B6881vlFx9NqZwlNfl/Obly+dXkP45Ujk5N/o+DgP9L5RffDV58qxyu3678rGpaTwZ/lxdY1SiyqlFkVaPIqkaRVY0iqxpFVjWKrGoUWdUosqpRZFWjyKpGkVWNIqsaRVY1iqxqFFnVKLKqUWRVo8iqRpFVjSKrGkVWNYqsahRZ1SiyqlFkVaPIqkaRVY0iqxpFVjWKrGoUWdUosqpRZFWjyKpGkVWNIqsaRVY1iqxqFFnVKLKqUWRVo8iqRpFVjSKrGkVWNYqsahRZ1SiyqlFkVaPIqkaRVY0iqxpF1jGKrGMUWbkosnJRZOWiyFpFkdWJIusmRdZGiqx4FFnjKLKqUWRVo8iqRpFVjSKrGkVWNYqsahRZ1SiyqlFkVaPIqkaRVY0iqxpFVjWKrGoUWdUosqpRZFWjyKpGkVWNIqsaRVY1iqxqFFnVKLKqUWRVo8iqRpFVjSKrGkVWNYrVVY3jpx4UUn1zCyvGVT2MdqMi2ouOoJloH2pGs9A96F50ByqhZagFPY1SqA49g55FD6Bj6AV0HK1CvagHnUAn0QG0Bh1Eh1A7qgmrJ9/rM0e6guFvpPQpH9HxZXwgx4s/ZR+OPD7CzzcG/6rNwT/mm6WxyjA/mNjP/5F3b37zMclfYEPnS4wphhhTDDGmGGJMMcSYYogxxRBjiiHGFEOMKYYYUwwxphhiTDHEmGKIMcUQY4ohxhRDjCmGGFMMMaYYYkwxxJhiiDHFEGOKIcYUQ4wphhhTDDGmGGJMMcSYYogxxRBjiiHGFEOMKYYYUwwxphhiTDHEmGKIMcUQY4ohxhRDjCmGGFMMMaYYYkwxxJhiiDHFEGOKIcYUQ4wphhhTDDGmGGJMMcSYYogxxRBjiiHGFEOMKYYYUwwxphhiTDHEmGKIMcUQY4ohxhRDjCmGGFMMMaYYYkwxxJhiiDHFEGOKIcYUQ4wphhhTDDGmGGJMMcSYYogxxRBjiiHGFEOMKYYYUwwxphhiTDHEmGKIMcUQY4ohxhRDjCmGGFMMMaYYYkwxxJhiiDHFUHVMceIL1BnB0PzCn3TBUcmvL04qfVNv/Dg3iXxTZnyBMuNk+LMxyj+tcIi/nxB4PwGqqlvRFHQjug1NRdPQDHQxuh3NQrPRHDQXzUPz0QK0EC1Ci9GZ6AwUQ9PR0rB68i+zx/zvk8WrWoZmot1oT1g9+Vcm9m9kJ1W+sya/fFLwC6/yZ55RaRt/Dj2E7kR3oUfQo+gxtBz9PHoc3Y260D7UjJ5A96IVaAN6Ej2F9qM6dB96Dt2PjqIM6kbPowdRPXoBrUJb0IvoJdSDZqMG1IZOooOoHb2MXkGH0R60DBXRXpRCr6LX0OvoDfQmegu9g95G76L30PvoA/Qh+gidQLPQbrQGzURT0Rw0Dy1BETQFTUYzUA1qQYfQJDQN3YPmowVoEVqMpqMH0AH0MDqC5qISiqGn0TPoWXQMHUe9aGFYPfnXKjvuGoJR1XmTStWHDv3h+A6JYOtd+Ydck/+DyZUjUZMfDvZHVPbnHazcLP165du3B28M89jU4Bmr24MXE49NPf05rKc/fnXiYaufPGP1DR5+vZ2reHv13/DmX/BBwV98CjlxtWSIaBnOuwxHN8NPO8N5l+G8y3DeZTjvMpzLGc6RDOdkpvqzeOuTHZS/Fz6MPfm3uQPsjygD/ohU/0fVVP/Oj/yphxMVclAGHw9+6XN8zPO74a1Is6pbkd77S7Ft+5vO66u/PT/oef/4mxasJ//+xGPkgsu9+sSLJcEvfBBcX8EP++XJwaX1IXV6jDo9Rp0eo06PUafHqNNj1Okx6vQYdXqMOj1GnR6jTo9Rp8eo02PU6THq9Bh1eow6PUadHqNOj1Gnx6jTY9TpMer0GHV6jDo9Rp0eo06PUafHqNNj1Okx6vQYdXqMOj1GnR6jTo9Rp8eo02NktRh1eow6PUadHqNOj1Gnx6jTY9TpMer0GHV6jAwfo06PUafHqNNj1Okx6vQYdXqMOj1GnR6jTo9Rp8eo02PU6THq9Bh1eow6PUadHqNOj1Gnx6jTY9TpMer0GHV6jDo9Rp0eo06PUafHqNNj1Okx6vQYdXqMOj1GnR6jTo9RL8WobWLU6THqpRj1Uox6KUa9FKMmilGnx6jTY9TpMer0GJVcjDo9Rg0Wo06PUafHqNNj1Okx6vQYdXqMyjFWres+Go/iKyNBFP/5ShSfX/brUyo/mnINO6nyXTX5fza5cmqUC/FI5W9ak88HL361/OKBSZUzoyZ/cfDiN8svLq0kjz6K7Lu5BO+u/gV+ofIlQXvwB5NKn9SV1dbh40/vDyq9w+9Xqrz+yrf3lP3WpErMqMnvmxwK6Y1seGtkO1oj2/Qa2f7WyHatRjZoNbJ1rJFNWI1swmpkE1Yj264a2XbVyJalRjYpNbJJqZFNSo1sUmpkk1IjW48a2QbVyIawRrYlNbK5qZFNSo1sUmpkk1Ijm5Qa2aTUyBapRrYsNbJlqZEtS41spmqsbhr6KxPDwt7qHQU1rUPB+7/ILsy7ObxV3YkeQY+ix9By9Di6G3WhfagZPYHuRSvQk2g/qkPPofvRUZRBz6MHUT16Aa1CW9CL6CXUg2ajBnQSHUTt6GX0CjqM9qBlqIhS6A40E81Ca9AJdAjVoN1oL7oHPYAOoIfREVRCLehp9Ax6Fh1Dx1FvWD35AXLAc/wzn+OirOoutBctR3ejLnQP2odmolnoXrQC3YH2oxSqQ/eh+1EGPYC60YOoHq1CPWg2akAH0Bp0EB1CNegw+jn0EHoYPYIeRUX0GDqCHkfN6Am0AT2JnkIltAy1oKfRM+hZ9Bw6io6h59EL6DjqRVvQi+gldAK1oZOoHb2MXkGvotfQ6+gN9CZ6C72N3kHvovfQ++gD9CH6CE1C09BctBDNRwvQIrQYxdD0sHryf5WJyh+z2lrVCXQSzUTL0G60J6ye/C+xte/Vypecjc5Bk9C56Dx0PlqOLkDT0IXoInQxmolmoTi6BK1ACXQpmo8WoEUoiRajM9EZaCWajpaiFKpFdegydDlKoyvQFJRBV6J6tAo1oNloNVqDrkKT0dWoEV2D1qJ1aCq6FjWh9SiLmtFctAHNQy0ohpagjeg6tAm1ohzKo+tRBG1GN6Ab0Qy0BW1F21AB3YTmoDa0HS1E7WgH6kCd6Ga0E+1Ct4TVk//lyqLY2eMR8FAw0cifA1t/F6XC6sn/tcpvsC6Ya9waKVVXd35rcuXUqMk/HAw0xiut3fwLqzqEUmH15H/lm89vDX4M3zr1obb52yurFH+98lMZT2c3RsLprKpz0Vp0PlqHlqML0EWoCa1HzSiOLkEr0KVoA0qilWgjSqFatAnVoTRqRUtRDl2PdqJ6tAVtRdtQAd2EGlAb2oE6UCe6Ct2MNqOr0S7UGFZP/ttUXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf1UXf3E2X6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn6qrn5qkn6qrn6qrn6qrn6qrn6qrn6qrn6qrv5qZTP41W/LGp9hdTPD6mZa2c0Mq5sZVjdTq25ml91MrbqZZHYzyexmdtnNfKub+VY3s8tuZpfdTLu6mV12M63sZk7VzbSym6lVN7PLbqZW3Uwru5lWdjPR6mZ22c0Mq5sZVjczrG6mnN1MObuZcnYz0epmrtnNfKub+VY3861uppxV7UHLUBGl0B1oFtqN1qCZ6AQ6hGrQXnQPegAdQA+jI6iEWtDT6Bn0LDqGjqPesHryf+OT3aD/5KvZDfqrn/5JmO1cH+1c/+1c/+1cLe1c/+1cH+1cH+1cH+1cH+3EhnaulnYiRTtXSztXSztRpJ240U5MaSdutHNdtXNdtXMFthN92rnm2rnm2rnm2rnm2rnm2rnm2rnm2rnm2rnm2rnm2rnm2rmS2rkC27nm2rnK2rnK2rnK2rla2rmO27kC27mS2rke27mu2rmu2rmu2rmu2rmu2rmq27nK2rnK2rnK2rn+26vX3K99sdsWW/+o9BO+a/FncstssG21JvhbfXPX4k9qy+xEmNrLdqe91T7/OxMPuPwhV9PEIZg4Nyeur4kTeeIsnbjiguupEN4YP34AT7sEJ47kxOU1cUgnLq/Tj+345ZWPBEk4wc3Apz7ALD8l2Bp8Zuhoj19Up11Lpx3r8Ytr4pifdpWNnwTj19b4OXBG+f+Nn3IKTFx7p58Lp58CE9fexCkwfhGefiqMX42nnxITl9zp58ZpV1pP/teDwWTwvOl/XhlMDlXOi4kHg5YrkdbLyz/TluDHvXL8KaetO8MHf+Lhoacee/rJ337iXzj+Uxn/l/bkf4MtUt0R+psI/U1Fd6FH0KPoMbQcPY7uRutRF9qHmtET6F60Am1AT6Kn0H60FNWh+1AOPYfuR0dRBnWj59GDqB69gFahLehF9BLqQbNRA2pDJ9FB1I5eRq+gw2gPWoaKaC9KoTvQq+g19Dp6A72J3kLvoLfRu+g99D76AH2IPkIn0Cy0G81Ea9AhVIPuQQ+gA+hhdASVUAt6Gj2DnkXH0HHUiyahaWguWojmowVoEVqMYmh6WD353zy15NT6J0Fg/5s8wmAFQ9UVDAFXMPytKoqmomloOpqBZqJZaDaag+aieWg+WoAWokXoDHQmWoxiaAlaipahs9DZ6Bx0LjoPnY+WowvQhegidDGKo0vQCpRAl6IkWolSqBbVocvQ5SiNrkAZdCWqR6tQA1qN1qCr0NWoEV2D1qJ16FrUhNajLGpGG1AL2oiuQ5tQK8qhPLoebUY3oBvRFrQVbUMFdBNqQ9tRO9qBOlAnuhntRLvQLehWdBu6PayecjddfaJoTf7RyaEjWM+Qqp5hWj1jqXqGTfUMm+oZL9Uzeqpn2FTPeKme8VI9g6h6hk31jJfqGT3VM2yqZ9hUz2ConsFQPYOoesZE9YyJ6hlS1TM0qmdoVM8Aq54RUj3jrHrGWfWMs+qrw6bhr64r/v3/AV3xab3wD22BJzrfiV74i7fAP7T1LTevrf+k9EVb4C+98/0uFVGKiihFRZSiIkpREaWoiFJURCkqohQVUYqKKEVFlKIiSlERpaiIUlREKSqiFBVRioooRUWUoiJKURGlqIhSVEQpKqIUFVGKiihFRZSiIkpREaWoiFJURCkqohQVUYqKKEVFlKIiSlERpaiIUlREKSqiFBVRioooRUWUoiJKURGlqIhSVEQpKqIUFVGKiihFRZSiIkpREaWoiFJURCkqohQVUYqKKEVFlKIiSlERpaiIUlREKSqiFBVRioooRUWUoiJKURGlqIhSVEQpKqIUFVGKiihFRZSiIkpREaWoiFJURCkqohQVUYqKKEVFlKIiSlERpaiIUlREKSqiFBVRioooRUWUoiJKURGlqIhSVEQpKqIUFVGKiihFRZSqVkR/e3wP5B9V7vH9XsBimXsq/K3K4uotwaDx750aPeaPBxskbg3e+qtBEN9dfjEynob/7NSHJ+XbytE8f1vwRVsrcX2kEtcfLvv54EueLr94pvIIt/+p8gu/U04fx0rBhtia1jmlaiZ/L/gDPz71t/1b1Vrg7wR/vWAr6N1Tgr/eb391pcGbk0s/q6XB13Uq/ne/uqP9Kz/S0a4udPzKpB/3uOd3Bt9fF16I/GSB5C86FU5fKBk/BU5bHPvLv1DyO5/zcVH56cFPfFPwNcH68++G/+jxwx4sSF45pfQpz4v65FCe+hf15H+XpZJ9lb7lIXQnegQ9ih5Dy9Hj6G7UhfahZvQEuhetQE+i/agOPYfuR0dRBj2PHkT16AW0Cm1BL6KXUA+ajRrQSXQQtaOX0SvoMNqDlqEiSqE70Ew0C61BJ9AhVIN2o73oHvQAOoAeRkdQCbWgp9Ez6Fl0DB1HvWH15D+meczSPGZpHrM0j1maxyzNY5bmMUvzmKV5zNI8ZmkeszSPWZrHLM1jluYxS/OYpXnM0jxmaR6zNI9ZmscszWOW5jFL85ileczSPGZpHrM0j1maxyzNY5bmMUvzmKV5zNI8ZmkeszSPWZrHLM1jluYxS/OYpXnM0jxmaR6zNI9ZmscszWOW5jFL85ileczSPGZpHrM0j1maxyzNY5bmMUvzmKV5zNI8ZmkeszSPWZrHLM1jluYxS/OYpXnM0jxmaR6zNI9ZmscszWOW5jFL85ileczSPGZpHrM0j1maxyzNY5bmMUvzmKV5zNI8ZmkeszSPWZrHLM1jluYxS/OYpXnM0jxmaR6zNI9ZmscszWOW5jFL85ileczSPGZpHrPV5vH3uDHpzwkCf04QqGoSOhedh85Hy9EFaBq6EF2ELkYz0SwUR5egFSiBLkXz0QK0CCXRYnQmOgOtRNPRUpRCtagOXYYuR2l0BZqCMuhKVI9WoQY0G61Ga9BVaDK6GjWia9BatA5NRdeiJrQenQpyL0+qmVQT/Hfq7Wa+aC7agOahFhRDS9BGdB3ahFpRDuXR9SiCNqMb0I1oBtqCtqJtqIBuQnNQG9qOFqJ2tAN1oE50M9qJdqFbwurJ/73KSK0yP1saNJnjI7WJsdnEIK0n/z+fepZZ9Tc4g7h1RvW3+/s0or9II/qLNKJV3YUeQY+ix9By9Di6G3WhfagZPYHuRSvQBvQkegrtR3XoPvQcuh8dRRnUjZ5HD6J69AJahbagF9FLqAfNRg2oDZ1EB1E7ehm9gg6jPWgZKqK9KIXuQK+i19Dr6A30JnoLvYPeRu+i99D76AP0IfoIzUK70Ro0E51Ah1ANugc9gA6gh9ERVEIt6Gn0DHoWHUPHUS+ahKahuWghmo8WoEVoMYqh6WH15P+XT7+rq5O40UkE7SRmdhI3OomZncSGTmJDJ7Ghk9jQSTztJFJ0El07iRSdRIpOIm8nsbaTONxJrO0kpnQSUzqJPp1E7E4iTCcRppMI00mE6STCdBJhOokwnUSYTiJMJzGlk5jSyVXWydXZyfXYyRXYyRXYyRXYyXXVyTXeSbTr5Jrr5Mrt5Ars5Ars5Ars5Ars5Ars5Prv5Hrs5Hrs5HrsJFJ0Vq+I3x9fCny3svb3D77QRzG0Fkuf65MY/tfKnzL+s72VmqyqQygVVk/+H/LMlsmVLbfnoHPRWnQ+WocuQMvRRagJrUfNKI4uQZeiDSiJNqJNKIVqUR1Ko1a0FOXQTlSPtqCtaBsqoJtQG+pAnegqtBldjXahxrB68v8o/DC91n8d+htV0JP/x1/tR4N8xu2Nn/H5H59+D+NdwTtfzT2Mp926+CPcljhxN+JP8nM7wvcessb649xx+OXeaPjF7i/syf+Tyhka3DL2q8HOi7agvRwJfuPfK7/4h8E3/Wn5xaTgnfFx3TDjumHGdcOM64YZ1w0zrhtmXDfMuG6Ycd0w47phxnXDjOuGGdcN0/YOM64bZlw3zLhumHHdMOO6YcZ1w4zrhhnXDTOuG2ZcN8y4bphx3TDjumHGdcOM64YZ1w2T5YYZ1w0zrhtmXDfMuG6Ycd0w47phxnXDjOuGGdcNM64bZlw3zLhumHHdMOO6YcZ1w4zrhhnXDTOuG2ZcN8y4bphx3TDjumHGdcOM64YZ1w0zrhsOj+tOqRnNRRvQPNSCYmgJ2oiuQ5tQK8qhPLoeRdBmdAO6Ec1AW9BWtA0V0E1oDmpD29FC1I52oA7UiW5GO9EudEtYPfl/eupGgeqbBW48LHCLW4Eb7ArchljgNsQCN8MVuBWvqn2oGc1C96B70R2ohJahFvQ0SqE69Ax6Fj2AjqHn0QvoOFqFelEPOoFOogNoDTqIDqF2VBNWT/5/++Zz4n6KHnrxdak3v8pnXfyg/P/gL/v1fOZFT/6fVa6Y4POCfif4iuDTgf6k0vz/wfjE4buV5xz882+urG+urJ/klRVcSDM+7Qr7ul5Z/4KPAVhQSVc/hx5Cd6K70CPoUfQYWo5+Hj2O7kZdaB9qRk+ge9EKtAE9iZ5C+1Edug89h+5HR1EGdaPn0YOoHr2AVqEt6EX0EupBs1EDakMn0UHUjl5Gr6DDaA9ahopoL0qhV9Fr6HX0BnoTvYXeQW+jd9F76H30AfoQfYROoFloN1qDZqKpaA6ah5agCJqCJqMZqAa1oENoPlqAFqHFaDp6GM1FJfQ0egYdQ8dRL5qEpqF70APoADqCYuhZtDCsnnIi/cruZDn0s3tL89f1JpX/fbzKHaisq/0fX5fbmMZvhfmitzP9tN3EVL39quUnc6ZU70T6u3/ROfOH3MpQy5i0lrFeLePcqqJoKpqGpqMZaCaahWajOWgumofmowVoIVqEzkBnosUohpagpWgZOgudjc5B56Lz0PloOboAXYguQhejOLoErUAJdClKopUohWpRHboMXY7S6AqUQVeierQKNaDVaA26Cl2NGtE1aC1ah65FTWg9yqJmtAG1oI3oOrQJtaIcyqPr0WZ0A7oRbUFb0TZUQDehNrQdtaMdqAN1opvRTrQL3YJuRbeh28Pqyf+f3MqwLhIOAlWdgyahc9F56Hy0HF2ApqEL0UXoYjQTzUJxdAlagRLoUjQfLUCLUBItRmeiM9BKNB0tRSlUi+rQZehylEZXoCkog65E9WgVakCz0Wp0AK1BV6HJ6GrUiK5Bf4rWonVoKroWNaH1KIua0Vy0Ac1DLSiGlqCN6Dq0CbWiHMqj61EE7UQ3oBvRDLQFbUXbUAHdhOagNvRf0Xa0ELWjHagDdaJb0M1oM9oVVk/+X1aCajCj/TUamx9lL+Hn2EP4Rz8927N+ImsCX2je/+ON+YO1luOTS1/5zq0vNO7/Om3hCg31/9V/99Cd4PMe94ZvFQo9fee0h+5Uno6zZdL403c2Vi6Qf01x8z06nO/R4VQ1CZ2LzkPno+XoAjQNXYguQhejmWgWiqNL0AqUQJei+WgBWoSSaDE6E52BVqLpaClKoVpUhy5Dl6M0ugJNQRl0JapHq1ADmo1WozXoKjQZXY0a0TVoLVqHpqJrURNaj7KoGc1FG9A81IJiaAnaiK5Dm1AryqE8uh5F0GZ0A7oRzUBb0Fa0DRXQTWgOakPb0ULUjnagDtSJbkY70S50S1g9+f/rmz0IP2698V+ChBUkpW82I3wl23xWlt94P1L60ncjBJ8LtO9LrWD+TeUiCs62QvALNeUXw8GXHiq/SEdK1dWQQ0ElMzUoUg4Gc/GG4FVf5dv/7/GH5G8I1ku+zx3Ov1a5c+khdCe6Cz2CHkWPoeXocXQ36kL7UDN6At2LVqAN6En0FNqP6tB96Dl0PzqKMqgbPY8eRPXoBbQKbUEvopdQD5qNGlAbOokOonb0MnoFHUZ70DJURHtRCt2BXkWvodfRG+hN9BZ6B72N3kXvoffRB+hD9BGahXajNWgmOoEOoRp0D3oAHUAPoyOohFrQ0+gZ9Cw6ho6jXjQJTUNz0UI0Hy1Ai9BiFEPTw+rJ/zG3VrbRX1R1CLWH1ZP/t59+/2d+WhCo1wdRPOhH3wxe/PAxzqnEmt8WfNPcKeEEMp7vT3/KYtDk/53gr/D/0LcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcOcl4N0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcO0rcOEksH6VsH6VsH6VsH6VsH6VsH6VsH6VsHq9H6/6VK7qJK7qJK7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIu7qIS7qL27aL27aLa7aLa7aLa7aLa7aK+7aK+7aK+7aK+7aK+7aK+7aK+7aK+7aK+7aK+7aK+7aKi7aKi7aKi7aKi7aKi7aKi7aKi7aKi7aKi7aKG7aKG7aKq66Ia7KL+66Li66Li66Li66KK7KKe7qIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KIa7KpWYKNclN/hovwOF2VVd6FH0KPoMbQcPY7uRl1oH2pGT6B70Qq0AT2JnkL7UR26Dz2H7kdHUQZ1o+fRg6gevYBWoS3oRfQS6kGzUQNqQyfRQdSOXkavoMNoD1qGimgvSqE70KvoNfQ6egO9id5C76C30bvoPfQ++gB9iD5Cs9ButAbNRCfQIVSD7kEPoAPoYXQElVALeho9g55Fx9Bx1IsmoWloLlqI5qMFaBFajGJoelg9+R9UAmcwYV0zORR96rg667g+6jjr6zjr6zjr6zjP6zjP6zhH6jgr6jgr6jgr6jgP6jhH6jjWdZx3dRzBOo5gHVdnHWdTHUe3jvOnjmNdx7Gu4wyt45ys47yr47yr47yrqx6lf/fV7WTv+rSp/De3MbT+BG9jGKtsS5gY2Fdm+G9FStWp/kORU0eZgX91qL+tMtT/95VvXxLcIfBw+VduD14cKAV9TE3r+uAL/oR5U3WffO1n7xb6zM/y2M+06TM+y+M/UKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNUKUNkAcGqNIGqNIGqNIGqNIGqNIGqNIGqNIGqNIGqNIGyEIDVGkDVGkDVGkD5KsB8tUA+WqAPDBA9hogew1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ1QpQ2QgQfIlgPk4wHy8QD5eIAMPEB2HiAHDpBXB8iIA2TuAbLsANlygGw5QLYcIMcPkOMHyOMDZO4BMvcAVdoAVdoAVdoAVdoAVdoAVdoAVdoAVdoAVdoAVdpANf//R25SOsho9CCjvIOMcKuKoqloGpqOZqCZaBaajeaguWgemo8WoIVoEToDnYkWoxhagpais9DZ6Bx0LjoPnY+WowvQhegidDGKo0vQCpRAl6IkWolSqBbVocvQ5SiNrkAZdCWqR6tQA1qN1qCr0NWoEV2D1qJ16FrUhNajLGpGG1AL2oiuQ5tQK8qhPLoebUY3oBvRFrQVbUMFdBNqQ9tRO9qBOlAnuhntRLvQMnQLuhXdhm4Pqyf/n8IBt/XXQ/G2iiVhRMK4NYwpYdwYxm1hTA1jWhgzwrg4jNvDmBXG7DDmhDE3jHlhzA9jQRgLw1gUxuIwzgzjjDBiYUwPY2kIPfn//Cldzz00O0H7c+L0rufZStfzX8Y/sPTKyr3ff1o5gEHv+1vjO7sfDvZqrwu6oT8rfVKj7ObErOoQSoXVU27fwk3MxZW7MR5Cd6K70CPoUfQYWo4eR3ejLrQPNaMn0L1oBdqAnkRPof2oDt2HnkP3o6Mog7rR8+hBVI9eQKvQFvQiegn1oNmoAbWhk+ggakcvo1fQYbQHLUNFtBel0B3oVfQaeh29gd5Eb6F30NvoXfQeeh99gD5EH6FZaDdag2aiE2g+WoAWocVoOqpBD6O5qIRa0NPoGXQMHUe9aBKahu5BD6AD6BA6gmLoWbQwrJ78n33uDd8//jRz9+eaZk7sFp/YG/4Z883Tt4R/xg7liYnnxFblYNf5ns+cgZ6+ZfmrmIqe9nDxv/CerM+Yk37GZufPMTCd2Hf+wyenE/vOP2OEOrEBfWKW+jl2ovfk//zUlunqubmEcdASRkxLGA4tqbbi/1/l218o/3Yrgj9gPNs2MTJsYqDXxKCzidFYE+PEJsZfTYy/mvi7NTGYa2LE1cS/qYl/RRNDrSaGWk0MhJoYATUxAmpiBNTECKiJEVATg50mhkxNjNuaGPo0MTpqYgTUxAioiRFQEyOgJkZATQygmhgINTEQamIg1MSoqql6Hvz/lXK1Mjv/De5wmDipg9H45VNKP8o0/fMM0WsiwQkYFLSlKaEfdCe1aid1bCc1bme1jp0Umai3/+6k0idldk9+csRK/NNXG1qPBl8biXxlK1MbvnnA1tdtZWpKJLzRuYNTroNTroNTrqN6ykUj4TFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmgjFmggFIgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmgqFmghMzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzwVAzQZBLMNRMMNRMMNRMMNRMMNRMMNRMMMZMMMZMMMZMMMZMVAPu1Ei41n2UsPYQgewhAstDBOOHCMYPEbYfIsQ+VP1jp/13BUQwuJvLKC8Y7rWePsqLVuqP6aSJKH9elL9ZlL9ZlDQRJU1ESRNR0kSUf0OUNBElTURJE1F+nlHSRJSfbpQ0ESVNREkTUdJElDQRJU1ESRNR0kSUoxklTURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDFESQ5TEECUxREkMURJDlMQQJTFESQxREkOUxBAlMURJDNFqhJ7x1bVtnd9sKPy6tW0zK0d7fMiUYZCUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYViUYZCUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUYXSUqY6OZlUOx/g/Zd+k8I98H1GzqjvC6snPjox/yMsPglMh+JCXhsphnkO1F+NQxjjoMQ5srPrXmhs59TCInw8WUOeFi7DW3w++fnIYkTCmhBENY2oY08KYHsaMMGaGMSuM2WHMCWNuGPPCmB/GgjAWhrEojDPCODOMxWHEwlgSxtIwzgrj7DDOCePcMM4L4/wwlodxQRgXhnFRGBeHEQ/jkjBWhJEI49IwkmGsDCMVRm0YdWFcFsblYaTDuCKMTBhXhlEfxqowGsJYHcaaMK4K4+owGsO4Joy1YawL49owmsJYH0Y2jOYwNoTREsbGMK4LY1MYrWHkwsiHcX0Ym8O4IYwbw9gSxtYwtoVRCOOmMNrC2B5Gexg7wugIozOMm8PYGcauMG4J49Ywbgvj9hB68vMrAfDJIIEH+XV8w8edLOZUdSd6BD2KHkPL0ePobtSF9qFm9AS6F61A+1Edeg7dj46iDHoePYjq0QtoFXoRvYR60GzUgE6ig6gdvYxeQYfRHrQMFVEK3YFmolloDTqBDqEa9DDajfaiI+geVEIt6Gn0DHoWPYCOoeOoFx0Iqye/oHIF7itfgb8TCZ3nq7kCV3Oer+bIr+bcWs2RX83xXM3xXM3xXM3xXM3xXM0RXM0RXM2xXs3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXM3xXF09ngspKf9W8BWTw1gSRiSMW8OYEsaNYdwWxtQwpoUxI4yLw7g9jFlhzA5jThhzw5gXxvwwFoSxMIxFYSwO48wwzggjFsb0MJaG0JNfVPmR/3z5EvprU0JJ7Be4hH6BJFbVXegR9Ch6DC1Hj6O7URfah5rRE+hetAJtQE+ip9B+VIfuQ8+h+9FRlEHd6Hn0IKpHL6BVaAt6Eb2EetBs1IDa0El0ELWjl9Er6DDag5ahItqLUugO9Cp6Db2O3kRvobfRu+g99AH6CL2B3kHvow/RTDQLrUEn0CFUg3aje9AD6AB6GB1BJdSCnkbPoGfRMXQc9YbVkz+jErX2lKPW1ZMqZ0xNvrcy4TiTlaEIK0MRVoYirAxFWBmKsDIUYWUowspQhJWhCCtDEVaGIqwMRVgZirAyFGFlKMLKUISVoQgrQxFWhiKsDEVYGYqwMhRhZSjCylCElaEIK0MRVoYirAxFWBmKsDIUYWUowspQhJWhCCtDEVaGIqwMRVgZirAyFGFlKMLKUISVoQgrQxFWhiKsDEVYGYqwMhRhZSjCylCElaEIK0MRVoYirAxFWBmKsDIUYWUowspQhJWhCCtDEVaGIqwMRVgZirAyFGFlKMLKUISVoQgrQxFWhiKsDEVYGYow44ywMhRhZSjCylCElaEIK0MRVoYirAxFWBmKsDIUYWUowspQhJWhCCtDEVaGIqwMRVgZirAyFGFlKMLKUISVoQgrQxFWhiKsDEVYGYqwMhRhZSjCylCElaFIdbq8OHLqPprHK/fRxD5Zyp8yvhxU3SW4pBKLny+7O7ixZnfwJVcG4Xq8lGumlGum0GqmAG2mZGmmzGumLGmmLGmmLGmmfGqmfGqmEGmmEGmmEGmm9Gim9GgmUTeTqJtJ6c2k7WbSdjNpu5n020wSb6YoaiY1N5Pgm0nUzSTqZhJ1M4m6mUTdTJnQTNpuJm03k7abKSiaq0l8aeX8GM8YvWSMXjJGLxmjl4zRS8boJWP0kjF6yRi9ZIxeMkYvGaOXjNFLxuglO/eSnXvJx73kll4ycC/ZuZfM3Uu90Us+7iXv9JJNeqlvesktveSWXrJJL/mjl/zRS1ao6k/RVNSE1qO5aANqQUvQdWgTyqMtaCsqoHa0A3WiXegsdDaahKahmWgWWolSqBZdhi5HaVSPGtBsdABdhSajq1EjWovWoWtRFjWjeSiGNqJWlEPXowjajG5AN6IZaBu6Cc1Bbei/ou1oIepAt6Cb0c6w8md52t2GbkfLUBTdGlZPflnk02/MOn1XyFf/SRwTmz9O/0iOH5T/hELp6/mJHD99H8QxvjNnfKfO1/KDOL7kz9/40j5246zKFTMeC44Rz46R1Y4Rl46RtY8Rd48RiY6RH45VL9SzK39sMA7ZHPzFggHJsqD2XhbU3o9UPoDsnIkvWXXqJvrWZ4P3zy2/Xz4eP4t3YP6s3XgZRNdZk0tf3zswz6+chv81OHuDT6a5Izh7v1v9kurpPkKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMEKzMELYGaFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGKFZGCGsjtAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjNAsjJAMRmgWRmgWRmgWRmgWRmgWRmgWRmgWRmgWRmgWRkhaIzQLIzQLIzQLIzQLIzQLIzQLIzQLIyTXEZqFEZqFEZqFEZqFEZqFEZLyCM3CCM3CCM3CCCl6hGZhhGZhhGZhhGZhhPZghPZghPZghPZghPZghPZgpFogLGd95DCH6jAX0GF+BIdpCw4TLg7zIzhM43GYC/0wp/dhfliHCbiHaVgOc+of5lQ8zA/yMOHiMKfGYcLvYcLvYX7IhwnGhwm/hwm/hwm/hzn5DhOMDxOMD1cPxwWMwNZGwlmtqvPQ+Wg5ugBdiC5CF6M4ugStQAl0KZqPFqBFKIkWozPRGWg6Worq0BVoCsqgK9EqtBqtQdegqagJrUdz0QbUgpag69AmlEdb0FZUQO1oB+pEu9BZ6Gw0CU1DM9EstBKlUC26DF2O0qgeNaDZ6Co0GV2NGtFatA5di7KoGc1DMbQRtaIcuh5F0E50A7oRzUDb0E1oDmpD29FC1IFuQTejzWH1lNuvr+yGpM/XkZ7eiAa9Vjr4kh/pFqXTG9Gf0XuVPk8DeXrf+Cnt4kUUNWdR1JxFGXMWhUtVUTQVTUPT0Qw0E81Cs9EcNBfNQ/PRArQQLUJnoDPRYhRDS9BSdBY6G52DzkXnofPRcnQBuhBdhC5GcXQJWoES6FKURCtRCtWiOnQZuhyl0RUog65E9WgVakCr0Rp0FboaNaJr0Fq0Dl2LmtB6lEXNaANqQRvRdWgTakU5lEfXo83oBnQj2oK2om2ogG5CbWg7akc7UAfqRDejnWgXWoZuQbei29DtYfXkL64E3N859ebPVdL176KPUSqsnnyceJ0jXueI1znidY54nSNe54jXOeJ1jnidI17niNc54nWOeJ0jXueI1znidY54nSNe54jXOeJ1jnidI17niNc54nWOeJ3jSOeI3jmid47onSN654jeOaJ3juidI3rniN45oneO6J0jeueI3jmid47onSN654jeOaJ3juidI3rniN45oneO6J0jeueI3jmid47onSN654jeOaJ3juidI3rniN45oneO6J0jeueI3jmid47onSN654jeOaJ3juidI3rniN45oneO6J0jeueI3jmid47onSN654jeOaJ3juidI3rniN45oneO6J0jeueI3jmid47onSN654jeOaJ3juidI3rniN454nWOeJ0jXueI17lqvL4kEv7w5t8kCPwmQaCqSehcdB46Hy1HF6Bp6EJ0EboYzUSzUBxdglagBLoUzUcL0CKURIvRmegMtBJNR0tRCtWiOnQZuhyl0RVoCsqgK1E9WoUa0Gy0Gq1BV6HJ6GrUiK5Ba9E6NBVdi5rQepRFzWgu2oDmoRYUQ0vQRnQd2oRaUQ7l0fUogjajG9CNaAbagraibaiAbkJzUBvajhaidrQDdaBOdDPaiXahW8Lqya849YiMmnwkeOjY4mDp+d9MKlU3Svwg+IoE1et+TuT9HOj9HIb9RO39XIz7OQz7iej7Oa33E0z3c8D2Ez73kwn2Ez73c9nu5xDt55Tfz0m+n4C5n4C5n8O3n/C5n4C5n4C5n4C5nwtnPwFzPwFzf/WAXcrhOJfDcS4H4Fx+5FVF0VQ0DU1HM9BMNAvNRnPQXDQPzUcL0EK0CJ2BzkSLUQwtQUvRWehsdA46F52HzkfL0QXoQnQRuhjF0SVoBUqgS1ESrUQpVIvq0GXocpRGV6AMuhLVo1WoAa1Ga9BV6GrUiK5Ba9E6dC1qQutRFjWjDagFbUTXoU2oFeVQHl2PNqMb0I1oC9qKtqECugm1oe2oHe1AHagT3Yx2ol1oGboF3YpuQ7eH1ZNPVgLuyXJe/OtTQsezgRt2GrhFp4FbbRq4KaeBG28auPGmgRtvGrjxpoEbbxq48aaBG28auPGmgRtvGrjVpoHbcBq48aaBG28auEmmgZtkGrgpp4FbZhq4ZaaBG3YauIGmgRtoGriZp4HbaRq4taeBW3sauLWnoXrjzcrKLVtrg9Lm0ESRs3dyqbpQtm58DS0y/iFLGyobR1Mk2gyJNkOizZBoMyTaDIk2Q6LNkGgzJNoMiTZDos2QaDMk2gyJNkOizZBoMyTaDIk2Q6LNkGgzJNoMiTZDos2QaDMk2gyXaIa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh7WZIuxnSboa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh7WZIuxnSboa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh7WZIuxnSboa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh7WZIuxnSboa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh7WZIuxnSboa0myHtZki7GdJuhrSbIe1mSLsZ0m6GtJsh0WZItBkSbYZEm6km2tpKwJ1fDsCvT6lEppr8v59UCUo1+X82uVR9sGM+WBz/zfKLW4IXv1p+8UBlTbzum538PwM7+b/QBv7gNoALJpW+0p38l1VOw+Dx7r88/lT3b4Wf8159qvvf4EHvE4+F78lfXvn28aJyayRcKm7l49Oq2o2KaC86gmaifagZzUL3oHvRHaiElqEW9DRKoTr0DHoWPYCOoRfQcbQK9aIedAKdRAfQGnQQHULtqCasnnx6/PGzbcFzB66onBqnfahSflpw9qwPTq1twasPq0+1qsm/GSl9ygctTVwME2FmPJ4FEeTvhK6s0z55qSefoSKOUxHHqYjjVMRxKuI4FXGcijhORRynIo5TEcepiONUxHEq4jgVcZyKOE5FHKcijlMRx6mI41TEcSriOBVxnIo4TkUcpyKOUxHHqYjjVMRxKuI4FXGcijhORRynIo5TEcepiONUxHEq4jgVcZyKOE5FHKcijlMRx6mI41TEcSriOBVxnIo4TkUcpyKOUxHHqYjjVMRxKuI4FXGcijhORRynIo5TEcepiONUxHEq4jgVcZyKOE5FHKcijlMRx6mI41TEcSriOBVxnIo4TkUcpyKOUxHHqYjjVMRxKuI4FXGcijhORRynIo5TEcepiONUxHEq4jgVcZyKOE5FHKcijlMRx6mI41TEcSriOBVxnIo4TkUcpyKOUxHHqYjj1Yr4yi9wH/oPyi8e/B98Q/o3N6J/cyP6T/hG9PpI+MPI9zOkrepO9Ah6FD2GlqPH0d2oC+1DzegJdC9agZ5E+1Edeg7dj46iDHoePYjq0QtoFdqCXkQvoR40GzWgk+ggakcvo1fQYbQHLUNFlEJ3oJloFlqDTqBDqAbtRnvRPegBdAA9jI6gEmpBT6Nn0LPoGDqOesPqKV/i4Y9bqeXA1XI4ajkctRyAWg5OLYejlgNQywGo5VDVcjhqORy1HI5afpC1HJxaDk4tP+RaDlUtP/JafuS1/Mhr+ZHX8iOv5YDXcgBqOQC1HIBaTo3a6uFooI9L08el6ePS9HFp+rg0fVyaPi5NH5emj0vTx6Xp49L0cWn6uDR9XJo+Lk0fl6aPS9PHpenj0vRxafq4NH1cmj4uTR+Xpo9L08el6ePS9HFp+rg0fVyaPi5NH5emj0vTx6Xp49L0cWn6uDR9XJo+Lk0fl6aPS9PHpenj0vRxafq4NH1cmj4uTR+Xpo9L08el6ePS9HFp+rg0fVyaPi5NH5emj0vTx6Xp49L0cWn6uDR9XJo+Lk0fl6aPS9PHpenj0vRxafq4NH1cmj4uTR+Xpo9L08el6ePS9HFp+rg0fVyaPi5NH5emj0vTx6Xp49L0cWn6uDR9XJo+Lk0fl6aPS9PHpenj0vRxafq4NH1cmj4uTR+Xpo9L08el6ePS1T5u9anPbai+2UIh2EIJ10LB2kKh1EKR2EJp1EJp1EKGbaG8a6Foa6GgayEXt5CLW8i+LWTmFnJxC7m4hezbQmZuIRe3kItbyMUt5OIWcnELubiFXNxCLm4hF7eQi1vIxS3k4hZycQu5uIVc3EIubiEXt5CLW6q5eE0w5B3/OT4RnC7d+avoYX6fU6KqO9Fd6BH0KHoMLUePo7tRF9qHmtET6F60Am1AT6Kn0H5Uh+5Dz6H70VGUQd3oefQgqkcvoFVoC3oRvYR60GzUgNrQSXQQtaOX0SvoMNqDlqEi2otS6A70KnoNvY7eQG+it9A76G30LnoPvY8+QB+ij9AstButQTPRCXQI1aB70APoAHoYHUEl1IKeRs+gZ9ExdBz1okloGpqLFqL5aAFahBajGJoeVk/+6krgHC+vp1cW1c5B56K16Hy0Dl2AlqOLUBNaj5pRHF2CLkUbUBJtRJtQCtWiOpRGrWgpyqGdqB5tQVvRNlRAN6E21IE60VVoM7oa7UKNYfXkG8m+o2TfUbLvKNl3lOw7SvYdJfuOkn1Hyb6jZN9Rsu8o2XeU7DtK9h0l+46SfUfJvqNk31Gy7yjZd5TsO0r2HSX7jpJ9R8m+o2TfUbLvKNl3lOw7SvYdJfuOkn1Hyb6jZN9Rsu8o2XeU7DtK9h0l+46SfUfJvqNk31Gy7yjZd5TsO0r2HSX7jpJ9R8m+o2TfUbLvKNl3lOw7SvYdJfuOkn1Hyb6jZN9Rsu8o2XeU7DtK9h0l+46SfUfJvqNk31Gy7yjZd5TsO0r2HSX7jpJ9R8m+o2TfUbLvKNl3lOw7SvYdJfuOkn1Hyb6jZN9Rsu8o2XeU7DtK9h0l+46SfUfJvqNk31Gy7yjZd5TsO0r2HSX7jlaz7zXcdfttRl3fZtRV1SR0LjoPnY+WowvQNHQhughdjGaiWSiOLkErUAJdiuajBWgRSqLF6Ex0BlqJpqOlKIVqUR26DF2O0ugKNAVl0JWoHq1CDWg2Wo3WoKvQZHQ1akTXoLVoHZqKrkVNaD3KomY0F21A81ALiqElaCO6Dm1CrSiH8uh6FEGb0Q3oRjQDbUFb0TZUQDehOagNbUcLUTvagTpQJ7oZ7US70C1h9eTXUmN+jxrze9SY36PG/B415veoMb9Hjfk9asyqHn95Ss2kmuA/3r4bdaF9qBk9ge5FK9AG9CR6Cu1Hdeg+9By6Hx1FGdSNnkcPonr0AlqFtqAX0UuoB81GDagNnUQHUTt6Gb2CDqM9aBkqor0ohe5Ar6LX0OvoDfQmegu9g95G76L30PvoA/Qh+gjNQrvRGjQTnUCHkFfcPegBdAA9jI6gEmpBT6Nn0LPoGDqOetEkNA3NRQvRfLQALUKLUQxND6snv+5LfTxmsBPut4ONRBPb5/7C2zw+46aOz7iX42f9GZif59GXn3JbxbXky4/Jlx+TLz8mX35MvvyYfPkx+fJj8mVVj6O7URfah5rRE+hetAJtQE+ip9B+VIfuQ8+h+9FRlEHd6Hn0IKpHL6BVaAt6Eb2EetBs1IDa0El0ELWjl9Er6DDag5ahItqLUugO9Cp6Db2O3kBvorfQO+ht9C56D72PPkAfoo/QLLQbrUEz0Ql0CNWge9AD6AB6GB1BJdSCnkbPoGfRMXQc9aJJaBqaixai+WgBWoQWoxiaHlZPvokVkSgrIlFWRKKsiERZEYmyIhJlRSTKikiUFZEoKyJRVkSirIhEWRGJsiISZUUkyopIlBWRKCsiUVZEoqyIRFkRibIiEmVFJMqKSJQVkSgrIlFWRKKsiERZEYmyIhJlRSTKikiUFZEoKyJRVkSirIhEWRGJsiISZUUkyopIlBWRaHVFZH3lJBq/wr9PHPw+18r3uVa+zzX9/eoZmWXz4XlMaM5jonAek6SqomgqmoamoxloJpqFZqM5aC6ah+ajBWghWoTOQGeixSiGlqCl6Cx0NjoHnYvOQ+ej5egCdCG6CF2M4ugStAIl0KUoiVaiFKpFdegydDlKoytQBl2J6tEq1IBWozXoKnQ1akTXoLVoHboWNaH1KIua0QbUgjai69Am1IpyKI+uR5vRDehGtAVtRdtQAd2E2tB21I52oA7UiW5GO9EutAzdgm5Ft6Hbw+rJN1MCXDw5HASqOhetReejdWg5ugBdhJrQetSM4ugStAJdijagJFqJNqIUqkWbUB1Ko1a0FOXQ9Wgnqkdb0Fa0DRXQTagBtaEdqAN1oqvQzWgzuhrtQo1h9eQ3VE7M8ex7hFvnj/CYgiM87OAIj0U4Uq1RWiq/WXC3/OrKpVPTujl4e+PX6rEgrZNKn++xIF/y00B+Mg8B+To9++MLPvLjU0ZS13FPU5oRQ5rBQZqCOc3gIE0QSjMqSNNmp2ms0zTWaRrrNGV3mjY7TbucpnVPM8RI00qnacjTNNZpGus0jXWaxjpNs5CmrU/TOqRps9O02WkGAOlqMNn0JX1kd/6fTyr9uLdIB090+c/Bt/9Y90p/8iSPL/mu6fzW4DeOfmn3Twd3lk8P3vlRbqQObkd+LVL6su6orj7sZM6PfG/1xJNRdpdfLAq++Me52/q+8oslwTun33b9F99tnd8T/NUvDL79p/6+673lF5cE73xyA3Yr/X2S/j5Jf5+kv0/S3yfp75P090n6+yT9fZL+Pkl/n6S/T9LfJ+nvk/T3Sfr7JP19kv4+SX+fpL9P0t8n6e+T9PdJ+vsk/X2SziBJt5+k20/S7Sfp9pN0+0m6/STdfpJuP0m3n6TbT9LtJ+n2k3T7Sbr9JN1+km4/SbefpNtP0u0n6faTdPtJuv0k3X6Sbj9Jt5+k20/S7Sfp9pN0+0m6/STdfpJuP0m3n6TbT9LtJ+n2k3T7Sbr9JN1+km4/SbefpNtP0u0n6faTdPtJuv0k3X6Sbj9Jt5+k20/S7Sfp9pN0+0m6/STdfpJuP0m3n6TbT9LtJ+n2k3T7Sbr9JN1+km4/SbefpNtP0u0n6faTdPtJ+vsk/X2S/j5Jf5+s9vc5tl0umBwOAgvo9hewPrGA3r+q89D5aDm6AE1DF6KL0MVoJpqF4ugStAIl0KVoPlqAFqEkWozORGeglWg6WopSqBbVocvQ5SiNrkBTUAZdierRKtSAZqPVaA26Ck1GV6NGdA1ai9ahqeha1ITWoyxqRnPRBjQPtaAYWoI2ouvQJtSKciiPrkcRtBndgG5EM9AWtBVtQwV0E5qD2tB2tBC1ox2oA3Wim9FOtAvdElZPPv9DnqE4PajIl4WbkokO7I7yG79bClXDQSNzXXjic9qDEj9pGE41Pz3564O7fD8uv/3klOAG382Vv8eyoHGJhOLCf6gG9BvY7PJPK/+Qh9Cd6C70CHoUPYaWo8fR3agL7UPN6Al0L1qBNqAn0VNoP6pD96Hn0P3oKMqgbvQ8ehDVoxfQKrQFvYheQj1oNmpAbegkOoja0cvoFXQY7UHLUBHtRSl0B3oVvYZeR2+gN9Fb6B30NnoXvYfeRx+gD9FHaBbajdagmegEOoRq0D3oAXQAPYyOoBJqQU+jZ9Cz6Bg6jnrRJDQNzUUL0Xy0AC1Ci1EMTQ+rJ38jlfCf0A7/Ce1wVZPQueg8dD5aji5A09CF6CJ0MZqJZqE4ugStQAl0KZqPFqBFKIkWozPRGWglmo6WohSqRXXoMnQ5SqMr0BSUQVeierQKNaDZaDVag65Ck9HVqBFdg9aidWgquhY1ofUoi5rRXLQBzUMtKIaWoI3oOrQJtaIcyqPrUQRtRjegG9EMtAVtRdtQAd2E5qA2tB0tRO1oB+pAnehmtBPtQreE1ZPf8umVcGXl8KrSj/Tg8M94YPjWiUXZf1f65Bn4E0++D56T3/pvTz0Uv/Xf+Cj8bcyRr+VCupYDfy0XfFVRNBVNQ9PRDDQTzUKz0Rw0F81D89ECtBAtQmegM9FiFENL0FK0DJ2FzkbnoHPReeh8tBxdgC5EF6GLURxdglagBLoUJdFKlEK1qA5dhi5HaXQFyqArUT1ahRrQarQGXYWuRo3oGrQWrUPXoia0HmVRM9qAWtBGdB3ahFpRDuXR9WgzugHdiLagrWgbKqCbUBvajtrRDtSBOtHNaCfahW5Bt6Lb0O1h9ZRD86ffUTWxpt5XfvELUyoh7NRH9PxC+cW3ppRCH9GzqvxiS/AiCOT/KHjxX8ov7gtesKZ+/+TSZy6ln1l+8R8nV07AmvyJyaXQUvrq8ot3J1eiXk1+x5RK6K/JfxypROia/M8Hv9QfrCmzSWZOOcOcLIWeTP5Xym+8UAot/k+stZ++xD69/LWDpU9W1k8to+cvCP6VvxR8z+kL6eMr9vkLgy/61uRKWqhpvaty2dbkvzO59Mka+y+V3/jupEqQr2ltLP//l8tvZCZV4mBN/o7gS09fhp/4fKR8+Zvml/+gi4IsuqwUWpefWI6/sPwrZ5dCy/ITK/ZnlX/lokrgrGlNlT7lwed/vfzGzaVPKoLryv9vLYWW7b9dfnEgmKJdHPz5W8rvDJb//59Kn++B6MEnOGUjpdAS/XfKL74dvDO+oSEfD37jraWJtfr8JcEbO8pv/Er5S56fXInKNa23lkLVycRmgvFF+/yK4Ju6Ktd8Tb4j+JN+PVh+51np15S/ZF8pKBFq8r8WfMnpj0ifWKK/ovy1B0ufLNVfXv7/z5VCO0Um1u5PW7Of2C0wsRtkYn/IqeX8fCL42z5WCq3rBx96dfenL/BfWf7ap0uh9f3t5Td6y/8fKr8xO/htZ5bfeLf8214a/Lbvl9/4q+X//0L5jVzwxi+XPtmnNjEUTQa/8p3SJ6VffmXwzm+UQh/ENbEj4LvlF9uDzQ1Tgq85s/zO3w4utPCz2T9rB87k8ot/EPw+N5S/e7gU5Iia1t8phXbS/GL5jftLoYJ0avmNv1+a2P6Srw3+4H9aCm17SQXv/IvSJ7tdBsr//8PyL0SCX/jXpdBml0j5xR8Hv+uS8otdwV/kB+Uv+X4pKG5qWkfL//9W+f9vl7+3LvjePy2FNqn8jfIb55SCgrAm/9vBn3tZ8CV/XgrtQ5nYmTKxIWVRcP0FP5RfK7+YHrz44ftPgg+Rmhy8yJRfTAvvAcxfHsSWBcFb4/tOZpTfGAn+hPENKPl08DVnBl8zsRVlfLvJyvIb5wS/cmp3Sf6K4GsvCd75jfKLseDbM8FblwZvTWwj+ZvlF/vZRpItv6gNLrIrg69eE3z1vPKLfxn8OOqDt64J3jp9s8lfK7+4NvilieZhYmvJbwW/UWVHyU3Mw3/APPwHzMN/wDz8B8zDf/Df2LvzAKnO9D7UbFOFKESzSCBQC1WVSk0vglLRGsSwNCVQURRQgBCLEJv20TYSkmg1mtGGJFpC+wLa0C45OI6TOG07m7NM7Nhujef6xpOu5HbHd5zYN3G2S/qmb0wcGzt1utSl7xnNgmY0M8iD/uE8vQHinPe87+/7ThV5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+CB5+GAtD996Sm1+/x7vifnJ3v/0m2P+5DbIR13832W354/xzTGvGj4fR4K6xwjOHiN+e4zg7DHCv8eItR4jCnyMMOex2mC7jQegzh++Us5Ds9EylER5lEJplEHL0QpUQE1oDmpGrWglakMXoVVoLpqHVqMsmo/WoJloLVqHdqEFaCO6Em1Cm9EWtBBtRVej7WgHWox2ovVoCdqNlobqLF990vX5+z+z8Fm8q9snH1CoF93T7+r2Wbyr23feI6MB89Hu0+/utubTvLvbdkp5E6W8iVLeRClvopQ3UcqbKOVNlPImSnkTpbyJUt5EKW+ilDdRypso5U2U8iZKeROlvIlS3kQpb6KUN1HKmyjlTZTyJkp5E6W8iVLeRClvopQ3UcqbKOVNlPImSnkTpbyJUt5EKW+ilDdRypso5U2U8iZKeROlvIlS3kQpb6KUN1HKmyjlTbVSvqO+o+9bI08X/cHwGbuTZcx9dDL76GT20cnsI77fxxLnPpYu9hHt72PBcx8Lnvvosfax0LaPJYF9LHjuY8FzH33bPhY899G37WPBcx8LnvtY8NzHguc+FjX3seC5j8XQfSx47mNBdx8LnvtqveAuXsrkvwz/U85Co9BB9HSozvLuj5a3hz+45g+DS3AYneVr+MefxT/+LP65Z/EPXNMXUAzF0Xh0BpqAEmgiOhNNQg1oMpqCpqJp6Cx0NpqOZqBz0Ex0LmpE56HZ6HyURCmURhegDLoQNaE5qBm1oFbUhi5Cc9E8lEUXoxyaj9rRJeiLaAG6FC1EX0KL0GK0BC1FHWgZyqPL0HK0Al2OCmglKqJVqIRWozVoLSqjdWg92oCuQBvRlWgT2oy2oK3oKrQNXY22ox1oJ9qFdqNZ6Bp0LboOXR+qs3xtVHBr24ny3cGOo2gL0sXd37Hz6B+44ei6z/IVRWuPFFwXfYi47JfCnVM/+LVFP3r6YHjFqvxL0Zd8mteKKO+Kvu1PSMdGRrePF+p+0AuQ1se0+hwxMq99Yp446RcgHVnn/ty9EOn10YMcUXe3YWz0IMcNvITJ748Jy9vv01zUNCFUZ/nG73HKRWdKA0nADxfQ/qRfxPbjk+rkT6bvCFZrp/qvj/nZOq1u+oxeveKzSII+zWtWnJJJUJSs/I/uUz8R+mFeeeJ0EvRREvTlz+kVU94S1bfC6FP02jmZayZ6DZXnx56+eD4nF0/0cj272Frz8VV08/BVNLLJ4cnhF1Z7At2NutF+dHuozvItRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUtRLUttab7VkK5JKFcklAuSSiXJJRLEsolCeWShHJJQrkkoVySUC5JKJcklEsSyiUJ5ZKEcklCuSShXJJQLkkolySUSxLKJQnlkoRySUK5JKFcklAuSSiXJJRLEsolCeWShHJJQrkkoVySUC5JKJcklEsSyiUJ5ZKEcklCuSShXJJQLkkolySUSxLKJQnlkoRySUK5JKFcklAuSSiXJJRLEsolCeWShHJJQrkkoVySUC5JKJcklEsSyiUJ5ZKEcklCuSShXJJQLkkolySUSxLKJQnlkoRySUK5JKFcklAuSSiXJJRLEsolCeWShHJJQrkkoVySUC5JKJcklEsSyiUJ5ZKEcklCuSShXJJQLkkolySUSxLKJQnlkoRySUK5JKFcklAuWQvlbvtM36qHOO33fhopx6nxVj1RDzgQdXM/WqbxmUcZt3N7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXN7zXNh5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rnZ5rm95rm95rm95rm95mu3168MF9z6UjCrDjVtQw+F6izfMbxkVl8HG14qe7H7uzytX1tW++Xu2uLZjdH33hnW+jXfCkp9DWNDjAvxhRCxEPEQ40OcEWJCiESIiSHODDEpREOIySGmhJgaYlqIs0KcHWJ6iBkhzgkxM8S5IRpDnBdidojzQyRDpEKkQ1wQIhPiwhBNIeaEaA7REqI1RFuIi0LMDTEvRDbExSFyIeaHaA9xSYgvhlgQ4tIQC0N8KcSiEItDLAmxNERHiGUh8iEuC7E8xIoQl4cohFgZohhiVYhSiNUh1oRYG6IcYl2I9SE2hLgixMYQV4bYFGJziC0htoa4KsS2EFeH2B5iR4idIXaF2B3imhDXhrguxPUBOst7eDRx33B9/Rr6MroZPYAeRA+jFHoE3YpuQ19BBfQougM1o5XoMXQA3YmyaA96Et2FnkKXoHvQM2gvWoCeRZeijegF9CLqRBPRQrQVHUJdaBs6jF5G96Gb0Cz0ELoFzUU3olfQq+g1dAS9gd5Eb6N30HvoA/Q6egu9i95HCXQDWoQmoJfQPjQK3Y7uRvei+9F+1I2K6HH0BDqInkbPoefRaBRHk9BUNBlNQdPQdDQDjQ/VWb7re7z+1Pd+3amRlCdasrs1+sxvVg8mRN/8g1+Adc1vV39NRL/v3ez/PXNseOnU9Bx6PlRn+Z7Px6pztOT3R6cf3Tm91nwKbNTYO3zJjBTQbaQ2Ne1D20J1ljuHvz16n5E/HhN857nc9M7lRnout8BzawXn3uGfUy8e9b9M/R/5JF7xrlpFyifC1+qo/w8YOTs/fum7Lpa/N/DGuxt4490NvPHuBt54dwNvvLuBt9rdwNvwbuCNdzfwxrsbeOPdDbzx7gbeeHcDb7xbUzNqRStRG7oIrUJz0Ty0GmXRfLQGzURr0Tq0Cy1AG9GVaBPajLaghWgruhptRzvQYrQTrUdL0G60NFRneR/5fIl8vkQ+XyKfL5HPl8jnS+TzJfL5Evl8iXy+RD5fIp8vkc+XyOdL5PMl8vkS+XyJfL5EPl8iny+Rz5fI50vk8yXy+RL5fIl8vkQ+XyKfL5HPl8jnS+TzJfL5Evl8iXy+RD5fIp8vkc+XyOdL5PMl8vkS+XyJfL5EPl8iny9R6Uvk8yXy+RL5fIl8vkQ+XyKfL5HPl8jnS+TzJfL5Evl8iXy+RD5fIp8vkc+XyOdL5PMl8vkS+XyJfL5EPl8iny+Rz5fI50vk8yXy+RL5fIl8vkQ+XyKfL5HPl8jnS+TzJfL5Evl8iXy+RD5fIp8vkc+XyOdL5PMl8vkS+XyJrqFEPl8iny+Rz5fI50vk8yXy+RL5fIl8vkQ+XyKfL9U6mPs+ejT0ow/yxqalWk3+6nAG/+UoX/+T4YI4ak3v8FeNKv/iuO7aCwZeFT20MSOK6Yuju2vvcDoh+t6vRU8kRKH9P4seSLh/+Cetir7s18Z214aOn/+o3V+ztjvKT0aV74g+cHPUWUc/c3X0xX89OipFR38cffJA9eBb0UHUz/7ucB/3wOkXK/jZmXi+c0vF6Ynn++2u/ZffY/R5MHw+uDyK9G0UA8woRpZRJFejagPMQ6dfnvX0y7OefnnWv5Ivz/qJl2X98b8a6/Cro5bT0Yd+wq/LevrlWD/PL8da74M/ZJL/sNbrPjx8k4r61j8caVL/Mvr4ftZJB1gnHWCddIB10gHWSQdYJx1gnXSAddIB1kkHWCcdYJ10gHXSAdZJB1gnHWCddIB10gHWSQdYJx1gnXSAddIB1kkHWCcdYJ10gHXSAdZJB1gnHWCddIB10gHWSQdYJx1gnXSAddIB1kkHWCcdYJ10gHXSAdZJB1gnHWCddIB10gHWSQeIdwdYJx1gnXSAddIB1kkH6LgG6LgGWCcdoFMbYJ10gHXSAdZJB1gnHWAVc4BV0wFWTQdY4RxgDXWANdQB1lAHWAsdYEV1gJXRAdZXB1gnHaDbHGCddIB10gHWSQdYJx1gnXSAddIB1kkHWCcdYJ10gHXSAdZJB1gnHWCddIB10gHWSQdYJx1gnXSAddIB1kkHWCcdYJ10gHXSAdZJB1gnHWCddIB10gHWSQdYJx2odf2PnPTUHQ0iU6JPnR6/T4/fPzPj93eZuh/9OEzb2/1xmPZdMrTo1VV+tfvje8IfUO3+oHYFPjZ8BQ6fvARqe6ILJerIhsO2b0efi1Ypu8aOBGl7og9FQdqvRAdR7jY0diRu+3r0oSiB+62x3WHIdmD4NxvpFdawerSmlhV2D//1NkY/5T9E33xb9eDi6H/FC9WDpujg4epf64bu6JY8qpyMPvBo9eDc6GBv1LFGB3dVD8ZFBw9UD05Ef537on+r6ODl6sG/Gx39To9HyWJ0TjaOjqLFJ37Alo3o6ZjD3T/qW4YdZHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqDpraD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpDpanOlie6mB5qoPlqQ6WpzpYnupgeaqD5akOlqc6WJ7qYHmqg+WpjtrI/uTpdZ3PY2M5/Koe0f3/dIf5E+8wn2JL226u8Jr2obmhOstP8+3X8+3X8+3X8+3X1779GbK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PqbLPrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0PrK0vtok/+xw4RwZaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYaXoYJnsYJnsYH3sYfnoYGHsYJnsYNHsYj3sYH3sYjHoYd2oahy5BX0SXoi+hRagDxdBytAJNQitREZ2DSmg1KqON6Eq0GW1DV6MdaDc6FzWi0SiOJqAEugjNRfPQxSiH5qMFaCGaiBajMWgJWoqWoTy6DF2OCqgBzUCr0Bq0Fq1DY9EutAFdgc5Am9AWdCbaiq5CU9F2dA3aidaj/xWqs/zcSBA4ezgIfP5TrUkcPD06nmKj4+mJ8Sc+Mb7AzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNbLzNZbm9le/Oh57WqdHxPUxf1cO/upG/upRfupPvupDftrv8dLI09QrIu6m0M/6Tw8apIejf5yp7ub093N57K7OTzy5ndr5gWV9D/Wrq6XecWFb3MT+jbl9dvcrr5NQf127Ye9cnqx6vQ1+Xm9JqNC//ron/TF+Wr9BRSejD7xc9WDvx39uJFh5CjDyFGaoaOMJkcZTY4ymhxlNDnKaHKU0eQoo8lRRpOjjCZHGU2OMpocZTQ5yjBylAbgKMPIUdqBo1Sjo4wmRxlNjtJiHGU0OcpocpTR5CijyVHaj6OMJkcZTY4ymhxlNDnKaHKU0eQoo8lRRpOjjCZHGU2OMpocpb06ymhylNHkKMPIUYaRowwjR2m6j9JmH6XWH63V+teYmT/kNP2QE/NDTswPOTE/5MT8kBPzQ07MDzkxP+TE/JAT80NOzA85MT/kxKzpDtSMVqLH0AF0J8qiPehJdBd6Cl2C7kHPoL1oAXoWXYo2ohfQi6gTTUQL0VZ0CHWhbegwehndh25Cs9BD6BY0F92IXkGvotfQ6+gIegO9hd5Eb6N30LvoPfQ++gAl0A1oEZqAXkL70Ch0O7ob3YvuR/tRNyqix9ET6CB6Gj2HnkejURxNQlPRZDQFTUPT0Qw0PlRn+fXTTfLpJvnz2iT/BHrj6FnSl7vDHvnI6Svm9BXzs37FROPpX+Ph3+83Vr7BcxorWMxfwbL4CjaG1PQFFENxNB6dgSagBJqIzkSTUAOajKagqWgaOgudjaajGegcNBPNQueiRnQemo3OR0mUQml0AcqgC1ETmoOaUQtqRW3oIjQXzUNZdDHKofmoHV2CvogWoEvRQvQltAgtRkvQUtSBlqE8ugwtRyvQ5aiAVqIiWoVKaDVag9aiMlqH1qMN6Aq0EV2JNqHNaAvaiq5C29DVaDvagXaiXWg3ugZdi65D14fqLL9JwU1RcFMU3BQFN0XBTVFwUxTcFAU3RcFNUXBTFNwUBTdFwU1RcFMU3BQFN0XBTVFwUxTcFAU3RcFNUXBTFNwUBTdFwU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJTlNgUJTZFiU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJTlNgUJTZFiU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJTlNgUJTZFiU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJTlNgUJTZFiU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJTlNgUJTZFiU1RYlOU2BQlNkWJTVFiU5TYFCU2RYlNUWJrmoWuQdei69D1oTrLb42sapYfjJrhkbDr39dClrcpxwXKcYFyXKAcFyjHBcpxgXJcoBwXKMcFynGBclygHBcoxwXKcYFyXKAcFyjHBcpxgXJcoBwXKMcFynGBclygHBcoxwX+IQsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcCxblAcS5QnAsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcCxblAcS5QnAsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcCxblAcS5QnAsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcCxblAcS5QnAsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcCxblAcS5QnAsU5wLFuUBxLlCcCxTnAsW5QHEuUJwLFOcC5bhAOS5QjguU40KtHL/DW9UfYgHiEMuBh1gOPMQyzSGW/A6xyHeIRb5DLEccYsnvEEsch1gaOcSS3yGW/A6xLHSIZb1DLCAdYpHvEIt8h1jWO8RC3iGWTQ6xrHeIhbxDLOQdYunuEAtyh1iQO8SC3CEWZg6xEHSIBblDLP0cYunnEEtwNX0VfQ3djx5AD6KH0MNoP3oEFdCjaCV6DB1A3WgWKqLH0RPoIHoSPYWeRs+gZ9Fz6Hm0Eb2AXkQvoa3oENqGDqOX0SvoVfQaeh0dQW+gN9Fb6G30DnoXvYfeRx+g0SiOJqGpaDKagqah6WgGGh+qs/zu6cWNH3ZxI1opWtX9E1jkuKN68OHo7tOrHafC+uDHixzv1Xefnx/9lGgWnDku+sT7TH8Zpr8M01+G6S/D9Jdh+ssw/WWY/jJMfxmmvwzTX4bpL8P0l2H6yzD9ZZj+Mkx/Gaa/DNNfhukvw/SXYfrLMP1lmP4yTH8Zpr8M01+G6S/D9Jdh+ssw/WWY/jJMfxmmvwzTX4bpL8P0l2H6yzD9ZZj+Mkx/Gaa/DNNfhukvw/SXYfrLMP1lmP4yTH8Zpr8M01+G6S/D9Jdh+ssw/WWY/jJMfxmmvwzTX4bpL8P0l2H6yzD9ZZj+Mkx/Gaa/DNNfhukvw/SXYfrLMP1lmP4yTH8Zpr8M01+G6S/D9Jdh+ssw/WWY/jJMfxmmvwzTX4bpL8P0l2H6yzD9ZZj+Mkx/Gaa/DNNfhukvw/SXYfrLMP1lmP4yTH8Zpr8M01+mNv19wGbQY8wEx5j+jjH9HWNCOMaEcIyZ4BiT4TFmgmPMiceYE48xGR5jejjG9HCMyfAYk+ExJotjTBbHmCyOMTUeY048xpx4jHnhGFPjMaaHY8yQx5gajzFLHGOGPMYMeYw54xgT5TEmi2NMFseYLI4xex5j9jzG7HmMqeMYU8cxZs9jzCDHmEGOMYMcYxKt6SY0Cz2EbkFz0Y3oFfQqeg29jo6gN9Bb6E30NnoHvYveQ++jD1AC3YAWoQnoJbQPjUK3o7vRveh+tB91oyJ6HD2BDqKn0XPoeTQaxdEkNBVNRlPQNDQdzUDjQ3WWf+7z8Y6191cPjkQHp+IY+KnGv2gb1T//KW12e7x6MCoaYU6/h+1nOgf+Nca9IuNekXGvyLhXZNwrMu4VGfeKjHtFxr0i416Rca/IuFdk3Csy7hUZ94qMe0XGvSLjXpFxr8i4V2TcKzLuFRn3iox7Rca9IuNekXGvyLhXZNwrMu4VGfeKjHtFxr0i416Rca/IuFdk3Csy7hUZ94qMe0XGvSLjXpFxr8i4V2TcKzLuFRn3iox7Rca9IuNekXGvyLhXZNwrMu4VGfeKjHtFxr0i416Rca/IuFdk3Csy7hUZ94qMe0XGvSLjXpFxr8i4V2TcKzLuFRn3iox7Rca9IuNekXGvyLhXZNwrMu4VGfeKjHtFxr0i416Rca/IuFdk3Csy7hUZ94qMe0XGvSLjXpFxr8i4V2TcKzLuFRn3iox7Rca9IuNekXGvWBv3jg4X3OrNvPw2d7FPvOj8J15svnxz9ML/Td31O135C9EH5nfXbl5/OLY7uPfVi3/93neg+rULuuv37PIt0Tcvi/5IPx+9SkQUBWaHXwTrr//wqXp5U/Ti/f91bPdPN18/PGrU6FHRf+V49OdZMbb7c9drfaLFiv6JX43+Ij+NBwu+GvWwY7s/q8z9Z6HFiprll8Neqz4A/hxD5c/VhplfIAXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXq54LtJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqJwXqrxXOv8EA284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A284A214bYH+x/vDAr44Lbos3829W042hOst/c/g7RwpGckxYMGqajZahJMqjFEqjDFqOVqACakJzUDNqRStRG7oIrUJz0Ty0GmXRfLQGzURr0Tq0Cy1AG9GVaBPajLaghWgruhptRzvQYrQTrUdL0G60NFRn+W+NvEzmL0b5x9+un+Bt4dMxf1T72l/iJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG7jJG6rnZh/h0Y4RyOcoxHO0QjnaIRzNMI5GuEcjXCORjhHI5yjEc7RCOdohHM0wjka4RyNcI5GOEcjnKMRztEI52iEczTCORrhHI1wjkY4RyOcoxHO0QjnaIRzNMI5GuEcjXCORjhHI5yjEc7RCOdohHM0wjka4RyNcI5GOEcjnKMRztEI52iEczTCORrhHI1wjkY4RyOcoxHO0QjnaIRzNMI5GuEcjXCORjhHI5yjEc7RCOdohHM0wjka4RyNcI5GOEcjnKMRztEI52iEczTCOZqqHI1wjkY4RyOcoxHO0QjnaIRzNMI5GuEcjXCORjhHI5yjEc7RCOdohHM0wjka4RyNcI5GOEcjnKMRztEI52iEczTCORrhHI1wjkY4RyOcoxHO1drZntNPH/w4l0KiAP2q6GtOqddYKt8arSiNP/38wQ+1KPLxvpNfHr54RnqQA/QEB+gsDtATHKCvOcAd+wBdzgHuUwdq1+yv/IB3+v4+7/Ad/UM1j+4+qbf6/lV6sSx/5ix/yiy9WJZeLEsvlqUXy9KLZfk/lqUXy9KLZenFsvx/z9KLZfn/nqUXy9KLZenFsvRiWXqxLL1Yll4sSy+W5V82Sy+WpRfL0otl6cWy9GJZerEsvViWXixLL5alF8vSi2XpxbL0Yll6sSy9WJZeLEsvlqUXy9KLZenFspzjWXqxLL1Yll4sSy+WpRfL0otl6cWy9GJZerEsvViWXixLL5alF8vSi2XpxbL0Yll6sSy9WJZeLEsvlqUXy9KLZenFsvRiWXqxLL1Yll4sSy+WpRfL0otl6cWy9GJZerEsvViWXixLL5alF8vSi2XpxbL0Yll6sSy9WJZeLEsvlqUXy9KLZenFsvRiWXqxLL1Yll4sSy+WpRfL0otla3X974YFd82/DOptDWNDjAvxhRCxEPEQ40OcEWJCiESIiSHODDEpREOIySGmhJgaYlqIs0KcHWJ6iBkhzgkxM8S5IRpDnBdidojzQyRDpEKkQ1wQIhPiwhBNIeaEaA7REqI1RFuIi0LMDTEvRDbExSFyIeaHaA9xSYgvhlgQ4tIQC0N8KcSiEItDLAmxNERHiGUh8iEuC7E8xIoQl4cohFgZohhiVYhSiNUh1oRYG6IcYl2I9SE2hLgixMYQV4bYFGJziC0htoa4KsS2EFeH2B5iR4idIXaF2B3imhDXhrguxPUBOst/b7gAbqt2oJWo0Y7S63uHG+2/T2WshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxElbGSlgZK2FlrISVsRJWxkpYGSthZayElbESVsZKWBkrYWWshJWxMlwZ/wE7K//F8NLJ19CX0c3oAfQgehil0CPoVnQb+goqoEfRHagZrUSPoQPoTpRFe9CT6C70FLoE3YOeQXvRAvQsuhRtRC+gF1EnmogWoq3oEOpC29Bh9DK6D92EZqGH0C1oLroRvYJeRa+h19ER9AZ6C72J3kbvoHfRe+h99AFKoBvQIjQBvYT2oVHodnQ3uhfdj/ajblREj6Mn0EH0NHoOPY9GoziahKaiyWgKmoamoxlofKjO8j8kxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwkxGwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktmwktqxpFroGXYuuQ9eH6iz/Gp1qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF71pF71pF91oF91oF91oF/1nFx1nF71wF/1uF11sF31rF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51qF51q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"
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = b"eJzVXXlgG8W5T+L7zn1yOpcTJ3EOQsCEBNmWE7EayZHsHORYZHlty5ElI8k5wOEoUAq4r1BMKS3QQsvrxU0ppZTSg56PQkspPSktpQeU3rTlKOXtalfa2Zmd0UrfruLmjyS72m/m9/2+Y86dvbTsxtIpU6cof45NNAnKX+OlsdCwNDFe0bXH5/X43PL/RkKplJSITSi/lh0KRUfln+e0to4cbW1tWjNWPVa3YuVW9XJivKw/GhpITuyfGC9JhA5PjC9oyT64Lza2L5F9tGVivFw8HOlLDcoPNwm115S9I/+ZIo1XimLq6IgkihPjVV1qzQH3xOh45UgiEk9EUkcnhCmD9eM13VJiOBILRTuk/olRYaoMbnDaeNU2r7/N5RX9XRODpcqt8vHa1oHWsdaBaLw3FG2dGKzcPzFYPV7fgt9tmRisVUCUCJXSYP1gw+jgdKWOwRmjwjS13Bqf3+f1txtLbmiNReVCYvFYNB7GCp/RQvyQKb9UqCbLL9Fw73J5BXfAiPuwXMbhUPSglMBxY3c5uEvVcit8/g43Xmp1ayyNrE/Kllnbot/TSywnSyzTSnR3bCNKlGRpqW/AUGL2HqfEcrXEynavKxjEi6xrDUeTcgHhaCiZzJba0GK4nSm4TKggC67QSPW3netu78ZLrmqNywXEe4eypda0ZG/pUMvIEis15bv3dBmUrz1/rDUliyseixkJv5spdSpNQFWGUl8Pwkstb5Vio8PZ8ipb1OtMSeV0SdVqSdWuNo/X073HqHJY4SwUw1XO3OKoXKMV2RnsDojBblegO1vktP7GTFlljf37GuWr+vFqLViDqcSEUsxUtZhazcjpYty+jmwhU7NllDaqRQwewKqvU+Xq1Op3UAiW69L9y3VprdZ6LWwz0oaKs6Iljcupehtwtbs87na3zuTeA/su2nescX+z7ujqrX3yvaydM5lM4/Nc5Uotezqhk7H4aq2s5SblL7dU/gzN79Plt7mD7dmyyy66aOzYsUyxFS3py0yJ04RpWeNr/M3U+Au4u3sCPnG7x4dxv3qLzv3qLRSDszKpp8crp0tB532rzvtWSmq2KlXW7vf6fbpMqy7TSsnMUWVKg27k0UXO0kXOokTmau7o9no9XUFPMCtWsmbNGt2p5QtKdJ4qWtLh17mYukavjJaYn9UJIZcus0qXWUXJLFBlyr1tARfmHFMv0oUuooQWakIBQuiYLnSMElqUqanLFXBjlDfpQk2U0AmZmgihFbrQCkroRM0jvMEdPbKYLrVXl9pLSZ2kSQVIqf261H5K6mQtfuVMLeeMgMe3TTdxUk5NWRPLF5TwKXqaF3GXL4nEUrqkfEFJnqqFniLZ6fW7dFm5RxQPZaUrGtOXlHyj5peKvNcT1MVLo5FkVrq8UbmihBdjlXf3dHl1rspSoyNRSa88fUnJL8HUDroxtZMSprZ8QUkuxWB3eNox2H2RMAZbuaKEl2HCbX6/VxfujcejurByRQkvx3Ru29Pt1iO5rPdoSkrqOqcvKfkmTGeXb4+ucyh2VNdZvqAkV2Cwlf6ADltp73XYyhUlvFKLH2GX6MWZjuJMR02YbtYysizoapMd24WRXRLqTWKYe2ltV2mYZel0b0snK92Z0slKX1LiqzWyZXG1T6VXLXec9KrlC0p2jUa0LKv0c3S2lD6NzpZyRcm26LJKR1aXVTqruqxyRcmu1TF7tvn8WAIpjwzE4omsfGWjek2VsE4nbacn6MFC+lAkGcFCOn1Jia/XxYNdrl16sixLjoQOx3Tx9CUlvkHXfZene7uu++GIPGbK6q5cUbKn6bp7XaitQ298yqOh4d6+kK67ek2VsFEH7/Z1B/T4KJNiqcRRHXz6khI/HTP6boy5UulIBEsLyhUluwkzHOryY72+8sjwSDyRwgyXvqZKOENrA5QSfO3eHsxzKiKxcHRUd56qRu0GVciZugqdAT/mt/2JOOa3yhUl26o1/Eqw6rE2LZQNtNLGEB1lZ2GkyYMsjDR5IIWRJl9Rspt10tShpE6aOljUSVOvqRLO1i3uCu7xYX3HUPJoLKxbPH1JiW/BxHe58GAJHQ7hwZK+pMS36rrLuRxzGDl3Yw6jXFGy5+i6y6nNjTuMnMwk3GHUa6oEF5Yet7vbBSw9Dkrhg1h6VC4p8Tbd3J5O3dyRft3ckX5Kqh0ztxeTK5WiuqRs7qiJbAcuG8RdJZrEXUW+omTdehPU6df9pKQ/jvWO5AtKsFNXs9uvq5mK62qm4pTUNl2qTU8j03qP6lK9dALZrltk13YP3qM5PBjBezTpS0rco7eW7X5ft8fXo5dQGY7HUpHYaLaQ6sbMHaqcc3UYbQG3C3OM3oQUwhwjfUmJC6p4rSze4Qm6fdtcWFhX9UWSUmwgpMd2TWP2FlWUV0eyx+P26sPZsqMRKdqnI0lfUuJId5ig4NFnB0qTByMjusMoV5SsT4+vgNuYkBOSMSGr11QJfrwEZUSJl5AaTcTwEpRrqoQuvYQOt9xz0mks6ZOiut/KF5TsDt3h8ZasBGvHyhrNWrGAXql7d7u7C1NcOhKWRjDF1WuqhKDeEnV6fC6vV6++ol+ZvYwe1Vsi7QZVSLdu+oDLg0V7WSIUSWKxkL6kxHuw7OTDslMMy0404TsxKawJi2BNWIRuwnbpbtYV8OzU3WwkETmku5lyRcnu1s3U1dOmm2lktFc3k3xBCe7BK8UG5xUjiXhK0ochVY3aDaqE8/Sqt2MNdslgCOtXD5o02Xt1D1FnnnWNlbllXWPlipLep1fb7tJNUxIOxfRq5QtKcL8u2OHuxEOhHw8Fut04oOMNdru6PXorX55MhVKRsO7R6jVVgqhnVv9OdyDgwTpXlfFDUiIR6cMya+YOVc75ulMjV3e73r8tGw6lwoO6U6cvKfGQbvN2F94AhkN4A6hcUbK9uqzHh3dOIzG8c6pcUbJhPaN3+YPdxgIqR+LJFF5IdWPmDlVQnw5iuxsbnJQOSglMAeWKkpX0rJIemGCteEV6LKK35FWN2g2qkH6sRXB7se5HUopi3Q/lipIdwIY2PV1YZ7MsOTqi9zXloY1ySYkP6lUH/FjAlibiccwAyhUlG9Fd34els9p9vbF4al+yORLblw27+hb8bnb6nJhAzcx5Dukle4KGkiNJuQilIEPJ+t1cJR/US3ZhE9Hly5aNhWLZpruyRb3Wp2VLyIKielLGbb5vbN/YGGbzFu0GZ4J3WC2pxIfRXxKLY5MQMRPyY5oixMTajqatrU2Jrb1bx3q3JrauaGpsbGxaM1Y3Vr1i5Vb5/2PLly/PXsv/XzFmeHjvgca66v0r5cf2Hliu/G/5isxsok/DT/KqwYmrcEqVmWbdiXzxGBZAyhW1PDCiCRpmnaq7E6PSWGcI60HXtuj39EW8MpLMCzSzGCf+NjTt62tu2rdmX9/KFWPKP80rmvZK7v17m1fv36pcbR1THkjfWt2s3spUvLGlAOGsuRl0JTSbb3fvzoKcuXbvkd37965dfWZodb9rdaeoLz7MbqF/y64XMTw9qVXRhoVmzdq9vW1yMeuwsutasJu5Ck1phfqxeafatXvjfgXbJqzU+hb8bq5iR7Vi8YneWkXbtMri/pV6sfhd1jpMhuVD2eTsDraLPhfSc/v8zVv2hlZf6Fp9nrhf+4+xpoUtrCeYymi1Hs6EAl7fXH5t81v4dbE0PKJlf1cg4JfHRfrSS+nm1fraUHmjckWlkKNa7leF9egrkZ/Wk498QUleaJDEBq5YpWWNZnVepJlEq1PsWodX24pXSy8yjRmEA2LXel24Fa+51aTmY2TNuPBmTGH5ghK+mKwZg716CwZbvqCEL9F6eu0mVmpuxq0kX1HSl2ombqfN1NyM8dXcTIleZhTF7IRVW9ZoVuu7tL5lu6mhmnFDNdMaX26UJiyF191qUvcVVN0GUzXjpqKVvpKqG0PejNuq2cRW71alp7l36ItcZ+uLXGdTAldpxt3l8gZ6giImN601K1ja2EpLvkdrwV0dHQaxZkysmRa7OtPw97QZxFZjYqtpsWs0MdTjNYitxMRW0mLXamIdnp0GsRZMrIUWG8/U5jfqthQTW0qLvVcjUx6GkDjPwSTPoSX/R7O6sjdBHg7swmVLVupKljWuNNHyfdpQQu41+AMioWtJSwsm3mKi7XUa7LZ0p9IAexkGexkteb0WoW1KL9IgOIYJjtGC79er3E1IHsAkD9CSN+iSco/TIHkxJnkxLTmhSXqD2z2dBsmSzZsxiuQLSvZGTTZAy27ZgsnKF5TsBzIxqTen087GoJ5Ni9ykiXix/QGb9TDeTAl8UBPYhgls0QXoJHWz1mXxYvNf0zZjqExI+JAmsw2X2YLJmCj/YQ2YDxM5FRM5lRa5ReuAdHl79AmUqc26NnTSvFXrNiOPD5dZrcvQbeJtmu+mQ04OV11spS62khL7iEZCBzYnNbVFl2ihJD6qScjJRJdYqksspSRux6HJ2QBLdyuxdEeDu0Nz02wiwDJeC5bxaJAf06rscLf7DZsHp56jIz2HEvu4lijbjOPRqct0oWWU0J2atdoMY8+pY7rMGCXzv3pFu3GhA7rQAUroE7oQPjqderEudDEl9ElNSE0TWHBsxoKDjsBPaWIBQmwLtsVpCx2Hn870zMQuT5db7NylkzitFRNtpUU/o7UZmmibgMtubsXQ0v2EuzRz05WOYZWO0ZXerXmYWZVjWJW0Be/ROt0dctY21LgGq3ENXeO9Gc+U5YgK12AV0num7tMqVPZMubGR2azF+1ZmdxvvW7l4bPGabFTNa1F/zOww1n7ONY65X8tyu/TkU9u0tXXvKVW1ddX7V2Ryl4+x7+4/2X13D8jC4+XxRGQgEtPaq+poKHFwTVQ6IiUmxsu64wel2MQNyu7qQI/XLd9JpkKJ1ISwVJgmTE1NyKFRP17ji8cym5onRserpCMjoVgyEo9N7NcKLR+O940qi1/1Q/tLp0wZDY2XxRN9cg3ClPGyUDQSSk74xiviIylZKJnert1wUJJGxFA0KqYUCMmJq8cr0uX2rZu4enC6b7whJQ2PREMpSUzGRxNhSS6gTr6TOipGYn2RsJScWKFAC8jV+rVyR+UbpcqNiVHhQbmSoe7S9PbxwWlDu+X/NQ3tkf/OYkXVU4XqjI4q7KED8t8ypapSdan4SFQ6JEXFZGo4lX1I/bFBFNVyRIUwcW32Z2moV/5HmDIUlv/xDfWpEIb65X+vHhpQ/pa1GxpM/xiR/5a1GBpSBOV/Dyr/Cp81Qh+R/0cAVH9IYj+E1FqnFl7rQzlrVauYVngVn8tZRVOmN69O441X90eiKSkhxkdTslfUj1fqbqiWMYqVoTFfUjjAhy0yf4X8/6Er0yXWD70b47+08Lo/z3TY6SnVA0VlR43YFw9PIM80YQbPdTMEGkFy3Rrut48wNSCqRCPThJmm8LUmSN09Y8QXAuP7ghHfrQzrjleFEuHBiLplzrbwetRi5RWh3khUeZeEqBoQdl+0WHW1+tKJeCiUIGsHxNRjVlnvT0iSGE5vnzNWDgiqL1msvG7kaLpqsTcaV3bVGAGUFQ7gcYsAtN1ExnrLC6/3y8xYNAQXWloiLOIlEmyvm1kuye5BM/uxStmBJo6ElE2BhrYzs4XcTKhWgxeRm/8kKRcwk4Mnrq8YyfoObSRrbGSoNVF5tihivKt9hnXEM+rbAqbKARLPVy0qN/R8KdmoqfdfwCTUO7+mnpTASeprVm2A753M0wgcggEJ7glmqGEBgL5XIpzMC7SZoph9WnWP9QR6U8Xgzv91I/w3GRlq6J1SO3ub37BY69t0rQAn+2bOrKgaa16p0MjNisqbqH1iQtnUwghz3Y4biGe0vbdmvqsuktmd3r5l1LqhjJUBZpaRkT67jOpeA4z+7cKBzC0zT07zqfvwVPSdnDBplPB+0v8xfdPYJCJUKizmOeecrA+mBVQnPI2RTJRHSP9UXwqz2wufNOq3lmn8DZTxN9rqhd+1CmQjBWSTA972VE44NBq4tz2dMxOmPQNdXiosKSgTFj3Lfc+okY/F4w6aR4AzfZ/d+OujSPS1UmE5j8XqPikcT4RS8QTZ5a3PliLKz0RtbPefMSI/n8WXZCtfP7BW63gdrne/jYPhZy0C0F4Csy3gfsh0FNLEaFaZ0MyNOUVANMxPaG4UCoelZFJMhQbInq9JyKm/NERig1JCDvY+USmW9L/aYWm4V0oQ42K49z1npGOMmYQvoZLwZdSdyxmdgyvJJx0aYv2oGMpcRTeCgDD4cTEgX89qLgFx9JPCgVt2EzOuAZNQPy0GZCbXgMmrn9kP3IRZwCzXz+0HyOSxonCYzzNzP9HMIalMWMWdJVBmh8VUPJ2rxfBgSHlXpigJ+xdMHfDOC5ooE1ZzZvZniaL+tDgSHU2KG22c4X+BDRJrGtEjZcIaHsvaUR+sCc/0qzx2d19/aYT+E6Yr/9zccbNvJ9nduP0KCiz7ypXdI6cXmdamOjXolTKhhbtgpp01YqbAfHlAbSxPHVOfToae7NXDkbBpWGaOJbHbbX5t5OBvTOv8g5Hv3qAy41usDAhwopf4wyS1M4vWlAvrOckDe4XcdPEVQONvjPgqy1mLVPo5E6YQABT91iKE7Ev4pgAA4fS7PACkz7wwBQDo2v3eIgD9rBC71+BfZrqpsVlFD5cLZ/LTCXuFa44o4oWpuWRTkZa6XjFquILmWMsXq8rN88Va6j48O/yBSXuNxpS6WPnLcqG14F0P5iu8cEZfNYLfzGR0qzmj9Io/nNA/QjGZbIGAt9d/gqKqHAwlTTetAJLOn8FU0fsW4EPGv+REpf7gwn6Ab1b4q8Vat9O1AgZxf7NYq5+uFTAm+7vFWnfStVYWXutrFmvdT9daVXit/2DmVz2i0PoK4axcO0G0N/NZww/l3DCz39jzkg1K/aFkMjIQE9Xj5KxO1wEy9j+NdIwxQ/4SRht4GeP+leVkX/oqB1rLfwHhZw+TMFPhckqFPJQCtA2vQ23yAbhNAK3IG1bhs1wHxDugoXkTCjwPmICW6S2rMFluAOIX0Lj9Gwo8D5iA1vBtZgtBZWh0YYWwmddQ5MjpptsL1J+mKx3OPlGRD0dDo0mqRwVI+v8xavh1Vsv7JN3yAnL1O0xeaV3RQxXC2QWttVemJ5Dp1lV5bde0PZaOjCTkBll5g8M2htGUqUZlf8T09Z9SPv1z8k7mVDbTLaKGI25sbl7RVJvUALeJaNpUpvfoFkdTKoUtBU5mO+MHJWzY6qI6OqNScBW2HaJKKcDmnRColAA8tYKRG8orbMwNqMxiteOVmtI2boNA5WwjYRwjqVLo4Fkqe3Zuft3+grcjVKex2TyFgyoIMubRltBCfmGFeSt9QgWZCk5iPHkK+aQzexJQZRF1aqywM+1VFRH5Kuo+eCyAqsH4LfuOGfOFDwZQTRGRM5kvfJSAah3Db8Jz4YMCVOcYTiarhY8NUD2nG5JtmdA9lYKbv3Mhvc4XF9MiZkukzuT2BjZ6vEL0XKXQWeiKzixR1ItS13POMO24mLxHzBkOObQGhKYTlBxkul+M4WYjVDgnqDuHWK4IaNRmgJHTOFOMJ5n4AU3bTAfwM3ECmrBZYJxMVIDmaXauPqs6kT2/StjOi2R257O44+U5hDo3s4Ydt1Bcwgcfcy1WnuPNWEAszLOKgP1iMMDD51utnfU+NsCPF7D9OFsbmqgSfIWNkfXvJJhOnmg12D2IXkgo9RgzZXyZSmFfNU8i43X9o7GwcrSHKViA9y8CgH3C1sHOCQAkT9JIABFxomUkDHOZMQOIkpPAeEz4AQwuTs6Nh6YBvDqOTrFa7ZN0tYBO/6kWqx2v0fMJNT9V+EI5arRafy2WIygAha+Zo8XsJE2kJfSfKiHAS9WGE+lNt5DkXlpXDtPPb46NuVpQpcA3ZlStLHX8kgpF7GwYlhBETqlkxXFJpXkclzHuVzDuV1WSmbKGulNH3jF+v8z0tUVH5umW/nfQM3QiVRq88VtWdN2taNpQaWezunxS6riIIcu0MqAhb5qUDDA1BXQRVoA1tTdmTTwZ0BNZOcm0y9uHAd2h5kmmO1NHQJdrlWM6FuirgN7b6uOqS96eWV24pmuOq6ZMjWoK16jFskbF6fmYeGZt4dqtnWTa5e2rdYXrvm6S6c7Usb5wHdc7pmOBvtpQuC4bjqsueXvm9MI1Pe24asrUaEbhGm20rJHj2XJm4Vqcfpy0yNv3ZhWu46bjpCNTl9mF63IGWJcCfWxO4ZjPLArmvD1qbuEatRZFIybyeYUjP4s962pcuELD1ULQ6UlX5dOnNk261kqHpFiK3NauFefIvOtmgsrXmU7wFsMJ3mbcf4dxf2oV6SIl1J0y8s7xmnc9+7+DnqE5VfbPu24puu5WNK2oorI6YN5166TUcRZlzRxWBsy7njMpGWBqCph3dYE1tTdmTTwZMO/aNsm0y9uHAfOu7ZNMd6aOgHnXDsd0LNBXAfOu7uOqS96eCZh37TyumjI1Asy7brOsUXF6PiaeCZh33T7JtMvbVwHzrp5JpjtTR8C867mO6VigrwLmXYXjqkvengmYd/UeV02ZGgHmXZFljRzPloB5V99x0iJv3wPMu/qPk45MXQDzrl1gXQr0McC8646iYM7bowDzroGiaMREDph3DXLmXQ0bbNEvqoVuS+/5pU8qNnvPr8j7T7vZqhn2LqPZNUIPTLPiT/L2sJXDK0TeGmEn52TVavYbPgBwOwlw1dWMcOAd9lGTOVQ3FCX9xZmJ4V2cUDDYF43VCLtyHY6wy9O93fI7ZbqYezd1solGR8Dd3RPwids9PsZZa468q7abIOVElimHTqk2z2yN1WQeW0I9CTfeHvtxpt+ncvu6A6b+ObSMUU5TNdVWAmbsz3OA/00s/gGz7nvBOGmvyJtnwJz5Pgfww+e394NR0bbOm1XADPYBB/DD55ZFdqLHuijouzXC7kJPjp+eLUccCSVCJh80Zcsep0x/PsFKL9NWEsNWA1SmiTiQ6UNgnDQq9f5Bxv1hWzN6rwP44fk7bBlVHiwB8nFfbjzg7Cqx8wAdv2hOrbCHlw4WiCIppJ4IciY5DEr/aPjYttYZduT7i6ifUPP9TNPeSAXwTbRRAaE7YBnJTRSSm1lODwjFwdx4aDjwIwginPZH9w0k1Arn8RyuMtjtCohd/l2Wv7WoyU2KQyOHCBLuY/rCg4yE8xDj/sO2+uxBqzg1e6Aer+lwwQpa9c4jjCcftbUZilrm/1tw/gHBMmwZpyMMA5qwmK3I4YOJOGfKaCAa7w1F1bxzd62wn9vvLezAd/Vg4GFlHqVYB76jEULl3zFN8ArDBH+inOcvDvRpL7CKM715dZvX3+YyzzKvUnDzUACQTRKWiX4bTjQgmyTZMUA5KPpzrXCAe94136U5B7xV65I2NqkpQrm6GkZ3ZnYN1Z0BOO8obzidPcEJbakTQgVPmnKn4ngnHbO7QWZT33AbHCLIOJm2gRYIjTWMeSTG/ZU1dnZrDrONRhz8ha6vE/o4SwgVXXt8Xo+P8VUwAJVH2BBLU5ISoF+qEwZyuVS3O8jYXV5kzzhKqHMO0zPaGR6wzVYPuJBN75z0glc8IWaWydQ1L/R2nTDE45shZ0yL2bU3/F0JOL0XEeoEmfTurCFamvHKNG4TPAB6x3Lj0XinkzGgIT5mtVqRrhbQrl7MdiazL9eijnrhINiTmGYDuNElhCJxFn8pW9vQS3n80avP6Ei9EJ2skXgZocslLAqvsJXCd1mgEDuCGN1bLwzDXTBdor38XU4o8j4WfxO28ncFmz890NBL9UKc96XWcFTu2hoIgXcEriSQfYRByHh1vHdICqfMqgcQ827L1R8ORQ9KCbPqARn9KqvVV0p9A5JZ5YC8/h7LlceUPpNJ5YAJlKs5HpmtDnkahFFuJ1D5ZK3o7zJ/F5R+bRMewNdwcGdthKQG4RAXt/Kt36LivpYzQYS5NrqsQTjM/VyR+q3momIf5wxC9ZyEbm8QjnDn1NOfFy4q8vdyWMfyGXq8QTjKZV39PHVRsf8Pz9MzLSN6oUG4kO/pvh5UVNzvs7A1MA39rQbhIu5hzK42j9fTvaeo6K/jeAw+cN82Xbi40C8bzBaxOQB1HXPd2uJ8qhpdT85j1bKGctNrzUfKs6n78AHd+zkZRuYnJaVn89DwdOFSTgepJjI8Ek+kjB+EgHeRbiDAnUJTpsUa41RzADETVus2+bY0vHt0o2XNI/2mrAN6Rx+wWnf14cFIVDKtHtA/uslq9ZX98YRp5YDVpA9arjyVOGpaOWBf2c2WiR8OpeShi1n1gA1kH7Ls8YcjKfPaAa8Nfzh37ZnWSVvWo08l4Sy3AV4CvsUystpYPCa3LPliA7y2e6tVmzWo3+cMp46Y74sHvGh7m2V+ahJSajQRM/tuEIcewFuyH7HuVEcjUrRPVDaFWEcGeIf1o5aRKYtEezxub4fp0uhRVp8A8O7p7dZZS4QiSSlPewLeJL3DuqvJgyOJ7JHkhAZ49fNj1kkLD0rp3mc+yACvcH7cOjKTBdycyACvZd5p3Zx9UlRK5etpgLcp/zefpEb3fXNCA7wc+Qnr9mS+lMNBBngF8pOWkVWFU4lonpQB3mT8lNVmkv95KMAbiZ+2iqA2ORJKRUJR0/7V/MIBfMYqADMLaNUvKLz6u9jjzOwQBn17pnAL99vPclPoYXw4hOnqZuvemhNKUXL0BB/m300o+mPmMP9njGH+85iEeucF8o4CnWx34XMB9zgMHb4h617ObIVuTFQxS7g152eevZPdk+4jlP0X0xxvMszxb8oc/ymOJ93vMHS4Jz3A9aQMI8gzS7gttycFi7nj5kHeeoY+IYPeM0u4nbsooOxM2+7xMrDnFQVwrT7LmXPPzvOgZ2YJH8+lE/tbgcoW305/wPLeRb3R6fbnSRLnDXB2Tdz8wghSAOUPEZSvqWMF6bo68yDdwLi/sY4M3k2MJ8+knjyL8eTZ1JNb66iEAEhZn7PMxuTRWr3jonkAJMaH/wt5gO+g/rxVrQEppjZz9IPJjpt0z5ZxOnNh/RFGvgBMzD9i2TOGGFaMMu7HKOuOMJ5MUE+maD8AzP9/wbKOTuui3jlEawdYYHh00mgHf939i5wOQ3ZtBt06W/hkrrd+WPvv2eFVIx0JSyOmr0eYRJ4W/f2RWCgaPWp3K/4YwcPNTJvewrDUbZSlPkrducPWtvZLRcH8cVvbxccdxgxvw77sAMI7rLAKaFO+4jBmeIvwVQcQmnAIyOpfsxUhPDM/wdmGhCdO9MJs4VOcTSVzRBF7XByJjibFdets3F7ydc5IWqs5fZLa67OFT3P3qKVPuGp3d1k/2ETv9bmCk+I9nm8QXPyW6UQvM5zoD5Sb/9XWRuObbGsZ21a0fo7wGe72NqWT7vG5vF7rDT+c4W9xvA3bz4EOzxHuyTXHgVzd7fmew5ZjX5wOQYu09UXaF/dtNi/TVVDhUDK7++/hOcK9uSbk2l2MCbmakVAqJSkbEKQLzAZg+U4Is9/QHJpJz1YCOPoOwdHCelZ0nlhvHp0n15PRuZTxpAlyQNT+H6cxwK2BTp0rPMA70jGeELXnbWwBniTQnUbzqlUfSrKqB5DzXd4maV1ftH2u8CDP6eXw1R/XtrVuIHy1goQP98qnCPjtDPaGtmM/wFl7msMaZiY0PFf4LLcZMHGpgtplOJPf46yOZvW5bq7wOU6ENEQj8nOhqANh8n0C3vmsMJmRjMQGolIqHnMgWp6xiqIhHBpJjSYkFgbAKPAHVjFMl5PaqBQLM0EABnrPWiZiODQyIluEhQEwcPuhVQx16nsqDASAgdlz7JihQgG55gmPc2KnhD6UEB41PyIAXsWiqKzT63cx6gfEy4+t1l8zPBpNyUOshOwqNsbKT9gGMskT6KZ5wlc5Jir19XjJ02HgNvopgfEWFkelbX4/o3qAiX7G8WEyiaEX5glf5xJEt0xwgn7O6Z1TKQ6dOF/4Frd37g3u6HEFzHvnM9PD/EgsJrHa5YWiSNap9XZOI3s7AdOK4C318wQfn2X2xB9m9K8fke/fOGXK1CnKH2OX/DFKBN4B/4VVwNyTX3PaZuhRcoDBOA0WPhP7gmUTfIdhgiepwdDTLOYBzfQvOcFNNszopfnCk4W+1TazLxLmB84CZXxvqFGLm41FGuT/iuDi50ybvcCw2a8om/3GgWh5EYyTiQrg8b9me5JZYKKNC4Tv8t7WM5sGgTcVLxEoX2dmGu6ZkrwhFsCyv+FwaBI/aGCB8BT3mDTWcOtYjqkhc/rhIfZbQsGqBj79+RyxCqf/d2z6iRECenaB8H0e8+yp8XmiaChLS3KnUzOh7Iau4eDhrLTJ8i63TQMY7/cEPSexjDd0aoN53lncQE3wMZ5cQd2Hm/dlMH4W2uWUXkz8gAz7imP4mWgBPYs/WEXLjhXaX7hhUcuJCc6JkJBoAkxOvGrZmp2Wo8nDeFKgntzBsjhgsuOPYI2s40eMJ/3WNQWsZv+piJoy8QNWv//MWaY0hAIaXCg8y2vnCow5h7oXfyH0StB2UX84iv0AnyH5K2cQRSYX9MGFwg+5fTZ+OuKQanLiifoD63h5h6zwN4KOK5jRcS3l7e9lxMX7sCfhPYG/sw2GnRuA/r1Q+HHhO/m5p+rWKuu1YihpZmJnlvZfI2cRmVa5nWGDj1HWutNWq/yDk5UMdKF1i4Sf8AwzVxRxAa2LvYmcf9OesZHkfxIqPMBKQA/bmoD+xVmayyiJdi8SfspdaixkC5AzX6h4ndDnqywav24rjW9wFm2x8zzQvYuE57l7rdRj4rknUxkDH07Zm5zgMZz4gZ5eJPyCh77G5/d5/e1Fxv8WJyXr9aG/LxJe4IGfJYrZp7WwP4Pc/ezEwWD/JuC/wvLYP9vqsW9zeh7kYSoInSC8yDV8IV8/c7LJ+g9nXw5+Sgu64wThN7k2P6rKFTGJvUOgr5jOcInq6WR7C3eMKdPYqQw7RQb99gTh97m6OMyDXdJdnM6AHxWR1amEYvNoVrVuzEKKVm2wNt3OTss0DtHYwTNo7YnCH3IRHXB5WG/pcr9cW2QTlBAqr2SaYDXDBC22mqA0Nx4WHPgGgjK2/Q3H+6BrTxT+lCtHuYJBdyDvDdqcj504Yv9yQuUOpv23MezvsdX+FZwQxI4xQi+eKPw1Vwi2b3e3C0XkspLjPvhxQmjJScJrudynw+11d1tPIHD0VRz0+IlDaPAk4V+5G+gufx7OD0dfzUaPHf2D7j5JeJP3ERYZelDwkF1l+FJlDQHvQkZaG69VTC+3HL5trm2MzTWA6Kq1CkMJn7aA20WGDzzH1lmFUKNEsN/X7fH1MIgALGjUs93FeB4Smney8DZvm/ihSDJi+zm0DQS8G5kkRQZi8YT5kagAP5nOycKYwkg8GU2ZmisN7/QEPeapgLNmXcg7EBwhR86zmEGw9HFm2/kJRtv5Kcb9z0wnZ+fuZjx5L/kk70AzgEfMBOtKIR26n+45ABLLLAcQfpF6Er6WOpvTzuLRjJ46GZVwg0tpaD3bfH7G9saCDuMDhMMcTtLAjqBBM05B5Vy9eF/GnC2K2OcC1RfHyC9Dmx2tCldvLqHe80z/+iXDv16kYpXTFwLE6jzLSClEQy/ZGpPzAUhepZEAom6BVSTcU1Py/uYz2xMBuw0WWmb1PxSrU2aQd6bNMPVWnm8C9hUssgk7fN3/BFs8ojw0OiDGR6xnIMBK/4mWuVtAWXkReYdnX8Cp6iexG4EMVejpU1C1eQOgtWuB4HZPZ7dIBRW8Y30yAa95BqNjXeXlYwCk51MsY2jbJfr8bAyAxHxqPhh2+wNMDICU3GgVQ6WMgQMBkEkX50ODy9fBxADIiEusYihHfjYAQCJcahlAh2cnEwAgry2zCqC20+uXHYEHA5C6lls3RI+XCQDw3YcmywCCPW1MAICPO6ywDMDVwXZFwJcdVlqOR+Tq5lkB8AmHZqsYajK72pkoAJ9rWMUZTGENN3r5VLSQO5iqOxyKJuRRkjpqsuMQCv4RtI7M7q4m2HgXwyZDV2I/wFvqNRarHa+JhoZ7+0LGDh+8lW5hOwFhViQ1opP4kwWsDYXKZwYDPUHaidWfS0ci2Iem4KZcS+h0G8uUd9pqynWcWRfceOjBRnRqzlkXrwu1dZgv003vH42FxT4prLyokwgNJwm6ARsz8pz5hNtqPUHafbSttAHHg+aDyKGHqIHIo4wnH6MHdwBzbwAjf5hx/xGIRoBccBpYozxwAnr1G9mBpqYS1LQYLeFGmDHlaGOALk+XW+zcZb53pUqREHtDtu5YOp3Q5GesTPWirZlqE2clU1cTxRej5fw8RXOi/ZCmsk1gcFndG0kdVva6xO2cPT2D0OqPLDJfs5XMMzndKExP9OXFaCWXTTNWtKycHp2a78nPCB2xlctWQql3WFyWz7STy7M4TSiuKHp1MWrmkmnKizayUOcb+HSGYn020rmZ0GvGTAad822l82wLdCqKokVL0CprdOK86HS6fOaBXpYcjPTbuR66hdBoMYvIlbYSuZVNpKYi6liCVnMpJLjQyFPnIc2zZDQ+EFG2Ydsa2ecQqmykGdQa+TNmEt2Q8XIvE+3Q5pl2dq5cuVHS1cJHQ22cXI5ZA92+BK3lx0vmaTpeZouiXpS653z9WhsN3E7o4GdRF7A1RDp4ox+MDPTUErTOGnexOBkuc3Tu5LI08tbZSJ6b0EJkkddrK3mdFshT2EBvL0HrueSV+Pzm2cSUVThh2wjkcQZh4xXh+LA8WqU+KA1gbTubtWxtaMlStIHL2Azl++nphzV/Ig+JrQ4lIqnBYSkVCdtInIcAfynL06601dPO5SyehYdH0otnvqVoI2/xTNk84QmSswTwlTOBwHYdy5fSc4rkC2ZwbrxW61cI8FGfNoE3PygvAhj1AwbWPqv1T/Mx9ksCFsr8Visv2UZtWoYvkXVZrt3Lqh2wPrbDMvHbGGcqAtbGApYr9zIqB6yIBS1X7mbQDlgN6+ZtJ9OTPvr7UuTiD91NmggtUpHH18M4djclJYZtbFF6CG2eZvbsn6F69qVdXnOUQ8/Z2q/fmRsjXS08se7izBimrYBOXYba+DOGBmtpuQD5GePekfhhyc5R225CgZeZtn2Vsm1Jh2enqWn/Yqtp9wAgVmVX3a0CBTjDeQCg3FPezHACWuO9EJwd7naZUPM3ss1wAhrufblx0tXCW+z9nDkZNfxQeBlq58/JGOMUtzHrKLny/lA4ZeuMzAFCkUWzGPw1zrJzJCByRgKajujyZaiDv49a3T9WJKbOJyCvppnKGJbZ7A6tn2Vn1gtZhsRuYk0QAdJbb25ExzIj8lhMClMv9QBSVpg7IldrQz9ehrZxnYoCpnWytNv0XtgabfeszfsI+ghtvCzbDvlnkQm4ri+SZOEdCtrqglJumHS18D5VP+9NZswe6Izl6Fz+hJ+Z+TSbu0Tuqux0TNTuxdkBQsF+Fq/DtublQTavtLbo1uUIccllM6SRrzHMXKyt7EuKyZHQYTt3fUQIHY+wqL3EVmqH2NTqWqKKJtTFf+OQYkS7r7za2+XaZb5/pnw0NmKvgx4k1LmGxeL1trIY5XQcNB1RVxMK8jnkHpdcYu9pO8ME4ltYRN1uK1ExNlFpBdE1TWhnzu4Va21V3XwRDkWjNjIVJyDfxWLqfluZGsm1ISWtJnqiCe3hexW3sTB/yQZO2gUE+i8y+4A5mrOhr9jaMUhYxsXNXGaoAP2GZF6oXLtc5m92m6EC9FxTuVHR1cInvUc5hwQYvBVtWYH2cX2f9wpZhfKhGdFvflJJbX8kmpIS6VUwO0drhwjdfsXsPr9Edp+HfjvL/I3BWnUzsjlWQKgcdgBrTSTWJx0Rk9FImBqVAOLnCADq722NmaMAJH+hkQDC6EIAktdpJIBZqYusIik8Xis7/N3s7jr7uELA+tSYZX6nzyb5nTnbPDwqFDVYDeHc2ZRRACtcxxyAX9JhPu1lBh2wPnYxAPpsc+hmCAGLaJcAEJ5kHSHgnbNLAQiXW0cIeCntstwIjxmmSgzdfvgLae+yWn+pUj9ZMeAdtMutVlwv9Q1ISlYj8qUGob5wCFfwDkvBWnBUuxKdz5+35H0JzubThgoSmiOKmEbadifqo7pOfWbuSoLontmsMNzNCLrzqPDcx3jyAPXk+Ywne6kn+6kn4f3Ld09K3fus6w7osF41KXVnagroEL/nuGqahzUBXe2rj6uOTI0AXfZriqiR9SyUhzUBHftrJ6XuTE0BY4DxSaBpHjYFDBneOwk0ZeoFGGj8TxH1ysNSgIHJ+4qoERM/YNhyHRi/E/23PGwHGDJdPyl1Z2oKGKO9fxJomodNAUPBGyaBpky9GgrXa6KIeuVhqemFa3RjETVi4p9ROP4POIbfkTw5s3BNb5oEmjL1mlW4Xh8sul552Gt24XrdXHS9mFrMKVyLDzmmRR5WmFs4/g87hp+Jdl7haG/JjTb9w3hl+jtbh0LU3PX8wiu/Nfc+RHX3SFczGih4BZ33IeHq9ClMpl/fVL5xsMf8fVyzmXytLoc+yH0bwdS5c1hOheaQTu6fY+5OO6gnd1FPwqdPP+IA8iDjfo91jQCToh91QCMmTsCU5u2cV+Qwt0cfakYR/llB6Q9L5veF2tqDh8W8xOAxcgeh7yjTLkcou1zIsMsY9iQ8Fj5mFWHB9AHc+uO5wak/XIv9AH/v4E7LnOTnhvDp8v+1SsgHaUIAc9qf4LzwmF7CRSesQjHuCdn0PhL4G/6fJGDdybQTt71lLnByW05AzH3KKu6he8xzgOlx7arEAw60Lp/OjVeF1aA4gxiOR6NSOIXzCY/Jz1jFkO52ySGZkhJ0xxAQendZBaB+csHE0wEBeHeOjZ1ZfdENq1CKF4i1vaORaCoSExWUNsbiPQTCZ1j0lCqb0Ww/bONey9W3+f2M6gERcp/V6muGR2X2k6lEJDZgY3Tcb7X+SrfX6+kKso47AcTHA1YhlHV6/S7G0Q+AEHnQav0l/nZG7YCVz89arr2NddIKYDXyIcu1b3fvtv3Qjc9Zrp0+QRh+6sbDnLewspkY9a5Gl/B3W3Xv6XJzvzlu90e7P0+e4jiX1QuYPZexfd00l8P7J49w5kDw/IWuW40u4zU2c0QRe179+NX602xsdb7AeUO4P4PygdXocv55K53B7oCovELGODpRKUo5HDtFno1dmZZ0U+9Uwb3jUUKzVSzvGK9T0e/gKFCXViB5gakONRl5phoAV/oiZ8CPsYpq16B38zxptijqj2tbDTfa6EiPETjbabrBXHyJzQVhIORbg67i0TFPoyMjoTFyuo2MPE6g7XKAkS+zGaGGEujza9A1PE6q+yLhFPEqD5yGrxAQ99M0aG1EUmLUDiDoq5ZrH5DI15jgvdqvWa29Oj0Rb1o9oFP7hNXqK9OWN1kHAHRnv2618grF7iZ1A7qy37Bs9dToSFQyqx3Qlf2mZdpZyy+Anuy3OO0F5mTofS3oBid2zyvH6War0Tosm4q1pf3bnPeW9fhGX2tBE/z3vAuZ7Rq6CbPzMUdXjr7D0VPPoui1FnRjDj3bAq72PE1sqqdZOXA9/4/jzFhjhZauRR8oWNGKg4fkPkCEnAcsnpZPct94iWVfBUbda9FNOb+97Qru8bWbn3gh/9rJOGift9Zqerqplj/pQw+yAxcMuta7OsPGwd93CdK+zRz8PWk++Bt6inH/e6Thh55hPPks9iS8p/+UZY3sRa7eeY7WBdDxefo46QJfYP0e70yaTC8JfWIturnghDNTFDMlaYFBfs7aPCXxlmadyk3fJ+j4J9OQbzDM8xZlyLepO1Pn2b9H4RkwchrnO4wnmfgBIfQDB/AzcQIC5lkwTiYqwOjjh5wwzva60Ytr0YcK7wQXsoXCsa7vc4TCS+axzLCcolu9v2Ie6S6rHQjLH4FxMlEBgu3HnA61PkRE09ehDxc+cFALMvEXp4YJPyG0OofJdTuD620OeMBPOVPOmakAtHEduqXgBraQwHSqAf0ZoW2QaYOdDBvspuJynwNW+TnHKpneCDqwDt3GXwiYPF+yfJ5QKMIiPscBwxx0ALp/wUk4uveim9ehj9i+jc8Zvl8gNLqY5lv94UrsB/gE7y85UwRYwkW/X4fuKNx1WVT+l+yi/BVB0nXMJHQDlWxuZKSlm6gnb2Y8+eF5dg6TX7SqS2EWPQ6bNH9t2Tp3UZzfw+D8PppzQB//JWc5L/Ym0N9YJvxxivCvMAj/Gk04YAHjt04RDj+i4HeWoRUaSoDVj9/nBqf+8FO6EQJs4HmZs7vQQAL6xnr0Sf5LL/mSdkybMTps3MwKbzReIZT6HYvLP9naoP+B1xHVlER/W48+xe8X0RuO1B+mMT5670yn6FVCmTcmVSf0j2yqyfO90I4N6K7Cp0oqlC+0+TvyXUycL4pGHOqC4oa1xHOOzar8iWCofj6rpZgx37xdmMW4P28+2bIsoJ6EW/jPUPxpy7k7tplabmgOpUQeagF6TH8Bm6UJbhZAf+qvYPwg5gFdp7+BkeeBE9CB+jtnTTWdUuIj6r7Wxzagu3mboirTT4diR23cEvUaAW47TWKmY6xU3p+gz3gE5IR/WK29Il17Km7jhqh/chr3TG3o5Q3oHp5JKlyBgH+XSC5kw+3yL3LjDsu5x6s1CGLXOtMmbYGyobhPxE7yVr5na9Kl0wtab/vW0dd5c0xZx0KrTkP3WqCb8c4HgO43CHwjuej22kW31wm63+QsOWWTCLrgNHQfN9+oCNs8ttP9FoHv8qLR7Yh3/5sz8Yd96Ql97jR0P/d9rszDZmkWQPfbBL4PsNJsFi2daQH0/Mdq9TWZ6k3aOECmf4ezV9v4LS70ymnoAf5gTu6Ddri9bupLv5oGeINu39htSkluB1Oaq4aN6EFuRLc71V5NJRB+jhnRNe05GqyCFm54cxVYjfbH/jSrig89zuiFfoXqhX7TgXFKCduFjGkHiRvRZ604kf2tcCmB8dmcTsRsFxxzIkfa6zKrig89z3CiFygn+o0DTlTOdiJD7kb3b0QPcY8QaHesb1FBYPzbJHQiRzJRpVXFh95iONHblBOVLLDfiao4mcjwvSG08nT0+YL3uHA/lDIrd4fRqZ0w1YT60xcUctAF9xVXruqWe8xOnZhRw7G/4RtO6JOnoy8UbH/W7DovPp2yeS1bZVNPRM+ejh7lam7BgTlLNKR0JCUN29hdrSPU3Uy7uPpD+wI7l2vq2SxznB4t3IS+aP9OIq6B4BQ3ELr6WBTvsJXi6dYdOe1TaP8m9Fhhq2Pl4eER+nvOzqyNzWCrheFDD25CX+b1amqSI1I4EorafDTSTALdMMPW49XCLnewXfS5EDk6hVt+llUQpezqAZ2G2ZyeJ846+usm9AR3CjH9BhH14Ui4leYQCN/FIqhWRtDlD3ZzYADsNNcqDIWIgJ/6UhncVPOsIkh/WrSny82YjQAsas3Ph4Sg29tp+wk6C/JBsN1NrRfDXzxeaBWBnDXEnZ6gp5t6Hw/+/vEiTl/PcOAJuv8M9F3urIPc4RWVTq/tgXsCgfFepqkUCC4feWgrPGZPtIogTYIjh16dlBeEDg/r2CVA0J6clx2CbgYCQNCeYhVBVdoZe7q89oftqXkZwusJ2n/+VWNeNHBOAAPsnluclzMwz6ICbKRbkhcLbXu63Yxz2ADnYS21iqE6HRLdAY9vmzkIwKdolhEgRksZIKanlJdIh1Pi4UhqUOyLh23sAy+3CqIuFR+JSockFYqNq1hNuRE00b+od17D7AafQFsBQPImjQSQslcSSH7FQsKbjKiJDI/EEylxJJQatHFM12wVm+EX9U7tQvMJ0vqFdr4+sIpA+DbLp00+KAyPqNVWa89xzCSAgDW5ITTRv6h3FlEmggdWCwDPqSw8gPBaS+CZXcYKL9Ynp5057XCdVVyGX9Q7GxihtdHW0FpPINzAZC6TfQxToJycBWdvg1Vshl/UO20LyTsdLL8DsHcagfAHTPYqO9zt/gBrHcL8JBc4gxut4jP8ot7ZwfC/oK3+dzqB8F9MBrmn3TjjgJusgjP8ot45n3LAXgcc8AwC4Zpy1o6hYWm4V0qY9vUADJ2Zu/4m+hf1TtxWR2olkIxUsBypSoqNDhuJcNSLzrKKzPCLeuciyouOOeBFmwmEN1YzuVO/V3IoZOmYGzh3Z1tFZvhFvXMNxd24A9xtIRDOrGWNfpOpkNx0SjE7429r7tqb6F/UOzfbGn/nEEh+WccagUtHwtJISuyzdenHlbv6JvoX9c6dthLRRpqknjULMBxKhQfFcCgpib3RePigjXS05wbRRP+i3rnfVjo6CCSdLCTjFfK4NiUlqLa9bZdITbjDM4vbKi7DL+qdx6jM8rgDmaWTQPgokznOnMHM9MFJ6rF+JL9wErdZhWj4Rb3zJKN/+ZSt7redQPjrgkhMH/3mFIkeqxANv6h3fsYg8XlbSTyXQLi4Ie/htdliN5w6wSowwy/qnVcY1L3qQCh7CZwPMQmsSO+4CpHH1TvUvUJWcRl+Ue+8QSXBtxxgzkcg/COTOeb+GIe481tFZvhFvVO5iLxTvch+7roIhC9OL2RsTW8PhHO3wyoywy/qnXkUdwsc4C5AIOyeyWw3BJP+ifpTTTQ+EAmHomIo1mdjgxG0is3wi3pnGcWVer9pkZ0NRjeBsI/JnnK+sYv6BAdBXyxu547AHqvgDL+odzYy6NtkK307CYSXM+mrDiUiqcFhKRUJ59gVCOdtl1VUhl/UOx1U0Hbaythu0qasbz3ne8ZaViifg/AKEoIbaI9VEoaCDDfuocy0i/HkHurJvQ5k4fOOk0bwFbK9RUROM6/e309rBFhj23dcNYKfgrG/KPjhp2AcUHDeePpJU9J/QIAhwct0IcB+KRFsAhvSEWCv1flFwS+Bd2SFHMOZh58AdnP1FhG/BN72FXYArYaqpnBUfZZR4b8Us3vA9JzawrWWJr3Wmo51hevYP2l01HSpL1yXgeOqSx4+2VC4joOTTEdNo+mFaxQ5ThppyGcUjnzIAeSO5MCZhet4cJLpqGk0q3CNosdJIw357MKRDxcReR7eNadwjWLHVSMN/9zC8ceLgl/DOa9wnCMEzmXMT3FmPvmc+RW+e+ACq3WX896kAMz7JHIDaKJ/Ue8sPcHOeZwkAEnzCfbvdE6R2xaYX6dNf+C6y+Omvo8C949RqyCq0iDa3EHy44ZwFzmUGwPkg5n8b8sAHOqwVdyGX9Q7ZzvgUEcAeNpZeADTdEcBeDwUHvW+cAL5JGIhB0zcXUggD7KiIvvtemei8yKrOByMzrHcGCZldB6zitvwi3pnwIHovBiAZ9iB6LwEgCfJiM5RKjoPOxCdlxLIb2JFheHzvfb1qS7LXX8T/Yt653q6SwOIzXcRSJ5jxmb6I8LkkQ9aDjsciiZGk6J6DpWNi5iXW0Vn+EW9cyvDwz5iK39XEAjfYvKXzydh4cxdaRWXyedd76Ji8B5WDAKYezeBcB77xEGz42HVn4xH39nneFdZBTf0KEmWQ5/6eE9uRDQg+AkXV1smgv4sAEXN0GN07AHaw2tsxfYEjQ3QNl5rEzZwWze65v8BlC90zg=="
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1


def Lark_StandAlone(**kwargs):
    return Lark._load_from_dict(DATA, MEMO, **kwargs)
