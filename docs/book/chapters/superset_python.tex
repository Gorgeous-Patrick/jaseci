\chapter{Jac Supersets Python Natively}
\section{Jac is Transpiled (...and compiled)}
Jac is a superset of Python: its grammar strictly extends Python's grammar, adding higher-level constructs and object–spatial features while preserving Python's semantics. ``Superset'' here does not every valid Python source file is also a valid Jac source file; instead, it means Jac provides the full expressivity of Python and then adds more. Practically speaking, you can write everything you could in Python, plus idiomatic Jac features, and the resulting program behaves as a native Python program at runtime.

Conceptually, Jac plays a similar role to how TypeScript or CoffeeScript relates to JavaScript: as TypeScript or CoffeeScript is JavaScript with wings, Jac is Python with wings.


\begin{figure}[t]
    \centering
    \begin{tikzpicture}[node distance=10mm and 12mm, >=Latex, font=\footnotesize]
        % styles
        \tikzstyle{proc}=[rectangle, rounded corners=2pt, draw=black, fill=blue!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{data}=[rectangle, draw=black, fill=green!6, minimum width=28mm, minimum height=8mm, align=center]

        % nodes
        \node[data] (psrc) {Python Source};
        \node[proc, below=of psrc] (past) {Parse to\\Python AST};
        \node[proc, right=of psrc] (pbyte) {CPython compiler\\to bytecode};
        \node[data, below=of pbyte] (pexec) {Execute};

        % edges
        \draw[->] (psrc) -- (past);
        \draw[->] (past) -- (pbyte);
        \draw[->] (pbyte) -- (pexec);
    \end{tikzpicture}
    \caption[]{Baseline Python pipeline: source \(\to\) AST \(\to\) CPython bytecode \(\to\) execute.}
    \label{fig:py-pipeline}
\end{figure}

At runtime, Python compiles \emph{module by module}. Importing a module parses its source to a Python AST, compiles it to a code object (bytecode), then executes the module body once. The resulting bytecode may be cached under \texttt{\_\_pycache\_\_} for faster subsequent imports if still valid. Executing a script performs the same steps for the entry module. Function and class bodies are compiled when their definitions are encountered during module execution; their code objects live inside the module. The unit of compilation and execution is thus the Python module.

\begin{figure}[t]
    \centering
    \begin{tikzpicture}[node distance=10mm and 12mm, >=Latex, font=\footnotesize]
        % styles
        \tikzstyle{proc}=[rectangle, rounded corners=2pt, draw=black, fill=blue!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{data}=[rectangle, draw=black, fill=green!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{note}=[rectangle, draw=black, fill=orange!10, minimum width=30mm, minimum height=8mm, align=center]

        % nodes
        \node[data] (src) {Jac Source};
        \node[proc, below=of src] (jacast) {Parse to\\Jac AST};
        \node[note, below=of jacast] (pre) {Jac high level\\analysis and\\optimizations (optional)};
        \node[proc, right=of jacast] (pyast) {Transpile to\\Python AST\\(+ runtime hooks)};
        \node[data, below=of pyast, draw, dotted] (pyprint) {Generate Python\\Source Code (optional)};
        \node[proc, above=of pyast] (bytecode) {CPython compiler\\to bytecode};
        \node[note, right=of bytecode] (post) {Jac level\\analysis and\\optimization (optional)};
        \node[data, below=of post] (out) {Execute / Package};

        % edges
        \draw[->] (src) -- (jacast);
        \draw[->] (jacast) -- (pre);
        \draw[->] (pre) -- (pyast);
        \draw[->] (pyast) -- (bytecode);
        \draw[->, dashed] (pyast) -- (pyprint);
        \draw[->] (bytecode) -- (post);
        \draw[->] (post) -- (out);
    \end{tikzpicture}
    \caption[]{Compilation pipeline from Jac to native Python execution.}
    \label{fig:jac-pipeline}
\end{figure}

As shown in Figure~\ref{fig:jac-pipeline}, under the hood, the compilation pipeline works like this:

\begin{itemize}
    \item Jac source is parsed into a Jac-specific AST.
    \item Optional high-level analysis and optimization passes run over the Jac AST.
    \item The Jac AST is mechanically transpiled into a pure Python AST, with well-defined callbacks into the Jac runtime for Jac-only semantics.
    \item Optional code generation is performed to produce Python source code.
    \item The Python AST is compiled to CPython bytecode using Python's internal compiler pipeline.
    \item Optional low-level analysis/optimization and metadata attachment are applied to the resulting bytecode/module artifacts.
    \item The resulting artifact is executed directly or packaged like ordinary Python code.
\end{itemize}


Jac mirrors Python's module-by-module behavior. When you import a Jac module (or run a Jac program), the Jac importer transpiles that single \texttt{.jac} module to a Python AST on demand, compiles it using the standard CPython compiler, executes the resulting module body once, and exposes regular Python module objects. Downstream imports repeat this per-module. Optionally emitting pure Python sources or caching intermediate artifacts makes subsequent runs as fast and predictable as native Python.



The consequence is powerful: you can reason about Jac as a natively Pythonic language. You get Python's ecosystem, tooling, and predictable runtime model, while writing in a language that raises the level of abstraction for architecture, dataflow, and object–spatial programming.

Here's a tiny Jac example:

\begin{jacblock}
def foo() -> str {
    return "Hello";
}

obj vehicle {
    has name: str = "Car";
}

enum Size {
    Small=1, Medium=2, Large=3
}

with entry {
    car = vehicle();
    print(foo());
    print(car.name);
    print(Size.Medium.value);
}
\end{jacblock}

The Jac compiler will transpile this into a pure Python module (with calls into the Jac runtime for Jac-specific semantics). A very rough Python shape might look like the following (greatly simplified for readability):

\begin{lstlisting}[language=Python]
from enum import Enum

def foo() -> str:
    return "Hello"

class vehicle:
    def __init__(self) -> None:
        self.name: str = "Car"

class Size(Enum):
    Small = 1; Medium = 2; Large = 3

if __name__ == "__main__":
    car = vehicle()
    print(foo())
    print(car.name)
    print(Size.Medium.value)
\end{lstlisting}

\begin{nerd}
\textbf{Under the hood}\quad Jac's transpiler maintains a one-to-one mapping from Jac AST nodes to Python AST nodes wherever possible. Where Jac introduces new semantics, the transpiler emits calls into a compact Jac execution library. The Python AST is compiled using the same CPython compiler that compiles ordinary Python, yielding standard bytecode that the Python VM executes. Because the compiler still holds references to that bytecode, it can attach metadata (for tooling, debugging, or optimization) before handing off to the runtime. This architecture is why Jac feels native in Python ecosystems.
\end{nerd}

\section{Jac and Python are Friends (no need to choose)}
Jac and Python interoperate seamlessly. Unlike languages that bolt on a foreign function interface, Jac is natively Python: the output is pure Python modules with a thin, principled runtime library written in pure Python with a small set of primitives needed to realize Jac-specific semantics. That means:

\begin{itemize}
    \item You can import Jac modules from Python with familiar syntax. (thanks to PEP 302)
    \item You can import Python modules from Jac with familiar syntax.
    \item You can embed native Python blocks directly inside Jac files for specialized needs.
    \item You can emit pure Python from any Jac program and import it from Python code without glue.
    \item Library elements that the Jac transpiler would generate (e.g., decorators and helper classes) are regular Python artifacts you can use directly in any Python code. (That is if for some reason you wanted to avoid using Jac's language syntax but still wanted to use Jac's semantics as a python library.)
\end{itemize}

\subsection{Jac in your Python Codebase}

Jac modules are importable from Python like regular modules. When you import \texttt{jaclang}, it installs a meta importer so that \texttt{.jac} files can be loaded natively by Python's import system.

\textbf{Native import (recommended)}

\begin{lstlisting}[language=Python]
import jaclang  # enable .jac imports

# If your project has a package "app/" with a Jac module app/logic.jac
import app.logic  # loads app/logic.jac

# Use exported classes/functions from the Jac module as usual
print(app.logic.__name__)
\end{lstlisting}

\textbf{Programmatic import (explicit control)}

For finer control over resolution, use the Jac API:

\begin{lstlisting}[language=Python]
from jaclang import JacMachine as Jac

# Import a Jac module by name relative to a base path (dir or __file__)
(mod,) = Jac.jac_import(target="hello_world", base_path=__file__)

# Work with exported archetypes (nodes, edges, walkers) and functions
print(dir(mod))
\end{lstlisting}

Notes:
\begin{itemize}
    \item \texttt{target} is the module name without \texttt{.jac}; \texttt{base\_path} is a directory or file path used to resolve relative imports.
    \item You can also import specific items with Python imports from Jac packages, e.g., \texttt{from mypkg.mymod import MyWalker} once the meta importer is active.
\end{itemize}

\subsection{Python in your Jac Codebase}

Import Python packages and symbols directly from Jac using familiar syntax. Non-\texttt{.jac} imports are forwarded to Python's importer.

\begin{jacblock}
// whole-module and aliased imports
import math;
import datetime as dt;

// selective imports with braces
import from typing { Optional, Tuple };
import from math { sqrt as square_root };

// include-style import (bring public names into scope)
include os.path;

with entry {
    x = square_root(16);
    print(dt.datetime.now());
}
\end{jacblock}

Module resolution mirrors Python's rules with support for relative paths and package layouts; Jac detects \texttt{.jac} vs Python modules automatically.

\subsection{Jac as a Python Library}

You can use Jac's runtime primitives from pure Python—no Jac syntax required. Define archetypes by subclassing Jac's base classes and annotate abilities with decorators provided by the API.

\begin{lstlisting}[language=Python]
from jaclang import JacMachineInterface as _
from jaclang.runtimelib.archetype import NodeArchetype, WalkerArchetype

class Person(NodeArchetype):
    name: str

class Greeter(WalkerArchetype):
    @_.entry
    def start(self, n: Person):
        print(f"Hello, {n.name}!")

if __name__ == "__main__":
    alice = Person(name="Alice")
    walker = Greeter()
    _.spawn(walker, alice)
\end{lstlisting}

Highlights:
\begin{itemize}
    \item Subclass \texttt{NodeArchetype}, \texttt{EdgeArchetype}, and \texttt{WalkerArchetype} to model graphs and behaviors.
    \item Use \texttt{@\_.entry} and \texttt{@\_.exit} to declare abilities; utilities like \texttt{\_.connect}, \texttt{\_.spawn}, \texttt{\_.report}, and \texttt{\_.printgraph} are available.
    \item Mix this with programmatic imports to load Jac modules and interact with them from Python.
\end{itemize}

\subsection{Inlining Python code inside Jac code}

For specialized needs, embed native Python directly within a Jac module using the \texttt{::py::} directive. The enclosed block is treated as Python and shares the module's namespace.

\begin{jacblock}
with entry {
    print("hello ");
}

::py::
def foo():
    print("world")

foo()
::py::
\end{jacblock}

Inline Python is ideal for leveraging Python-only libraries, quick interop, or migrating code incrementally. Symbols defined in a Python block are available to subsequent Jac code in the same module.

\section{A Well Organized Codebase}
Jac encourages clean separation between interfaces and implementations. You declare the shape of your module (functions, objects, enums, tests) once, and you may provide the bodies elsewhere. This is similar in spirit to ``header files'' in other ecosystems, but without manual include wiring—the compiler discovers implementation bodies automatically when you follow conventions.

\subsection*{Separate interface and implementation}
\begin{jacblock}
can foo() -> str;
obj vehicle;
enum Size;
test check_vehicle;

// implementations can live in the same file or elsewhere
impl foo() -> str { return "Hello"; }
impl vehicle { has name: str = "Car"; }
impl Size { Small=1, Medium=2, Large=3 }
\end{jacblock}

\subsection*{Keep implementations beside or under modules}
Three project layouts are common and supported:

\textbf{1) Same file as the declarations}

Simple modules can keep declarations and bodies together for local readability.

\textbf{2) Sibling ``.impl.jac'' and ``.test.jac'' files}

\begin{lstlisting}[language=shell]
base/
├── main.jac
├── main.impl.jac
└── main.test.jac
\end{lstlisting}

The compiler automatically discovers these sibling files. No extra imports are required.

\textbf{3) Dedicated ``.impl/'' and ``.test/'' folders}

\begin{lstlisting}[language=shell]
base/
├── main.jac
├── main.impl/
│   ├── foo.impl.jac
│   ├── vehicle.impl.jac
│   └── size.impl.jac
└── main.test/
    └── check_vehicle.test.jac
\end{lstlisting}

This layout scales well for large codebases. You can even place all implementations across the project under a single top-level directory (for example, \texttt{src/impl/}) while keeping your public interfaces minimal and readable.

\subsection*{Why this matters}
\begin{itemize}
    \item \textbf{Interface clarity}: Readers see what a module exposes without implementation noise.
    \item \textbf{Team velocity}: Different contributors can implement features without touching interface files.
    \item \textbf{Test hygiene}: Tests live beside modules but away from interfaces.
    \item \textbf{Refactoring safety}: Changing implementations rarely changes consumer-facing interfaces.
\end{itemize}

\subsection*{A quick checklist}
\begin{itemize}
    \item Declare public functions, objects, enums, and tests in your \texttt{.jac} module.
    \item Place bodies in \texttt{.impl.jac} siblings or an \texttt{.impl/} folder.
    \item Keep tests in \texttt{.test.jac} files or a \texttt{.test/} folder.
    \item Import Python libraries directly from Jac where helpful; prefer Jac idioms elsewhere.
    \item Emit pure Python when distributing to Python-only consumers.
\end{itemize}