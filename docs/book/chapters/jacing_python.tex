\chapter{From Python-ic to Jac-tastic: The Basics of Jac}

Coming from the previous chapter where we saw how Jac cleanly supersets Python and compiles to native Python, this chapter focuses on what it feels like to write everyday Jac. We walk through modules, definitions, control flow, and core expressions with side-by-side intuitions for Python developers. This chapter focuses on the key differences between Jac and Python, anything not covered can be assumed to work exactly the same as in Python.

The transition from Python to Jac is deliberately gentle. Rather than forcing you to learn an entirely new syntax, Jac preserves Python's expressiveness while introducing clearer structural elements and more powerful abstractions. The most visible changes—braces for blocks and semicolons for statements—might seem like a step backward to Python purists, but they serve a crucial purpose: they make program structure explicit and unambiguous, enabling better tooling, clearer error messages, and more sophisticated compile-time analysis.

As you work through this chapter, you'll notice that Jac doesn't just change syntax for the sake of being different. Each modification addresses a specific pain point in Python development. Type annotations become mandatory where they matter most, eliminating entire classes of runtime errors. Module initialization becomes explicit through entry blocks, solving Python's sometimes confusing top-level execution model. New operators like pipes and concurrent execution primitives make common patterns more expressive. By the end of this chapter, you'll understand not just how to write Jac, but why these design choices lead to more maintainable and scalable code.

\section{What a Jac Module Looks Like}

Understanding Jac's module structure is your gateway to productive Jac development. While the surface syntax differs from Python with its braces and semicolons, the underlying module model remains familiar. Jac modules are still files, imports still create a module graph, and execution still follows predictable rules. What changes is how you express these concepts—more explicitly, more clearly, and with better separation of concerns.

A minimal Jac module uses familiar Pythonic elements with a few clear syntactic conventions (braces for blocks, semicolons to terminate statements), plus Jac's entry block for top-level execution. Let's examine a complete module that demonstrates the key elements:

\begin{jacblock}
"""An optional module docstring"""

import math;
import datetime as dt;
import from typing { Optional, Tuple };
include os.path;

let:priv mode = "development";
glob:pub API_VERSION = "2.1";

def circle_area(r: float) -> float {
    return math.pi * r * r;
}

obj Person {
    has name: str = "Alice";   # `has` fields must be typed
}

enum Size { Small=1, Medium=2, Large=3 }

with entry {
    who = Person();
    print(f"Hello, {who.name}! Today is {dt.datetime.now().date()}");
    print(circle_area(3.0));
    print(f"Mode={mode}, API={API_VERSION}");
}
\end{jacblock}

This module showcases several fundamental Jac concepts. The docstring works exactly as in Python, becoming the module's \texttt{\_\_doc\_\_} attribute. Imports demonstrate Jac's enhanced syntax while maintaining Python's semantics. The \texttt{let} and \texttt{glob} declarations introduce module-level constants and variables with explicit visibility modifiers. Functions, objects, and enums show Jac's approach to defining types and behavior. Finally, the \texttt{with entry} block contains the executable code that runs when the module loads.

The structure enforces a clean separation between declaration and execution. In Python, top-level code executes as the module loads, which can lead to initialization order problems and makes it harder to reason about when side effects occur. Jac's entry blocks make execution points explicit—you always know exactly what code runs at module load time and in what order.

\subsection{Whitespace and Comments}

The shift from significant whitespace to explicit delimiters represents one of Jac's most visible departures from Python. This change isn't arbitrary—it enables more robust tooling, clearer error recovery, and easier code generation while maintaining readability through conventional indentation.

Jac uses braces to delimit blocks and semicolons to terminate statements. Indentation is for readability, not structure. Two comment forms are supported:

\begin{itemize}
    \item Line comments start with \texttt{\#} and continue to end of line
    \item Block comments are delimited with \texttt{\#*} and \texttt{*\#}
\end{itemize}

\begin{jacblock}
# This is a line comment
#*
This is a block comment
spanning multiple lines
*#

with entry {
    if 1 < 2 {
        print("yes");  # trailing comment
    }
}
\end{jacblock}

The addition of block comments addresses a long-standing Python limitation. While Python developers have learned to work around the lack of multi-line comments using triple-quoted strings or editor features, having true block comments makes it easier to temporarily disable code sections, write longer explanations, or include structured documentation that shouldn't become docstrings.

Modules may optionally begin with a top-level string literal which acts like a module docstring and is preserved through compilation. This docstring becomes accessible through the module's \texttt{\_\_doc\_\_} attribute, maintaining compatibility with Python documentation tools.

\subsection{Import and Include Statements}

Jac's import system extends Python's with ergonomic improvements that address common pain points. The brace syntax for selective imports eliminates ambiguity in complex import lists, while the `include` statement provides a cleaner alternative to wildcard imports.

Imports mirror Python with a couple of ergonomic enhancements. You can import whole modules, alias them, selectively import symbols with braces, or \emph{include} all public names into the current scope:

\begin{jacblock}
// whole-module and aliased imports
import math;
import datetime as dt;

// selective imports with braces (from one module)
import from typing { Optional, Tuple };
import from math { sqrt as square_root };

// include-style import (bring public names into scope)
include os.path;

// relative selective import ("from ..pkg import {...}")
import from ..utils { helper };
\end{jacblock}

The brace syntax for selective imports solves several problems with Python's comma-separated lists. It's visually clearer, especially with many imports. It eliminates the ambiguity between importing multiple items and importing a single item with multiple names. It also works better with automatic formatting tools, which can more easily manage additions and deletions to the import list.

Jac automatically resolves whether a target is a Jac or Python module and uses the right importer. The brace form avoids ambiguities of comma-heavy import lists, and `include` behaves like Python's `from target import *`, while still cooperating with tooling. The `include` statement makes the intent explicit—you're deliberately bringing all public names into scope, not accidentally using a wildcard import. This clarity helps both human readers and static analysis tools understand the code's dependencies.

\subsection{Entry blocks as the module's runnable code}

One of Python's subtle complexities is determining what code runs when a module loads versus when it's imported versus when it's run as a script. The \verb|if __name__ == "__main__"| idiom, while powerful, often confuses newcomers and can lead to unexpected behavior in complex import scenarios. Jac's entry blocks provide a clearer, more explicit model.

Instead of free-floating top-level statements, Jac uses `with entry { ... }` blocks to declare executable code that should run when the module is executed or imported-as-main. You may define multiple entry blocks; they execute from top to bottom:

\begin{jacblock}
with entry {
    print("Booting module...");
}

with entry:__main__ {
    // Named entry point; helpful for clarity and tooling
    print("Running as a script");
}
\end{jacblock}

Named entry blocks like \texttt{entry:\_\_main\_\_} provide semantic labels that tools can recognize. While functionally equivalent to unnamed entry blocks, they communicate intent and enable IDE features like "run configuration" detection. Multiple entry blocks execute in source order, allowing you to organize initialization logic into logical phases.

\paragraph{Module level globals, and with entry in class bodies}

The distinction between declaration and execution extends throughout Jac's design. Module-level variables must be declared with `let` or `glob`, making their scope and mutability explicit. Executable initialization code goes in entry blocks, whether at module level or within class definitions.

Use `let` to declare module-level constants and `glob` to declare program-wide mutable variables; both support access modifiers like `:priv`, `:protect`, and `:pub`. Names are defined at import time, while executable statements—whether at the module level or inside class/archetype bodies—belong in `with entry { ... }` blocks. In short, declare with `let`/`glob`, then run with `with entry`:

\begin{jacblock}
let:priv config = "development";
glob:pub shared_counter = 0;

with entry {
    # Executable code that can read/write declared variables
    print(config);
    shared_counter += 1;
}

obj Registry {
    static def register() -> None {
        # registration logic ...
    }

    with entry {
        # executed when the module defines this object/class
        Registry.register();
    }
}

class Legacy {
    with entry {
        print("Legacy class loaded");
    }
}
\end{jacblock}

The `let` keyword declares immutable bindings—the name cannot be reassigned, though mutable objects can still be modified. The `glob` keyword declares mutable module-level variables. Both support visibility modifiers that affect what other modules can access. The `:priv` modifier makes a name module-private, `:protect` allows access within the package hierarchy, and `:pub` makes it fully public.

In short: `let`/`glob` define names; `with entry` runs code—both at the module top level and within class/archetype bodies. This separation ensures that declaration order doesn't affect execution order, eliminating a common source of subtle bugs in Python programs.

\section{Functions, Classes, and Enums}

Jac's approach to defining functions, classes, and enumerations balances familiarity for Python developers with improvements in type safety and expressiveness. The requirement for type annotations isn't just about catching errors—it's about making code's intent explicit and enabling better tooling and optimization.

Jac supports traditional functions, Python-like classes via the `obj` archetype, and enumerations. Signatures are explicit and type-annotated. This explicitness serves multiple purposes: it documents intent, enables better IDE support, allows for more aggressive optimization, and catches entire categories of errors at compile time rather than runtime.

\paragraph{Functions}

The mandate for type annotations in Jac functions reflects a fundamental philosophy: explicit is better than implicit when it comes to interfaces. While Python's gradual typing allows you to add types incrementally, Jac requires them upfront for function parameters, ensuring that every function's contract is clear.

Jac is type-safety first: \textbf{parameter type annotations are required} for all functions (including methods and abilities), and return types (inferred to be None when omitted):

\begin{jacblock}
def distance(x1: float, y1: float, x2: float, y2: float) -> float {
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
}
\end{jacblock}

This requirement might seem restrictive to Python developers accustomed to duck typing, but it provides immense value in practice. Type annotations serve as inline documentation, enable better IDE autocomplete and refactoring, catch errors earlier in the development cycle, and allow the Jac compiler to generate more efficient code. The return type can be omitted (defaulting to `None`) but specifying it explicitly improves clarity.

\paragraph{Objects (classes)}

Jac provides two ways to define classes, each optimized for different use cases. The `obj` keyword creates dataclass-like structures with automatic initialization and comparison methods. The traditional `class` keyword provides full control over class behavior, matching Python's semantics exactly.

Use `obj` to define classes; fields are declared with `has` and \textbf{must include a type}. Defaults (when provided) should be compatible with the declared type. Methods use `def`. Access control modifiers `:priv`, `:protect`, and `:pub` are available, and `static` methods work as you'd expect:

\begin{jacblock}
obj Calculator {
    has scale: float = 1.0;

    def :pub add(a: float, b: float) -> float {
        return a + b;
    }

    static def mul(a: float, b: float) -> float {
        return a * b;
    }
}
\end{jacblock}

The `obj` archetype represents Jac's opinion on how most classes should be structured: fields are declared upfront with types, initialization is automatic based on these declarations, and common methods like equality comparison are synthesized. This approach eliminates boilerplate while ensuring consistency. The `has` keyword explicitly marks instance fields, making the class structure immediately apparent.

\paragraph{Traditional classes}

Sometimes you need the full flexibility of Python's class model—custom initialization logic, dynamic attribute creation, or complex inheritance patterns. For these cases, Jac provides the `class` keyword with traditional Python semantics.

If you want familiar Python class semantics without Jac's field machinery, use `class`. You typically initialize attributes in an explicit constructor and manage methods exactly like in Python:

\begin{jacblock}
class Counter {
    def __init__(start: int = 0) {
        self.value = start;
    }

    def inc() -> None { self.value += 1; }

    def read() -> int { return self.value; }
}
\end{jacblock}

This mirrors traditional Python classes: no automatic field generation, no synthesized constructor beyond what you write, and full control over attribute creation and invariants. Choose `class` when you need this control—for example, when implementing complex initialization logic, maintaining invariants between multiple fields, or working with metaclasses and descriptors.

\paragraph{`obj` has dataclass-like semantics}

Understanding how `obj` translates to Python helps clarify when to use it versus traditional classes. The `obj` archetype isn't just syntactic sugar—it represents a different philosophy about class design, one that favors explicit structure and automatic behavior generation.

By contrast, `obj` favors declarative data modeling. Fields declared with `has` carry types and defaults; Jac synthesizes the usual constructor and comparison/representation behavior. During the Python AST emission phase, an `obj` is lowered to a Python class decorated like a `dataclasses.dataclass`, with annotated attributes and default values:

\begin{jacblock}
obj Person {
    has name: str = "Alice";
    has age: int = 0;

    def label() -> str { return f"{self.name} ({self.age})"; }
}
\end{jacblock}

An illustrative Python shape of the generated class (simplified):

\begin{lstlisting}[language=Python]
from dataclasses import dataclass

@dataclass
class Person:
    name: str = "Alice"
    age: int = 0

    def label(self) -> str:
        return f"{self.name} ({self.age})"
\end{lstlisting}

Notes:
\begin{itemize}
    \item `has` fields become annotated attributes with defaults; Jac emits the appropriate dataclass decorator in the Python AST.
    \item Instance methods in `obj` are regular methods; `static def` lowers to `@staticmethod`.
    \item Choose `class` when you want raw Python-class control; choose `obj` when you want concise, dataclass-style data modeling with stronger type intent.
\end{itemize}

The `obj` approach encourages thinking about classes as structured data with attached behavior, rather than as arbitrary collections of attributes and methods. This mental model aligns well with modern software design practices and makes code easier to understand and maintain.

Abstract declarations use `abs` and can be implemented later (often in `impl` blocks or subclasses):

\begin{jacblock}
obj Shape {
    def area() -> float abs;
}

obj Rectangle(Shape) {
    has width: float;
    has height: float;

    def area() -> float { return self.width * self.height; }
}
\end{jacblock}

Abstract methods in Jac work similarly to Python's `abc.abstractmethod`, but with cleaner syntax. The `abs` keyword marks a method as abstract, requiring concrete implementation in subclasses. This provides compile-time checking of interface compliance, catching errors that would only appear at runtime in Python.

\paragraph{Enumerations}

Enumerations in Jac provide a type-safe way to represent fixed sets of values. They compile to Python's `enum.Enum`, ensuring compatibility with existing code while providing cleaner syntax and better type checking.

Enumerations behave like Python's `enum.Enum`, with simple declarations and optional implementation blocks for behavior:

\begin{jacblock}
enum Color { RED=1, GREEN=2, BLUE }

enum Day;

impl Day {
    MON=1, TUE=2, WED=3, THU=4, FRI=5, SAT=6, SUN=7,

    def is_weekend(self) -> bool { return self in [Day.SAT, Day.SUN]; }
}
\end{jacblock}

The ability to separate enum declaration from implementation follows Jac's general pattern of separating interface from implementation. You can declare that an enum exists, then provide its values and methods in an implementation block. This separation is particularly valuable in large codebases where you want to define interfaces in one place and implementations elsewhere.

\paragraph{A note on abilities}

While not the focus of this basics chapter, Jac also provides object–spatial abilities with `can`, which execute in response to spatial events (e.g., walker entry/exit on nodes). We'll revisit this paradigm in later chapters. These abilities represent one of Jac's most innovative features, enabling reactive programming patterns that are difficult to express in traditional object-oriented languages.

\section{Loops, Conditionals, and Lambdas}

Control flow in Jac follows Python's semantics while adopting more conventional syntax. The use of braces instead of indentation might initially feel foreign to Python developers, but it provides advantages in terms of clarity, tooling, and error recovery.

\paragraph{Conditionals}

Jac's conditional statements work exactly like Python's, just with explicit block delimiters. The boolean operators (`and`, `or`, `not`) and comparison operators remain unchanged, preserving Python's expressive condition syntax.

Jac uses Pythonic boolean operators with explicit blocks:

\begin{jacblock}
if score >= 90 {
    grade = "A";
} elif score >= 80 {
    grade = "B";
} else {
    grade = "C";
}
\end{jacblock}

The explicit blocks eliminate ambiguity about which statements belong to which condition, especially in complex nested structures. This clarity becomes particularly valuable when refactoring code or when multiple developers work on the same codebase.

\paragraph{For-in and for-to-by loops}

Jac provides two loop forms: the familiar `for-in` loop for iteration and the `for-to-by` loop for explicit counter control. The latter provides a more readable alternative to `range()` for simple counting loops.

Iterate over iterables using `for x in xs { ... }`, or use the explicit counter form `for init to condition by increment { ... }`:

\begin{jacblock}
for ch in "abc" { print(ch); }

for i in range(3) {
    print(i);  // 0,1,2
}

for i=0 to i<3 by i+=1 {
    print(i);
}
\end{jacblock}

The `for-to-by` syntax makes the loop's behavior explicit: initialization, termination condition, and increment are all visible at the loop header. This form is particularly useful for loops that don't follow the simple "count from 0 to n-1" pattern, eliminating the need to decode complex `range()` calls.

Asynchronous iteration mirrors Python:

\begin{jacblock}
async for item in stream {
    await consume(item);
}
\end{jacblock}

Async iteration in Jac works identically to Python, using the same event loop and coroutine mechanisms. This compatibility ensures that Jac code can seamlessly work with Python's extensive async ecosystem.

\paragraph{Lambdas}

Lambdas in Jac maintain Python's single-expression limitation while requiring type annotations for parameters. This requirement ensures that lambdas are as type-safe as regular functions.

Lambdas are single-expression and \textbf{must annotate all parameters with types}. They're great for functional-style helpers; return types are inferred from the body expression:

\begin{jacblock}
square = lambda x: int : x * x;
combine = lambda a: int, b: int : a + b;

nums = [1, 2, 3, 4, 5];
evens = filter(lambda x: int : x % 2 == 0, nums);
\end{jacblock}

The type annotation syntax for lambdas might seem verbose compared to Python, but it provides the same benefits as typed functions: better error detection, clearer intent, and improved tooling support. The return type is inferred from the expression, maintaining some of the conciseness that makes lambdas useful.

\section{Operators and Expressions}

Jac extends Python's expression syntax with new operators that address common patterns in modern software development. These additions don't replace Python's operators but augment them with higher-level constructs that make certain patterns more expressive.

Jac's expression grammar extends Python's with a few extras. The high-level precedence is conditional > lambda > concurrency (flow/wait) > walrus > pipes > bitwise > logical/compare > arithmetic > connect > atom. Understanding this precedence is crucial for writing correct Jac code, especially when combining multiple operators in a single expression.

\paragraph{Assignments and annotations}

Jac provides multiple ways to declare and assign variables, each with specific semantics. The `let` keyword creates immutable bindings, type annotations document and enforce types, and the walrus operator enables assignment expressions.

You can use `let` for declaration, annotate with types, and use walrus `:=` for named expressions:

\begin{jacblock}
let count: int = 0;
ratio: float = total / max(count, 1);

if (n := len(items)) > 0 {
    avg = sum(items) / n;
}
\end{jacblock}

The `let` keyword creates an immutable binding—the variable cannot be reassigned, though mutable objects can still be modified. This immutability by default encourages functional programming patterns and makes code easier to reason about. Type annotations on assignments help catch type errors early and document the expected types of variables.

\paragraph{Logical and comparison operators}

Jac preserves Python's rich set of logical and comparison operators, including the ability to chain comparisons and use English-like keywords for boolean operations.

Use `and`, `or`, `not`, `in`, `not in`, `is`, and `is not`, with chained comparisons supported:

\begin{jacblock}
ok = (0 <= x <= 10) and (item in allowed);
\end{jacblock}

Chained comparisons remain one of Python's most elegant features, and Jac preserves them unchanged. The ability to write `0 <= x <= 10` instead of `0 <= x and x <= 10` makes mathematical conditions more readable and less error-prone.

\paragraph{Pipe operators}

The pipe operators represent one of Jac's most useful additions for functional programming patterns. They allow you to chain operations in a natural left-to-right or right-to-left flow, making data transformation pipelines more readable.

Pipe an expression forward or backward through call sites using `|>` and `<|`:

\begin{jacblock}
result = data |> normalize |> transform |> summarize;
final  = render <| format <| result;
\end{jacblock}

Forward pipes (`|>`) pass the left operand as the first argument to the right operand, enabling Unix-pipe-like composition. Backward pipes (`<|`) work in reverse, useful when you want to write the operations in the order they'll execute but still maintain a pipeline style. These operators eliminate the need for deeply nested function calls or intermediate variables in data processing code.

\paragraph{F-strings}

Formatted string literals work exactly as in Python, providing a powerful and readable way to construct strings with embedded expressions.

Formatted string literals are fully supported, including format specs:

\begin{jacblock}
name = "Alice"; score = 92.5;
msg = f"Hello, {name}. Score={score:.1f}";
\end{jacblock}

F-strings in Jac support all of Python's formatting mini-language, including width specifications, alignment, number formatting, and custom format specifiers. This compatibility ensures that string formatting code ports directly from Python without modification.

\section{Concurrency with \texttt{flow} and \texttt{wait}}

One of Jac's most practical innovations is its expression-level concurrency model. Rather than requiring separate async functions or complex threading code, Jac provides simple operators that make concurrent execution as easy as arithmetic.

Jac offers a simple, expression-level concurrency model using the `flow` and `wait` keywords. These integrate naturally into expressions (see precedence in this chapter's expression section) and map directly to Python's standard `concurrent.futures` thread pool APIs. This design makes concurrent programming accessible without requiring deep understanding of threading or async programming.

\paragraph{Basics}

The `flow` and `wait` operators provide a minimal but complete interface for concurrent execution. They handle the common case of "run this in the background and get the result later" without the ceremony of explicit thread management.

\begin{itemize}
    \item `flow <expr>`: schedule evaluation of `<expr>` on a background thread and return a task handle.
    \item `wait <expr>`: block until the task completes and return its result (propagates exceptions).
\end{itemize}

\begin{jacblock}
def compute(x: int) -> int { return x * x; }

with entry {
    # Fire-and-join
    t1 = flow compute(10);
    r1 = wait t1;          # => 100

    # Parallel map pattern
    nums   = [1, 2, 3, 4, 5];
    tasks  = [flow compute(n) for n in nums];
    results = [wait t for t in tasks];
    print(results);        # => [1, 4, 9, 16, 25]
}
\end{jacblock}

The parallel map pattern shown above is one of the most common uses of `flow`/`wait`. By creating all tasks before waiting for any of them, you ensure maximum parallelism. This pattern is so useful that it often eliminates the need for more complex parallel processing libraries.

`flow`/`wait` compose with other expressions and work anywhere an expression is valid, including inside comprehensions and argument lists. This composability makes it easy to add concurrency to existing code without restructuring it.

\paragraph{Under the hood}

Understanding the implementation of `flow`/`wait` helps you use them effectively. They're not magic—they're a thin, ergonomic wrapper around Python's robust concurrent.futures module.

`flow` submits the expression as a callable to a shared `ThreadPoolExecutor` and returns a `Future`-like handle; `wait` calls the underlying future's `.result()` to retrieve the value. This design makes Jac's concurrency predictable and Python-native:

\begin{itemize}
    \item Uses `concurrent.futures.ThreadPoolExecutor` under the hood.
    \item `wait` mirrors `Future.result()`, propagating exceptions raised in the worker.
    \item Best for I/O-bound or mixed workloads; CPU-bound speedups are subject to Python's GIL like ordinary threads.
\end{itemize}

The thread pool is shared across the entire program, with a default size based on CPU count. This sharing prevents thread explosion when using `flow` in multiple places. Exception propagation works naturally—if the background computation raises an exception, `wait` re-raises it in the calling thread, preserving stack traces for debugging.

You can freely mix `flow`/`wait` with asynchronous functions (`async def` and `await`) when appropriate; `flow` is thread-based, while `await` is event-loop based. Choose `flow` for blocking I/O or CPU-bound work; choose `async`/`await` for event-driven I/O where you need fine control over concurrency.

\section{Comprehensions}

Comprehensions are one of Python's most beloved features, and Jac not only preserves them but extends them with new forms that address common patterns. These extensions maintain the spirit of comprehensions—declarative, concise data transformation—while adding capabilities specific to Jac's programming model.

Jac supports Python-style list, set, dict, and generator comprehensions, with optional `if` filters and multiple `for` clauses:

\begin{jacblock}
nums = [1, 2, 3, 4, 5];
sq   = [x*x for x in nums];
ev   = {x for x in nums if x % 2 == 0};
mp   = {x: x*x for x in nums if x > 2};
gen  = (x*x for x in range(10));
\end{jacblock}

These comprehensions work exactly as in Python, including support for nested loops, multiple conditions, and complex expressions. They compile to the same bytecode as Python comprehensions, ensuring identical performance characteristics.

Comprehensions naturally compose with lambdas and function calls, and they work well within object–spatial code when iterating over collections of nodes/edges. This composability makes them particularly valuable in Jac's graph-based programming model, where you often need to transform or filter collections of connected entities.

\subsection{Filter comprehensions (Jac feature)}

Filter comprehensions provide a postfix filtering syntax that's more readable than traditional comprehension filters for certain patterns. They're particularly useful when the filtering logic is the primary operation.

Filter comprehensions provide a concise, chainable way to select elements from any collection-like expression. Predicates are boolean expressions evaluated against each element:

\begin{itemize}
    \item Syntax: `collection(?predicate1, predicate2, ...)`
    \item Each predicate must evaluate to `True` for the element to be kept
\end{itemize}

\begin{jacblock}
import random;

obj TestObj {
    has x: int = random.randint(0, 15),
        y: int = random.randint(0, 15),
        z: int = random.randint(0, 15);
}

with entry {
    random.seed(42);
    apple = [];
    for i=0 to i<100 by i+=1  {
        apple.append(TestObj());
    }

    // keep only items with 0 <= x <= 15 (always true in this example)
    print(apple(?x >= 0, x <= 15) == apple);
}
\end{jacblock}

Notes:
\begin{itemize}
    \item Multiple predicates are combined with logical AND
    \item Works on any atomic chain result: lists, edge refs, call results, etc.
\end{itemize}

Filter comprehensions shine when you need to apply multiple conditions to a collection. Instead of writing `[item for item in collection if cond1(item) and cond2(item) and cond3(item)]`, you can write `collection(?cond1, cond2, cond3)`, which is both more concise and clearer in intent.

\subsection{Assign comprehensions (Jac feature)}

Assign comprehensions solve a common pattern: updating multiple fields across all elements in a collection. Rather than writing loops or map operations with side effects, assign comprehensions provide a declarative way to express bulk updates.

Assign (bulk-assign) comprehensions apply field assignments to each element of a collection in-place and return the same collection reference. Useful for concise bulk updates:

\begin{itemize}
    \item Syntax: `collection(=field1=value1, field2=value2, ...)`
    \item Applies to every element in the target collection
    \item Supports chaining with subsequent operations
\end{itemize}

\begin{jacblock}
obj MyObj {
    has apple: int = 0,
        banana: int = 0;
}

with entry {
    x = MyObj();
    y = MyObj();
    mvar = [x, y](=apple=5, banana=7);
    print(mvar);
}
\end{jacblock}

The comprehension returns the (mutated) collection, enabling patterns like filtering then assigning, or vice versa, in a single readable chain. This chaining capability makes it easy to express complex transformations as a pipeline of operations, each clearly stating its purpose.

\section{Tests}

Testing is so fundamental to modern software development that Jac makes tests first-class citizens in the language. Rather than requiring a separate testing framework or special file naming conventions, Jac lets you write tests directly in your modules, right next to the code they test.

Tests are first-class with the `test` keyword. A test is a named (or anonymous) code block. Use assertions and helper code as usual:

\begin{jacblock}
test math_basics {
    assert (2 + 2) == 4;
    assert len([1,2,3]) == 3;
}

test {  // anonymous test
    x = [i for i in range(3)];
    assert x == [0,1,2];
}
\end{jacblock}

Tests in Jac are discovered automatically by the test runner, which finds all test blocks in your modules. Named tests provide better error reporting and can be run selectively, while anonymous tests are useful for quick checks or when testing generated code. The test blocks have access to the module's full scope, making it easy to test internal functions and classes without complex setup.

The integration of tests into the language itself encourages a development style where tests live close to the code they verify. This proximity makes it more likely that tests will be written and maintained, as they're not hidden away in a separate test directory but are part of the module's definition. When you modify a function, its tests are right there, reminding you to update them.

\section{Inlining Python}

Despite Jac's comprehensive feature set, there are times when you need to drop down to raw Python. Perhaps you're using a library with Python-specific idioms, gradually migrating existing code, or need access to Python features that don't yet have Jac equivalents. The inline Python feature provides a seamless escape hatch.

For specialized needs, embed native Python directly using `::py::`. The code shares the module's namespace and runs as ordinary Python:

\begin{jacblock}
with entry {
    print("hello ");
}

::py::
def foo():
    print("world")

foo()
::py::
\end{jacblock}

Inline Python is ideal for leveraging the broader Python ecosystem, quick interop, or incremental migration of existing Python into Jac. The Python code executes in the same namespace as the surrounding Jac code, meaning it can access Jac-defined variables, functions, and classes, and vice versa. This bidirectional visibility enables powerful integration patterns.

Common use cases for inline Python include:
\begin{itemize}
    \item Using Python libraries that rely on decorators or metaclasses not yet supported in Jac
    \item Implementing performance-critical sections using Python-specific optimizations
    \item Gradually migrating Python codebases by moving code into Jac modules piece by piece
    \item Accessing Python standard library features that use complex runtime introspection
    \item Prototyping with Python code before converting to idiomatic Jac
\end{itemize}

The ability to freely mix Jac and Python in the same file reduces the adoption barrier significantly. You don't have to convert everything at once—you can start with Jac for new code while keeping complex existing Python logic unchanged, then gradually refactor as you become comfortable with Jac's idioms.

\section{Putting It All Together}

Now that we've covered Jac's basic features, let's see how they combine in practice. The transition from Python to Jac isn't about learning entirely new concepts—it's about expressing familiar patterns more clearly and safely. The mandatory type annotations might feel constraining at first, but they quickly become second nature and pay dividends in code clarity and error prevention.

The structural differences—braces, semicolons, and entry blocks—serve a purpose beyond mere syntax. They make program structure unambiguous, enable better tooling, and clarify the distinction between declaration and execution. These changes address real pain points in Python development: the ambiguity of significant whitespace in generated code, the confusion around module initialization order, and the difficulty of determining what code runs when.

Jac's extensions to Python's expression syntax—pipe operators, flow/wait concurrency, and enhanced comprehensions—aren't just conveniences. They represent common patterns that deserve first-class support in the language. Pipes make data transformation pipelines readable. Flow/wait makes basic concurrency accessible. Filter and assign comprehensions eliminate boilerplate in collection manipulation.

The seamless interoperability with Python means you can adopt Jac incrementally. Start with a single module, perhaps one that would benefit from stronger typing or clearer structure. Use inline Python for complex sections you're not ready to convert. Import your existing Python libraries without modification. As you grow comfortable with Jac's patterns, expand its use throughout your codebase.

Most importantly, remember that Jac isn't asking you to abandon your Python knowledge—it's asking you to enhance it. Every Python skill you've developed remains valuable. Every library you know still works. Every pattern you've learned still applies. Jac simply provides better ways to express these patterns, with stronger guarantees and clearer intent.

In the next chapter, we'll explore one of Jac's most innovative features: Object-Spatial Programming. This paradigm shift from thinking about isolated objects to thinking about connected entities in space opens up new ways to model complex systems. But even as we venture into new territory, the foundation remains the familiar Python you know, enhanced with the Jac features you've just learned.


