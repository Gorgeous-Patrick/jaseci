\chapter{From Python-ic to Jac-tastic: The Basics of Jac}

Coming from the previous chapter where we saw how Jac cleanly supersets Python and compiles to native Python, this chapter focuses on what it feels like to write everyday Jac. We walk through modules, definitions, control flow, and core expressions with side-by-side intuitions for Python developers. This chapter focuses on the key differences between Jac and Python, anything not covered can be assumed to work exactly the same as in Python.

\section{What a Jac Module Looks Like}

A minimal Jac module uses familiar Pythonic elements with a few clear syntactic conventions (braces for blocks, semicolons to terminate statements), plus Jac's entry block for top-level execution.

\begin{jacblock}
"""An optional module docstring"""

import math;
import datetime as dt;
import from typing { Optional, Tuple };
include os.path;

let:priv mode = "development";
glob:pub API_VERSION = "2.1";

def circle_area(r: float) -> float {
    return math.pi * r * r;
}

obj Person {
    has name: str = "Alice";   # `has` fields must be typed
}

enum Size { Small=1, Medium=2, Large=3 }

with entry {
    who = Person();
    print(f"Hello, {who.name}! Today is {dt.datetime.now().date()}");
    print(circle_area(3.0));
    print(f"Mode={mode}, API={API_VERSION}");
}
\end{jacblock}

\subsection{Whitespace and Comments}

Jac uses braces to delimit blocks and semicolons to terminate statements. Indentation is for readability, not structure. Two comment forms are supported:

\begin{itemize}
    \item Line comments start with `#` and continue to end of line
    \item Block comments are delimited with `#*` and `*#`
\end{itemize}

\begin{jacblock}
# This is a line comment
#*
This is a block comment
spanning multiple lines
*#

with entry {
    if 1 < 2 {
        print("yes");  # trailing comment
    }
}
\end{jacblock}

Modules may optionally begin with a top-level string literal which acts like a module docstring and is preserved through compilation.

\subsection{Import and Include Statements}

Imports mirror Python with a couple of ergonomic enhancements. You can import whole modules, alias them, selectively import symbols with braces, or \emph{include} all public names into the current scope.

\begin{jacblock}
// whole-module and aliased imports
import math;
import datetime as dt;

// selective imports with braces (from one module)
import from typing { Optional, Tuple };
import from math { sqrt as square_root };

// include-style import (bring public names into scope)
include os.path;

// relative selective import ("from ..pkg import {...}")
import from ..utils { helper };
\end{jacblock}

Jac automatically resolves whether a target is a Jac or Python module and uses the right importer. The brace form avoids ambiguities of comma-heavy import lists, and `include` behaves like Python's `from target import *`, while still cooperating with tooling.

\subsection{Entry blocks as the module's runnable code}

Instead of free-floating top-level statements, Jac uses `with entry { ... }` blocks to declare executable code that should run when the module is executed or imported-as-main. You may define multiple entry blocks; they execute from top to bottom.

\begin{jacblock}
with entry {
    print("Booting module...");
}

with entry:__main__ {
    // Named entry point; helpful for clarity and tooling
    print("Running as a script");
}
\end{jacblock}

\paragraph{Module level globals, and with entry in class bodies}

Use `let` to declare module-level constants and `glob` to declare program-wide mutable variables; both support access modifiers like `:priv`, `:protect`, and `:pub`. Names are defined at import time, while executable statements—whether at the module level or inside class/archetype bodies—belong in `with entry { ... }` blocks. In short, declare with `let`/`glob`, then run with `with entry`.

\begin{jacblock}
let:priv config = "development";
glob:pub shared_counter = 0;

with entry {
    # Executable code that can read/write declared variables
    print(config);
    shared_counter += 1;
}

obj Registry {
    static def register() -> None {
        # registration logic ...
    }

    with entry {
        # executed when the module defines this object/class
        Registry.register();
    }
}

class Legacy {
    with entry {
        print("Legacy class loaded");
    }
}
\end{jacblock}

In short: `let`/`glob` define names; `with entry` runs code—both at the module top level and within class/archetype bodies.

\section{Functions, Classes, and Enums}

Jac supports traditional functions, Python-like classes via the `obj` archetype, and enumerations. Signatures are explicit and type-annotated.

\paragraph{Functions}

Jac is type-safety first: \textbf{parameter type annotations are required} for all functions (including methods and abilities), and return types (inferred to be None when omitted).

\begin{jacblock}
def distance(x1: float, y1: float, x2: float, y2: float) -> float {
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
}
\end{jacblock}

\paragraph{Objects (classes)}

Use `obj` to define classes; fields are declared with `has` and \textbf{must include a type}. Defaults (when provided) should be compatible with the declared type. Methods use `def`. Access control modifiers `:priv`, `:protect`, and `:pub` are available, and `static` methods work as you'd expect.

\begin{jacblock}
obj Calculator {
    has scale: float = 1.0;

    def :pub add(a: float, b: float) -> float {
        return a + b;
    }

    static def mul(a: float, b: float) -> float {
        return a * b;
    }
}
\end{jacblock}

\paragraph{Traditional classes}

If you want familiar Python class semantics without Jac's field machinery, use `class`. You typically initialize attributes in an explicit constructor and manage methods exactly like in Python.

\begin{jacblock}
class Counter {
    def __init__(start: int = 0) {
        self.value = start;
    }

    def inc() -> None { self.value += 1; }

    def read() -> int { return self.value; }
}
\end{jacblock}

This mirrors traditional Python classes: no automatic field generation, no synthesized constructor beyond what you write, and full control over attribute creation and invariants.

\paragraph{`obj` has dataclass-like semantics}

By contrast, `obj` favors declarative data modeling. Fields declared with `has` carry types and defaults; Jac synthesizes the usual constructor and comparison/representation behavior. During the Python AST emission phase, an `obj` is lowered to a Python class decorated like a `dataclasses.dataclass`, with annotated attributes and default values.

\begin{jacblock}
obj Person {
    has name: str = "Alice";
    has age: int = 0;

    def label() -> str { return f"{self.name} ({self.age})"; }
}
\end{jacblock}

An illustrative Python shape of the generated class (simplified):

\begin{lstlisting}[language=Python]
from dataclasses import dataclass

@dataclass
class Person:
    name: str = "Alice"
    age: int = 0

    def label(self) -> str:
        return f"{self.name} ({self.age})"
\end{lstlisting}

Notes:
\begin{itemize}
    \item `has` fields become annotated attributes with defaults; Jac emits the appropriate dataclass decorator in the Python AST.
    \item Instance methods in `obj` are regular methods; `static def` lowers to `@staticmethod`.
    \item Choose `class` when you want raw Python-class control; choose `obj` when you want concise, dataclass-style data modeling with stronger type intent.
\end{itemize}

Abstract declarations use `abs` and can be implemented later (often in `impl` blocks or subclasses):

\begin{jacblock}
obj Shape {
    def area() -> float abs;
}

obj Rectangle(Shape) {
    has width: float;
    has height: float;

    def area() -> float { return self.width * self.height; }
}
\end{jacblock}

\paragraph{Enumerations}

Enumerations behave like Python's `enum.Enum`, with simple declarations and optional implementation blocks for behavior.

\begin{jacblock}
enum Color { RED=1, GREEN=2, BLUE }

enum Day;

impl Day {
    MON=1, TUE=2, WED=3, THU=4, FRI=5, SAT=6, SUN=7,

    def is_weekend(self) -> bool { return self in [Day.SAT, Day.SUN]; }
}
\end{jacblock}

\paragraph{A note on abilities}

While not the focus of this basics chapter, Jac also provides object–spatial abilities with `can`, which execute in response to spatial events (e.g., walker entry/exit on nodes). We'll revisit this paradigm in later chapters.


\section{Loops, Conditionals, and Lambdas}

\paragraph{Conditionals}

Jac uses Pythonic boolean operators with explicit blocks.

\begin{jacblock}
if score >= 90 {
    grade = "A";
} elif score >= 80 {
    grade = "B";
} else {
    grade = "C";
}
\end{jacblock}

\paragraph{For-in and for-to-by loops}

Iterate over iterables using `for x in xs { ... }`, or use the explicit counter form `for init to condition by increment { ... }`.

\begin{jacblock}
for ch in "abc" { print(ch); }

for i in range(3) {
    print(i);  // 0,1,2
}

for i=0 to i<3 by i+=1 {
    print(i);
}
\end{jacblock}

Asynchronous iteration mirrors Python:

\begin{jacblock}
async for item in stream {
    await consume(item);
}
\end{jacblock}

\paragraph{Lambdas}

Lambdas are single-expression and \textbf{must annotate all parameters with types}. They’re great for functional-style helpers; return types are inferred from the body expression.

\begin{jacblock}
square = lambda x: int : x * x;
combine = lambda a: int, b: int : a + b;

nums = [1, 2, 3, 4, 5];
evens = filter(lambda x: int : x % 2 == 0, nums);
\end{jacblock}

\section{Operators and Expressions}

Jac's expression grammar extends Python's with a few extras. The high-level precedence is conditional > lambda > concurrency (flow/wait) > walrus > pipes > bitwise > logical/compare > arithmetic > connect > atom.

\paragraph{Assignments and annotations}

You can use `let` for declaration, annotate with types, and use walrus `:=` for named expressions.

\begin{jacblock}
let count: int = 0;
ratio: float = total / max(count, 1);

if (n := len(items)) > 0 {
    avg = sum(items) / n;
}
\end{jacblock}

\paragraph{Logical and comparison operators}

Use `and`, `or`, `not`, `in`, `not in`, `is`, and `is not`, with chained comparisons supported.

\begin{jacblock}
ok = (0 <= x <= 10) and (item in allowed);
\end{jacblock}

\paragraph{Pipe operators}

Pipe an expression forward or backward through call sites using `|>` and `<|`.

\begin{jacblock}
result = data |> normalize |> transform |> summarize;
final  = render <| format <| result;
\end{jacblock}

\paragraph{F-strings}

Formatted string literals are fully supported, including format specs.

\begin{jacblock}
name = "Alice"; score = 92.5;
msg = f"Hello, {name}. Score={score:.1f}";
\end{jacblock}

\section{Concurrency with \texttt{flow} and \texttt{wait}}

Jac offers a simple, expression-level concurrency model using the `flow` and `wait` keywords. These integrate naturally into expressions (see precedence in this chapter’s expression section) and map directly to Python’s standard `concurrent.futures` thread pool APIs.

\paragraph{Basics}

\begin{itemize}
    \item `flow <expr>`: schedule evaluation of `<expr>` on a background thread and return a task handle.
    \item `wait <expr>`: block until the task completes and return its result (propagates exceptions).
\end{itemize}

\begin{jacblock}
def compute(x: int) -> int { return x * x; }

with entry {
    # Fire-and-join
    t1 = flow compute(10);
    r1 = wait t1;          # => 100

    # Parallel map pattern
    nums   = [1, 2, 3, 4, 5];
    tasks  = [flow compute(n) for n in nums];
    results = [wait t for t in tasks];
    print(results);        # => [1, 4, 9, 16, 25]
}
\end{jacblock}

`flow`/`wait` compose with other expressions and work anywhere an expression is valid, including inside comprehensions and argument lists.

\paragraph{Under the hood}

`flow` submits the expression as a callable to a shared `ThreadPoolExecutor` and returns a `Future`-like handle; `wait` calls the underlying future’s `.result()` to retrieve the value. This design makes Jac’s concurrency predictable and Python-native:

\begin{itemize}
    \item Uses `concurrent.futures.ThreadPoolExecutor` under the hood.
    \item `wait` mirrors `Future.result()`, propagating exceptions raised in the worker.
    \item Best for I/O-bound or mixed workloads; CPU-bound speedups are subject to Python’s GIL like ordinary threads.
\end{itemize}

You can freely mix `flow`/`wait` with asynchronous functions (`async def` and `await`) when appropriate; `flow` is thread-based, while `await` is event-loop based.

\section{Comprehensions}

Jac supports Python-style list, set, dict, and generator comprehensions, with optional `if` filters and multiple `for` clauses.

\begin{jacblock}
nums = [1, 2, 3, 4, 5];
sq   = [x*x for x in nums];
ev   = {x for x in nums if x % 2 == 0};
mp   = {x: x*x for x in nums if x > 2};
gen  = (x*x for x in range(10));
\end{jacblock}

Comprehensions naturally compose with lambdas and function calls, and they work well within object–spatial code when iterating over collections of nodes/edges.

\subsection{Filter comprehensions (Jac feature)}

Filter comprehensions provide a concise, chainable way to select elements from any collection-like expression. Predicates are boolean expressions evaluated against each element.

\begin{itemize}
    \item Syntax: `collection(?predicate1, predicate2, ...)`
    \item Each predicate must evaluate to `True` for the element to be kept
\end{itemize}

\begin{jacblock}
import random;

obj TestObj {
    has x: int = random.randint(0, 15),
        y: int = random.randint(0, 15),
        z: int = random.randint(0, 15);
}

with entry {
    random.seed(42);
    apple = [];
    for i=0 to i<100 by i+=1  {
        apple.append(TestObj());
    }

    // keep only items with 0 <= x <= 15 (always true in this example)
    print(apple(?x >= 0, x <= 15) == apple);
}
\end{jacblock}

Notes:
\begin{itemize}
    \item Multiple predicates are combined with logical AND
    \item Works on any atomic chain result: lists, edge refs, call results, etc.
\end{itemize}

\subsection{Assign comprehensions (Jac feature)}

Assign (bulk-assign) comprehensions apply field assignments to each element of a collection in-place and return the same collection reference. Useful for concise bulk updates.

\begin{itemize}
    \item Syntax: `collection(=field1=value1, field2=value2, ...)`
    \item Applies to every element in the target collection
    \item Supports chaining with subsequent operations
\end{itemize}

\begin{jacblock}
obj MyObj {
    has apple: int = 0,
        banana: int = 0;
}

with entry {
    x = MyObj();
    y = MyObj();
    mvar = [x, y](=apple=5, banana=7);
    print(mvar);
}
\end{jacblock}

The comprehension returns the (mutated) collection, enabling patterns like filtering then assigning, or vice versa, in a single readable chain.

\section{Tests}

Tests are first-class with the `test` keyword. A test is a named (or anonymous) code block. Use assertions and helper code as usual.

\begin{jacblock}
test math_basics {
    assert (2 + 2) == 4;
    assert len([1,2,3]) == 3;
}

test {  // anonymous test
    x = [i for i in range(3)];
    assert x == [0,1,2];
}
\end{jacblock}

\section{Inlining Python}

For specialized needs, embed native Python directly using `::py::`. The code shares the module's namespace and runs as ordinary Python.

\begin{jacblock}
with entry {
    print("hello ");
}

::py::
def foo():
    print("world")

foo()
::py::
\end{jacblock}

Inline Python is ideal for leveraging the broader Python ecosystem, quick interop, or incremental migration of existing Python into Jac.