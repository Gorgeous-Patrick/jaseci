\chapter{Building an Agentic AI Application with Jac}

Throughout the previous chapters, you've learned about Jac's foundational concepts: how it supersets Python while adding powerful abstractions, the shift from object-oriented to object-spatial programming, native AI integration through meaning-typed programming, and constructs for infinite scale. This chapter brings all these concepts together in a comprehensive, step-by-step implementation of a real-world agentic AI application—a multi-agent task manager that demonstrates every major Jac feature in a cohesive, practical system.

The application we'll build showcases the power of combining Jac's object-spatial programming model with AI agents. Rather than a monolithic AI system, we'll create specialized agents that collaborate through a shared object-spatial environment. Each agent handles specific domains—task management, email automation, and general conversation—while maintaining context through persistent sessions and coordinating through a sophisticated routing system.

What makes this example particularly valuable is how naturally Jac's features compose. The object-spatial programming model provides the architectural foundation, with nodes representing different agent capabilities and walkers orchestrating interactions between them. AI integration through the \texttt{by} keyword transforms complex natural language processing into simple function signatures. The root node ensures persistence without explicit database management. Together, these features enable building sophisticated AI systems with remarkable clarity and maintainability.

As you work through this implementation, pay attention to how each Jac feature serves a specific architectural purpose. The object-spatial model isn't just different syntax—it's a fundamentally better way to express the connected, collaborative nature of modern AI systems. The AI integration isn't just convenient syntax—it's a paradigm shift that eliminates the accidental complexity typically associated with AI programming. The scale constructs aren't just persistence helpers—they're the foundation for building systems that work equally well for one user or millions.

\section{Project Architecture Overview}

Before diving into implementation details, it's crucial to understand the overall architecture of our agentic task manager. The system demonstrates a sophisticated multi-agent architecture where specialized AI agents collaborate through a shared object-spatial environment, each handling specific domains while maintaining context through persistent sessions.

\subsection{System Design Using Object-Spatial Programming}

The architecture leverages Jac's object-spatial programming model to create a natural representation of agent collaboration. Rather than thinking in terms of isolated objects exchanging messages, we model the system as a connected graph where agents navigate through shared spaces, accessing and modifying persistent state through object-spatial relationships.

At the foundation level, we have a \texttt{Memory} node connected to the root that serves as the persistent anchor for all system state. Connected to this memory are \texttt{Session} nodes that maintain conversation history and context for individual interactions. This object-spatial organization means that persistence happens automatically—anything connected to the root persists, while temporary computation happens in disconnected spaces.

The agent architecture builds on this foundation with specialized \texttt{Toolbox} nodes that encapsulate domain-specific AI capabilities. Rather than monolithic AI systems, we create focused agents: \texttt{TaskHandling} for schedule management, \texttt{EmailHandling} for communication automation, and \texttt{GeneralChat} for conversational fallback. Each toolbox implements the same interface but provides radically different behaviors through AI delegation.

\subsection{Agent Orchestration Through Walkers}

Walkers in our system serve as the active components that orchestrate agent interactions. The primary \texttt{agent} walker acts as a sophisticated router, analyzing incoming requests and dynamically instantiating the appropriate toolbox nodes. This walker demonstrates several advanced Jac patterns: dynamic node creation, object-spatial navigation for context retrieval, and AI-powered decision making for routing logic.

Supporting walkers handle auxiliary operations: \texttt{get\_all\_sessions} provides session management capabilities, while \texttt{get\_all\_tasks} enables task retrieval across the system. These walkers showcase how Jac's object-spatial model makes complex queries simple—finding all tasks becomes a straightforward graph traversal rather than complex database operations.

\subsection{AI Integration Architecture}

The AI integration demonstrates Jac's meaning-typed programming in action. Rather than explicit prompt engineering and response parsing, we use the \texttt{by} keyword to delegate implementation to AI models based on semantic intent inferred from function signatures and context. This approach eliminates the boilerplate typically associated with AI programming while providing sophisticated capabilities.

The system uses multiple AI integration patterns: simple function delegation for tasks like translation and summarization, method delegation for context-aware operations, and advanced tool composition using the ReAct methodology. Semantic annotations through the \texttt{sem} keyword provide additional guidance to AI models, ensuring reliable behavior while maintaining declarative simplicity.

\section{Step-by-Step Implementation}

Now we'll build the complete system step by step, starting with foundational utilities and progressing through increasingly sophisticated features. Each step demonstrates specific Jac capabilities while building toward a complete, production-ready application.

\subsection{Step 1: Setting up the Foundation}

We begin with the utility functions and global configuration that support the entire system. This demonstrates Jac's module system, import syntax, and global variable management.

\begin{jacblock}
import from datetime { datetime }

def get_current_datetime() -> str {
    return str(datetime.now());
}
\end{jacblock}

This simple utility showcases Jac's import syntax with braces for selective imports. The function provides current timestamp functionality that we'll use throughout the system for tracking creation times and scheduling information.

Next, we establish the core architectural foundation with the agent core module:

\begin{jacblock}
import from dotenv { load_dotenv }
import sys;
include utils;

node Memory {}

node Session {
    has history: list = [];
    has created_at: str = get_current_datetime();

    def add_history(entry: str) {
        self.history = self.history + [entry];
    }
    def get_history -> str {
        return "\n".join(self.history[-10:]);
    }
}
\end{jacblock}

Here we see several key Jac features in action. The \texttt{include} statement brings utility functions into scope without explicit prefixing. The \texttt{Memory} node serves as a simple anchor point, while \texttt{Session} demonstrates Jac's object model with typed fields using \texttt{has} declarations and methods that operate on instance state.

\subsection{Step 2: Building the Spatial Foundation}

The session management showcases how Jac's object-spatial model naturally handles state persistence and context management. Notice how the \texttt{add\_history} method builds conversation context by appending entries, while \texttt{get\_history} provides the last 10 entries for AI context—a common pattern in conversational AI systems.

\begin{jacblock}
node Toolbox {
    def route_and_run(utterance: str, history: str) -> str abs;
    can execute with agent entry {
        session = visitor.session;
        response = self.route_and_run(visitor.utterance, session.get_history());
        session.add_history(
            "user: " + visitor.utterance + "\nai: " + response
        );
        report {
            "session_id": jid(visitor.session),
            "response": response
        };
    }
}
\end{jacblock}

The \texttt{Toolbox} node demonstrates several advanced Jac concepts. The abstract method \texttt{route\_and\_run} establishes a contract that all toolbox implementations must fulfill. The \texttt{can execute} ability shows how nodes respond to walker visits, accessing walker state through \texttt{visitor} and updating session history automatically. The \texttt{jid} function converts node references to persistent identifiers.

\subsection{Step 3: Creating the Agent Core}

The core agent walker demonstrates sophisticated routing logic and dynamic node instantiation:

\begin{jacblock}
enum RoutingNodes {
    GENERAL_CHAT = "GeneralChat"
}

walker agent {
    has utterance: str = "";
    has session_id: str = "";

    obj __specs__ {
        static has auth: bool = False;
    }
    def get_node_class(class_name: str) {
        main_mod = sys.modules.get("__main__");
        if main_mod and hasattr(main_mod, class_name) {
            return getattr(main_mod, class_name, None);
        }

        for (mod_name, mod) in sys.modules.items() {
            if mod and hasattr(mod, class_name) {
                return getattr(mod, class_name);
            }
        }
        return None;
    }
    def route_to_node(utterance: str, history: str) -> RoutingNodes abs;
\end{jacblock}

This walker showcases several sophisticated patterns. The \texttt{\_\_specs\_\_} object provides metadata about walker behavior, including authentication requirements. The \texttt{get\_node\_class} method demonstrates Python interoperability, dynamically loading classes from the module system. The abstract \texttt{route\_to\_node} method will be implemented through AI delegation in specialized walker variants.

The main execution logic demonstrates the power of Jac's object-spatial programming:

\begin{jacblock}
    can execute with `root entry {
        memory_list = [root --> (`?Memory)];
        if not memory_list {
            memory_list = root ++> Memory();
        }
        memory = memory_list[0];
        if not self.session_id {
            session_list = memory ++> Session();
            self.session = session_list[0];
        } else {
            self.session = &(self.session_id);
        }
        routed_node = self.route_to_node(self.utterance, self.session.get_history());
        node_cls = self.get_node_class(routed_node.value);
        if not node_cls {
            print("Failed to get node class");
            return;
        }
        node_inst = node_cls();
        visit [-->(`?node_cls)] else {
            attached_routed_node = here ++> node_inst;
            visit attached_routed_node;
        }
    }
\end{jacblock}

The walker navigates to the root node, ensuring a Memory node exists, then either retrieves an existing session or creates a new one. The routing logic uses AI to determine which toolbox to instantiate, then dynamically creates and visits the appropriate node. The \texttt{visit} statement with fallback logic shows how object-spatial navigation handles both existing and new nodes gracefully.

\subsection{Step 4: Implementing AI-Powered Toolboxes}

Now we implement the specialized toolbox nodes that demonstrate Jac's AI integration capabilities:

\begin{jacblock}
import from mtllm.llm { Model }
import from email.mime.text { MIMEText }
import smtplib;
import os;
include agent_core;

glob llm = Model(model_name="gpt-4o", verbose=False);

enum RoutingNodes {
    GENERAL_CHAT = "GeneralChat",
    TASK_HANDLING = "TaskHandling",
    EMAIL_HANDLING = "EmailHandling"
}

node Task {
    has task:str = "";
    has date:str = "";
    has time:str = "";
    has status: str = "pending";
}
\end{jacblock}

Here we see the global LLM model configuration and the expanded routing enum. The \texttt{Task} node demonstrates Jac's approach to data modeling—simple, typed fields that represent domain entities directly.

The \texttt{TaskHandling} node showcases sophisticated AI integration:

\begin{jacblock}
node TaskHandling(Toolbox) {
    def add_task(task: Task) -> str;
    def check_scheduled_tasks -> list[Task];
    def extract_task_info(utterance: str) -> Task by llm(
        method="ReAct",
        tools=([self.add_task, get_current_datetime])
    );
    def summarize_tasks() -> str by llm(
        method="ReAct",
        tools=([self.check_scheduled_tasks])
    );
    def route_and_run(utterance: str, history: str) -> str by llm(
        method="ReAct",
        tools=([self.extract_task_info, self.summarize_tasks])
    );
}
\end{jacblock}

Methods like \texttt{extract\_task\_info} use the \texttt{by llm()} delegation with ReAct methodology and tool composition. The AI model can call the \texttt{add\_task} method and \texttt{get\_current\_datetime} function as tools, enabling complex reasoning about task scheduling.

\subsection{Step 5: Advanced AI Integration with Semantic Annotations}

The implementation blocks demonstrate how Jac separates interface from implementation while providing semantic guidance to AI models:

\begin{jacblock}
# Implementation of TaskHandling
impl TaskHandling.add_task {
    self ++> task;
    return "Task added successfully";
}
impl TaskHandling.check_scheduled_tasks {
    return [self --> (`?Task)];
}

sem TaskHandling.extract_task_info = "time and date should be extracted in the format of 'YYYY-MM-DD HH:MM:SS'.";
sem TaskHandling.route_and_run = "Select and Execute only one tool provided.";
sem TaskHandling.summarize_tasks = "Summarize the tasks in a concise manner. But all relevant task information should be included.";
\end{jacblock}

The \texttt{impl} blocks provide concrete implementations for abstract methods. Notice how \texttt{add\_task} uses object-spatial connection (\texttt{++>}) to attach tasks to the toolbox node, automatically making them persistent. The \texttt{check\_scheduled\_tasks} method demonstrates object-spatial queries to retrieve connected tasks.

The \texttt{sem} annotations provide semantic guidance to AI models without cluttering the interface definitions. This separation of concerns keeps the code clean while ensuring AI models have the context they need for reliable behavior.

\subsection{Step 6: Email Automation with Error Handling}

The email handling node demonstrates more complex AI integration with external service interaction:

\begin{jacblock}
node EmailHandling(Toolbox) {
    has sender_email: str = os.getenv("SENDER_EMAIL");
    has sender_password: str = os.getenv("SENDER_PASSWORD");
    has sender_name: str = os.getenv("SENDER_NAME");

    def write_email_content(utterance: str, history: str) -> str by llm();
    def send_email(email_content: str, email_subject: str, email_to: str) -> None;
    def route_and_run(utterance: str, history: str) -> str by llm(
        method="ReAct",
        tools=([self.write_email_content, self.send_email])
    );
}
\end{jacblock}

This node shows how Jac handles configuration through environment variables and combines AI delegation with traditional programming for external service integration. The implementation demonstrates robust error handling:

\begin{jacblock}
impl EmailHandling.send_email {
    msg = MIMEText(email_content);
    msg["Subject"] = email_subject;
    msg["From"] = self.sender_email;
    msg["To"] = email_to;

    try {
        server = smtplib.SMTP("smtp.gmail.com", 587);
        server.starttls();
        server.login(self.sender_email, self.sender_password);
        server.sendmail(self.sender_email, email_to, msg.as_string());
        server.quit();
    }
    except Exception as e {
        print(f"Failed to send email to {email_to} with subject '{email_subject}': {e}");
    }
}

sem EmailHandling.route_and_run = """
Step 1: Extract the email content, subject, and recipient from the user's utterance.
- Generate a complete draft of the email.
- Use 'Hi' as the greeting if the recipient name is not mentioned.
- Show the draft to the user and ask for confirmation.

Step 2: If the user confirms (yes), send the email.
If the user says no, either re-draft based on feedback or cancel.
Never send without explicit confirmation.
""";
\end{jacblock}

The semantic annotation demonstrates how to provide complex behavioral guidance to AI models. The multi-step process with confirmation requirements ensures safe email automation while maintaining natural language interaction.

\subsection{Step 7: Walker Orchestration and System Integration}

The specialized walkers demonstrate different patterns for system interaction:

\begin{jacblock}
walker task_manager(agent) {
    def route_to_node(utterance: str, history: str) -> RoutingNodes by llm();
}

walker get_all_sessions {
    obj __specs__ {
        static has auth: bool = False;
    }
    can get_all_sessions with `root entry {
        memory_list = [here --> (`?Memory)];
        if not memory_list {
            report "No sessions found.";
            disengage;
        }
        memory = memory_list[0];
        session_list = [memory --> (`?Session)];
        report [{
            "id": jid(session),
            "created_at": session.created_at
        } for session in session_list];
    }
}
\end{jacblock}

The \texttt{task\_manager} walker extends the base \texttt{agent} walker, providing AI-powered routing specific to task management scenarios. The \texttt{get\_all\_sessions} walker demonstrates how object-spatial queries make complex data retrieval operations simple and readable.

Finally, the system initialization demonstrates Jac's entry block pattern:

\begin{jacblock}
with entry {
    load_dotenv();
}
\end{jacblock}

This simple entry block ensures environment variables are loaded when the module initializes, demonstrating how Jac makes module initialization explicit and predictable.

\section{Key Jac Features Demonstrated}

This implementation showcases virtually every major Jac feature in a cohesive, real-world application:

\subsection{Object-Spatial Programming}
\begin{itemize}
    \item \textbf{Nodes}: \texttt{Memory}, \texttt{Session}, \texttt{Task}, and toolbox nodes represent persistent entities with behavior
    \item \textbf{Walkers}: \texttt{agent}, \texttt{task\_manager}, and utility walkers orchestrate system interactions
    \item \textbf{Object-Spatial Navigation}: \texttt{-->}, \texttt{++>}, and \texttt{visit} operations manage relationships and traversal
    \item \textbf{Object-Spatial Queries}: List comprehensions with object-spatial filters retrieve connected entities
\end{itemize}

\subsection{AI Integration}
\begin{itemize}
    \item \textbf{Method Delegation}: \texttt{by llm()} transforms function signatures into AI-powered implementations
    \item \textbf{Tool Composition}: ReAct methodology enables AI models to use regular methods as tools
    \item \textbf{Semantic Annotations}: \texttt{sem} statements provide behavioral guidance without cluttering interfaces
    \item \textbf{Configuration}: Model parameters and reasoning modes control AI behavior
\end{itemize}

\subsection{Scale Constructs}
\begin{itemize}
    \item \textbf{Root Node}: Provides persistent anchor for all system state
    \item \textbf{Automatic Persistence}: Spatial connectivity determines what persists across program runs
    \item \textbf{Session Management}: User context maintained through persistent session nodes
    \item \textbf{Scalable Architecture}: Same code works for single user or multi-tenant scenarios
\end{itemize}

\subsection{Language Features}
\begin{itemize}
    \item \textbf{Module System}: Import and include statements with enhanced syntax
    \item \textbf{Type System}: Mandatory typing for node fields and function parameters
    \item \textbf{Abstract Methods}: Interface definitions with \texttt{abs} keyword
    \item \textbf{Implementation Blocks}: Separation of interface from implementation
    \item \textbf{Entry Blocks}: Explicit module initialization with \texttt{with entry}
    \item \textbf{Global Variables}: \texttt{glob} declarations for shared state
    \item \textbf{Enums}: Type-safe enumeration with string values
\end{itemize}

\section{Understanding the Architecture Choices}

Each architectural decision in this implementation serves specific purposes that demonstrate Jac's strengths:

\subsection{Why Object-Spatial Programming?}

Traditional object-oriented approaches would model this system as isolated classes with complex interaction protocols. The object-spatial model makes the collaborative nature of AI agents explicit—they share spaces, navigate between contexts, and maintain relationships through object-spatial connectivity rather than fragile object references.

The persistence model emerges naturally from object-spatial relationships. Rather than explicit save/load operations, entities persist by being connected to the root. This eliminates entire classes of bugs while making the persistence boundaries of the system explicit in the code structure.

\subsection{Why AI Delegation?}

The \texttt{by llm()} approach eliminates the boilerplate typically associated with AI programming while providing more reliable behavior than manual prompt engineering. By inferring intent from function signatures and type annotations, Jac enables AI integration that feels like natural programming rather than external service calls.

The tool composition pattern through ReAct methodology enables sophisticated AI reasoning while maintaining the benefits of typed interfaces. AI models can call regular methods as tools, creating a seamless boundary between AI-powered and traditional code.

\subsection{Why Semantic Annotations?}

The \texttt{sem} keyword provides a clean separation between interface definitions and behavioral guidance. This keeps the code readable while ensuring AI models have the context they need for reliable operation. The semantic annotations serve as documentation for both human developers and AI models.

\section{Production Considerations and Extensions}

While this implementation demonstrates Jac's capabilities, production deployments would benefit from additional considerations:

\subsection{Security and Authentication}

The \texttt{\_\_specs\_\_} objects provide hooks for authentication and authorization. Production systems should implement proper user authentication, session validation, and access control for sensitive operations like email sending.

\subsection{Error Handling and Monitoring}

The object-spatial model enables sophisticated error handling patterns. Failed operations can leave trace nodes that enable debugging and recovery. The persistent nature of the system makes it possible to implement comprehensive audit trails and monitoring.

\subsection{Extension Possibilities}

This foundation enables numerous extensions: adding new agent types by inheriting from \texttt{Toolbox}, supporting multi-user scenarios through root node architecture, integrating external services through additional toolbox nodes, and implementing advanced AI capabilities like multi-agent collaboration and adaptive behavior.

\section{Conclusion}

This comprehensive example demonstrates how Jac's features compose to enable building sophisticated AI systems with remarkable clarity and maintainability. The object-spatial programming model provides the architectural foundation, AI integration eliminates accidental complexity, and scale constructs ensure the system works across different deployment scenarios.

What makes this example particularly powerful is how naturally the features work together. The object-spatial model isn't just different syntax—it's a fundamentally better way to express collaborative AI systems. The AI integration isn't just convenient—it's a paradigm shift that makes AI programming feel like natural programming. The scale constructs aren't just persistence helpers—they're the foundation for building systems that adapt to any scale.

As you build your own Jac applications, remember that these patterns compose and extend. The architectural principles demonstrated here—object-spatial organization, AI delegation, semantic clarity—apply to systems far beyond task management. Whether you're building recommendation engines, content management systems, or complex multi-agent simulations, Jac provides the abstractions needed to express your ideas clearly and scale them effectively.

The future of software development lies not in managing complexity but in choosing the right abstractions that make complexity disappear. Jac represents one path toward that future—a language designed for the problems we face today and the opportunities we'll discover tomorrow.